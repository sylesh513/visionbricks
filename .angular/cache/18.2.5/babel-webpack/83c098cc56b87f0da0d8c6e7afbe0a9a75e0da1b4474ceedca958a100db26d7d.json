{"ast":null,"code":"import { NodeDialogComponent } from './node-dialog/node-dialog.component';\nimport Drawflow from 'drawflow';\nimport interact from 'interactjs';\nimport { io } from 'socket.io-client';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/material/dialog\";\nimport * as i2 from \"./socket.service\";\nimport * as i3 from \"@angular/common\";\nimport * as i4 from \"@angular/material/button\";\nfunction AppComponent_li_16_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r2 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"li\", 12);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementStart(2, \"button\", 13);\n    i0.ɵɵlistener(\"click\", function AppComponent_li_16_Template_button_click_2_listener() {\n      const i_r3 = i0.ɵɵrestoreView(_r2).index;\n      const ctx_r3 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r3.openEditDialog(i_r3));\n    });\n    i0.ɵɵtext(3, \" Edit \");\n    i0.ɵɵelementEnd()();\n  }\n  if (rf & 2) {\n    const item_r5 = ctx.$implicit;\n    const i_r3 = ctx.index;\n    i0.ɵɵattribute(\"data-node-name\", item_r5.name)(\"data-index\", i_r3);\n    i0.ɵɵadvance();\n    i0.ɵɵtextInterpolate1(\" \", item_r5.name, \" \");\n  }\n}\nconst socket = io('http://127.0.0.1:5000'); // Replace with your socket server URL\nexport let AppComponent = /*#__PURE__*/(() => {\n  class AppComponent {\n    dialog;\n    socketService;\n    drawflow;\n    id = null;\n    items = [{\n      name: 'Node 1',\n      params: '',\n      file: null\n    }];\n    newItemName = '';\n    taskUpdates = [];\n    jobStatus = '';\n    constructor(dialog, socketService) {\n      this.dialog = dialog;\n      this.socketService = socketService;\n    }\n    ngOnInit() {\n      this.id = document.getElementById('drawflow');\n      this.drawflow = new Drawflow(this.id);\n      this.drawflow.start();\n      this.socketService.getTaskUpdates().subscribe(taskUpdate => {\n        this.taskUpdates.push(taskUpdate);\n        // console.log('Task Update:', taskUpdate['task_name']);\n        // console.log('Task Updates:', taskUpdate['status']);\n        // this.updateNodeColor(taskUpdate['task_name'], taskUpdate['status']);\n        this.handleWebhookUpdate(taskUpdate['task_name'], taskUpdate['status']);\n      });\n      // Subscribe to job completion event\n      this.socketService.getJobCompletion().subscribe(jobCompletion => {\n        this.jobStatus = jobCompletion.status;\n        console.log('Job Completed:', jobCompletion);\n      });\n      // Handle case where execution is already in progress\n      this.socketService.getExecutionInProgress().subscribe(message => {\n        alert(message);\n      });\n      // Load workflow data from localStorage\n      const savedWorkflow = localStorage.getItem('workflowData');\n      if (savedWorkflow) {\n        this.importWorkflow(savedWorkflow);\n      }\n      // Initialize draggable items\n      interact('.draggable-item').draggable({\n        inertia: true,\n        autoScroll: true,\n        onstart: event => {\n          // Store the original position\n          const target = event.target;\n          const rect = target.getBoundingClientRect();\n          target.setAttribute('data-start-x', rect.left);\n          target.setAttribute('data-start-y', rect.top);\n        },\n        onmove: this.dragMoveListener,\n        onend: event => {\n          if (!event.target.dropzone) {\n            const startX = event.target.getAttribute('data-start-x');\n            const startY = event.target.getAttribute('data-start-y');\n            // Snap back to original position\n            event.target.style.transform = 'translate(0px, 0px)';\n            event.target.style.left = `${startX}px`;\n            event.target.style.top = `${startY}px`;\n            event.target.removeAttribute('data-x');\n            event.target.removeAttribute('data-y');\n          }\n        }\n      });\n      // Set up the dropzone\n      interact('#drawflow').dropzone({\n        accept: '.draggable-item',\n        // Accept items with class .draggable-item\n        overlap: 0.75,\n        ondrop: event => {\n          const nodeName = event.relatedTarget.getAttribute('data-node-name');\n          const x = event.dragEvent.clientX - event.target.getBoundingClientRect().left - 300;\n          const y = event.dragEvent.clientY - event.target.getBoundingClientRect().top - 40;\n          this.addNode(nodeName, x, y);\n        },\n        ondropdeactivate: event => {\n          const startX = event.relatedTarget.getAttribute('data-start-x');\n          const startY = event.relatedTarget.getAttribute('data-start-y');\n          event.relatedTarget.style.transform = 'translate(0px, 0px)';\n          event.relatedTarget.style.left = `${startX}px`;\n          event.relatedTarget.style.top = `${startY}px`;\n          event.relatedTarget.removeAttribute('data-x');\n          event.relatedTarget.removeAttribute('data-y');\n        }\n      });\n      this.drawflow.on('connectionCreated', event => {\n        console.log('Connection Created:', event);\n        const outputNode = this.drawflow.getNodeFromId(event.output_id);\n        const inputNode = this.drawflow.getNodeFromId(event.input_id);\n        if (outputNode.name === inputNode.name) {\n          alert('Error: Cannot connect two consecutive nodes with the same name!');\n          this.drawflow.removeSingleConnection(event.output_id, event.input_id, event.output_class, event.input_class);\n        } else if (this.hasCycle()) {\n          alert('Error: Cycle detected in the workflow!');\n          this.drawflow.removeSingleConnection(event.output_id, event.input_id, event.output_class, event.input_class);\n        }\n      });\n      this.id.addEventListener('dblclick', event => {\n        const target = event.target;\n        const nodeElement = target.closest('.drawflow-node');\n        if (nodeElement) {\n          const nodeId = nodeElement.id.replace('node-', '');\n          const node = this.drawflow.getNodeFromId(nodeId);\n          const index = this.items.findIndex(item => item.name === node.name);\n          console.log('Node Index:', index);\n          if (index !== -1) {\n            this.openEditDialog(index);\n          }\n        }\n      });\n    }\n    unloadNotification($event) {\n      // Save workflow data to localStorage before the user closes the tab or reloads the page\n      const workflowData = this.drawflow.export();\n      const processedData = this.processWorkflowData(workflowData);\n      localStorage.setItem('workflowData', JSON.stringify(processedData));\n    }\n    updateNodeColor(taskName, status) {\n      // Iterate through all nodes to find the one with the matching name\n      const nodes = this.drawflow.drawflow.drawflow[1].data; // Assuming you're working in the first module\n      for (const nodeId in nodes) {\n        if (nodes[nodeId].name === taskName) {\n          const nodeElement = document.querySelector(`#node-${nodeId}`);\n          if (nodeElement) {\n            let colorClass = '';\n            if (status === 'completed') {\n              colorClass = 'node-color-green';\n            } else if (status === 'in-progress') {\n              colorClass = 'node-color-blue';\n            } else if (status === 'failed') {\n              colorClass = 'node-color-red';\n            }\n            // Remove existing color classes\n            nodeElement.classList.remove('node-color-red', 'node-color-green', 'node-color-blue');\n            // Add new color class\n            nodeElement.classList.add(colorClass);\n          }\n          break;\n        }\n      }\n    }\n    openDialog() {\n      const dialogRef = this.dialog.open(NodeDialogComponent, {\n        width: '300px',\n        data: {\n          name: '',\n          mode: 'create',\n          params: ''\n        } // Initialize params\n      });\n      dialogRef.afterClosed().subscribe(result => {\n        if (result && result.action === 'create') {\n          this.newItemName = result.name;\n          const newItemParams = result.params;\n          if (typeof this.newItemName === 'string') {\n            this.items.push({\n              name: this.newItemName,\n              params: newItemParams,\n              file: result.file\n            });\n          }\n        }\n      });\n    }\n    openContextMenu(event, index) {\n      // Create a context menu\n      const contextMenu = document.createElement('div');\n      contextMenu.classList.add('context-menu');\n      contextMenu.style.top = `${event.clientY}px`;\n      contextMenu.style.left = `${event.clientX}px`;\n      // Add menu items\n      const editItem = document.createElement('div');\n      editItem.classList.add('context-menu-item');\n      editItem.innerText = 'Edit';\n      editItem.addEventListener('click', () => {\n        this.openEditDialog(index);\n        document.body.removeChild(contextMenu);\n      });\n      const deleteItem = document.createElement('div');\n      deleteItem.classList.add('context-menu-item');\n      deleteItem.innerText = 'Delete';\n      deleteItem.addEventListener('click', () => {\n        this.deleteItem(index);\n        document.body.removeChild(contextMenu);\n      });\n      contextMenu.appendChild(editItem);\n      contextMenu.appendChild(deleteItem);\n      // Remove any existing context menu\n      const existingMenu = document.querySelector('.context-menu');\n      if (existingMenu) {\n        document.body.removeChild(existingMenu);\n      }\n      // Add the context menu to the body\n      document.body.appendChild(contextMenu);\n      // Remove the context menu when clicking outside\n      document.addEventListener('click', () => {\n        if (contextMenu) {\n          document.body.removeChild(contextMenu);\n        }\n      }, {\n        once: true\n      });\n    }\n    dragMoveListener(event) {\n      const target = event.target;\n      const x = (parseFloat(target.getAttribute('data-x')) || 0) + event.dx;\n      const y = (parseFloat(target.getAttribute('data-y')) || 0) + event.dy;\n      target.style.transform = `translate(${x}px, ${y}px)`;\n      target.setAttribute('data-x', x);\n      target.setAttribute('data-y', y);\n    }\n    addNode(nodeName, x, y) {\n      var html = document.createElement('div');\n      html.innerHTML = nodeName;\n      this.drawflow.registerNode('test', html);\n      return this.drawflow.addNode(nodeName, 1, 1, x, y, 'github', this.items, 'test', true);\n    }\n    openEditDialog(index) {\n      const dialogRef = this.dialog.open(NodeDialogComponent, {\n        width: '300px',\n        // Set the desired width for the dialog\n        maxWidth: '100%',\n        // Ensure the dialog does not exceed the screen width\n        data: {\n          name: this.items[index].name,\n          params: this.items[index].params,\n          file: this.items[index].file,\n          // Include the file in the dialog data\n          index: index,\n          mode: 'edit'\n        }\n      });\n      dialogRef.afterClosed().subscribe(result => {\n        if (result && result.action === 'save') {\n          this.items[index].name = result.name;\n          this.items[index].params = result.params;\n          if (result.file) {\n            this.items[index].file = result.file; // Save the file with the node\n          }\n        } else if (result && result.action === 'delete') {\n          this.deleteItem(index);\n        }\n      });\n    }\n    // Assuming you have a webhook event that passes the node name and status\n    handleWebhookUpdate(newnodeName, newstatus) {\n      console.log(newnodeName);\n      console.log(newstatus);\n      // Find the node by name (or use node ID if you prefer)\n      const nodeId = this.findNodeIdByName(newnodeName);\n      if (nodeId) {\n        // Change node color based on status\n        this.changeNodeColor(nodeId, newstatus);\n      }\n    }\n    // Helper method to find node ID by its name\n    findNodeIdByName(nodeName) {\n      const nodes = this.drawflow.getNodesFromName(nodeName);\n      console.log(nodes); // You can also get node by ID\n      return nodes.length > 0 ? nodes[0].id : null;\n    }\n    // Helper method to change node color based on status\n    changeNodeColor(nodeId, status) {\n      // Get the DOM element for the node\n      const nodeElement = document.querySelector(`#node-${nodeId}`);\n      console.log(nodeElement);\n      if (nodeElement) {\n        // Apply different colors based on status\n        let color = '';\n        switch (status) {\n          case 'PENDING':\n            color = '#f1c40f'; // Yellow for pending\n            break;\n          case 'RUNNING':\n            color = '#3498db'; // Blue for running\n            break;\n          case 'COMPLETED':\n            color = '#2ecc71'; // Green for completed\n            break;\n          case 'FAILED':\n            color = '#e74c3c'; // Red for failed\n            break;\n          default:\n            color = '#cccccc'; // Default gray\n            break;\n        }\n        // Apply the new background color to the node element\n        nodeElement.style.backgroundColor = color;\n      }\n    }\n    uploadFile(file, index) {\n      // Implement the file upload logic here\n      const formData = new FormData();\n      formData.append('file', file);\n      // Store the file in the items array\n      this.items[index].file = file;\n      console.log(this.items);\n      // Use your preferred method to upload the file to the API\n      // Example using HttpClient:\n      // this.http.post('your-api-endpoint', formData).subscribe(response => {\n      //   console.log('File uploaded successfully', response);\n      // });\n    }\n    removeNodeFromDrawflow(index) {\n      const item = document.querySelector(`.draggable-item[data-index=\"${index}\"]`);\n      if (item) {\n        item.style.display = 'none';\n        setTimeout(() => {\n          item.style.display = '';\n        }, 0);\n      }\n    }\n    runWorkflow() {\n      // Check if each node has a file\n      for (const item of this.items) {\n        console.log(\"newnew\");\n        if (!item.file || !item.file.name || item.file.name === 'none' || item.file.name === '' || item.file.name === undefined) {\n          alert(`Error: Node \"${item.name}\" does not have an associated file.`);\n          return; // Stop the workflow from running\n        } else {\n          console.log(item.file.name);\n        }\n      }\n      console.log('Run workflow');\n      const workflowData = this.drawflow.export();\n      const processedData = this.processWorkflowData(workflowData);\n      // Send the processed data to the server\n      this.sendWorkflowData(processedData);\n    }\n    sendWorkflowData(workflowData) {\n      const formData = new FormData();\n      formData.append('workflowData', JSON.stringify(workflowData, null, 2));\n      // Append files to the formData\n      workflowData.nodes.forEach((node, index) => {\n        if (node.file) {\n          formData.append(node.name, node.file);\n        }\n      });\n      const url = 'http://127.0.0.1:5000/upload_workflow'; // Replace with your API endpoint\n      fetch(url, {\n        method: 'POST',\n        body: formData\n      }).then(response => response.json()).then(data => {\n        console.log('Workflow data uploaded successfully:', data);\n        this.socketService.runWorkflow();\n        // Listen for real-time updates from the server\n      }).catch(error => {\n        console.error('Error uploading workflow data:', error);\n      });\n      console.log('Sending workflow data to server:', workflowData);\n    }\n    createNode() {\n      const nodeNameInput = document.getElementById('nodeNameInput');\n      const nodeName = nodeNameInput.value;\n      if (nodeName) {\n        this.addNode(nodeName, 50, 50); // You can adjust the x and y coordinates as needed\n        nodeNameInput.value = ''; // Clear the input field after creating the node\n      } else {\n        alert('Please enter a node name');\n      }\n    }\n    addItem() {\n      if (this.newItemName) {\n        if (this.items.some(item => item.name === this.newItemName)) {\n          alert('Item with this name already exists');\n        } else {\n          this.items.push({\n            name: this.newItemName,\n            params: '',\n            file: null\n          });\n          this.newItemName = '';\n        }\n      } else {\n        alert('Please enter an item name');\n      }\n    }\n    deleteItem(index) {\n      this.items.splice(index, 1);\n      console.log(this.items);\n    }\n    importWorkflow(jsonData) {\n      this.items.length = 0; // Clear the items array\n      try {\n        const workflowData = JSON.parse(jsonData);\n        if (!this.drawflow) {\n          this.id = document.getElementById('drawflow');\n          this.drawflow = new Drawflow(this.id);\n          this.drawflow.start();\n        } else {\n          this.drawflow.clear(); // Clear the current Drawflow data\n        }\n        const nodeIdMap = new Map();\n        const nodeNamesSet = new Set(); // Set to track node names\n        // First, add all nodes to the Drawflow\n        workflowData.nodes.forEach(node => {\n          const nodeId = this.addNode(node.name, node.position.x, node.position.y); // Use positions\n          nodeIdMap.set(node.name, nodeId);\n          const drawflowNode = this.drawflow.getNodeFromId(nodeId);\n          drawflowNode.data = {\n            params: node.params,\n            file: node.file\n          };\n          // Check for duplicate node names\n          if (!nodeNamesSet.has(node.name)) {\n            nodeNamesSet.add(node.name);\n            this.items.push({\n              name: node.name,\n              params: JSON.stringify(node.params),\n              file: node.file\n            });\n          } else {\n            console.warn(`Duplicate node name found: ${node.name}. Skipping this node.`);\n          }\n        });\n        // Then, recreate connections\n        workflowData.nodes.forEach(node => {\n          node.connections.forEach(connection => {\n            const outputNodeId = nodeIdMap.get(node.name);\n            const inputNodeId = nodeIdMap.get(connection);\n            if (outputNodeId && inputNodeId) {\n              this.drawflow.addConnection(outputNodeId, inputNodeId, 'output_1', 'input_1');\n            }\n          });\n        });\n        console.log('Workflow imported successfully:', workflowData);\n      } catch (error) {\n        console.error('Error importing workflow data:', error);\n      }\n    }\n    onFileSelected(event) {\n      const file = event.target.files[0];\n      if (file) {\n        const reader = new FileReader();\n        reader.onload = e => {\n          const jsonData = e.target.result;\n          this.importWorkflow(jsonData);\n        };\n        reader.readAsText(file);\n      }\n    }\n    clearWorkflow() {\n      this.drawflow.clear();\n      this.items = [];\n      localStorage.removeItem('workflowData');\n    }\n    exportWorkflow() {\n      const workflowData = this.drawflow.export();\n      const processedData = this.processWorkflowData(workflowData);\n      console.log('Exported Workflow Data:', processedData);\n      if (processedData !== undefined) {\n        this.downloadWorkflow(processedData);\n      }\n    }\n    triggerFileInput() {\n      const fileInput = document.querySelector('input[type=\"file\"]');\n      if (fileInput) {\n        fileInput.click();\n      }\n    }\n    processWorkflowData(workflowData) {\n      const processedData = {\n        nodes: []\n      };\n      for (const key in workflowData.drawflow.Home.data) {\n        const node = workflowData.drawflow.Home.data[key];\n        const item = this.items.find(item => item.name === node.name);\n        const connections = [];\n        // Collect names of connected nodes\n        for (const outputKey in node.outputs) {\n          const outputConnections = node.outputs[outputKey].connections;\n          for (const connection of outputConnections) {\n            const connectedNode = workflowData.drawflow.Home.data[connection.node];\n            connections.push(connectedNode.name);\n          }\n        }\n        try {\n          processedData.nodes.push({\n            id: node.id,\n            name: node.name,\n            params: item.params ? JSON.parse(item.params) : {},\n            // Parse if params is a string\n            file: item ? item.file : null,\n            filePath: item && item.file ? item.file.path : null,\n            // Include full file path\n            connections: connections,\n            position: {\n              x: node.pos_x,\n              y: node.pos_y\n            } // Include positions\n          });\n        } catch (error) {\n          alert('Error parsing JSON parameters: ' + error.message);\n          return;\n        }\n      }\n      return processedData;\n    }\n    downloadWorkflow(workflowData) {\n      const dataStr = JSON.stringify(workflowData, null, 2);\n      const blob = new Blob([dataStr], {\n        type: 'application/json'\n      });\n      const url = URL.createObjectURL(blob);\n      const a = document.createElement('a');\n      a.href = url;\n      a.download = 'workflow.json';\n      document.body.appendChild(a);\n      a.click();\n      document.body.removeChild(a);\n      URL.revokeObjectURL(url);\n    }\n    hasCycle() {\n      const workflowData = this.drawflow.export();\n      const graph = this.buildGraph(workflowData);\n      return this.detectCycle(graph);\n    }\n    buildGraph(workflowData) {\n      const graph = new Map();\n      for (const key in workflowData.drawflow.Home.data) {\n        const node = workflowData.drawflow.Home.data[key];\n        graph.set(key, []);\n        for (const outputKey in node.outputs) {\n          const connections = node.outputs[outputKey].connections;\n          for (const connection of connections) {\n            graph.get(key).push(connection.node);\n          }\n        }\n      }\n      return graph;\n    }\n    detectCycle(graph) {\n      const visited = new Set();\n      const recStack = new Set();\n      const dfs = node => {\n        if (!visited.has(node)) {\n          visited.add(node);\n          recStack.add(node);\n          const neighbors = graph.get(node) || [];\n          for (const neighbor of neighbors) {\n            if (!visited.has(neighbor) && dfs(neighbor)) {\n              return true;\n            } else if (recStack.has(neighbor)) {\n              return true;\n            }\n          }\n        }\n        recStack.delete(node);\n        return false;\n      };\n      for (const node of graph.keys()) {\n        if (dfs(node)) {\n          return true;\n        }\n      }\n      return false;\n    }\n    static ɵfac = function AppComponent_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || AppComponent)(i0.ɵɵdirectiveInject(i1.MatDialog), i0.ɵɵdirectiveInject(i2.SocketService));\n    };\n    static ɵcmp = /*@__PURE__*/i0.ɵɵdefineComponent({\n      type: AppComponent,\n      selectors: [[\"my-app\"]],\n      hostBindings: function AppComponent_HostBindings(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵlistener(\"beforeunload\", function AppComponent_beforeunload_HostBindingHandler($event) {\n            return ctx.unloadNotification($event);\n          }, false, i0.ɵɵresolveWindow);\n        }\n      },\n      decls: 21,\n      vars: 1,\n      consts: [[\"fileInput\", \"\"], [\"drawflow\", \"\"], [1, \"header\"], [1, \"run-button\", 3, \"click\"], [\"type\", \"file\", \"accept\", \".json\", 1, \"import-button\", 2, \"display\", \"none\", 3, \"change\"], [1, \"container\"], [1, \"sidebar\"], [2, \"font-family\", \"system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif\", \"font-weight\", \"700\"], [\"id\", \"draggable-list\"], [\"class\", \"draggable-item\", \"draggable\", \"true\", 4, \"ngFor\", \"ngForOf\"], [\"mat-button\", \"\", 1, \"add-button\", 2, \"color\", \"rgb(104, 197, 197)\", \"background-color\", \"rgb(67, 67, 67)\", 3, \"click\"], [\"id\", \"drawflow\"], [\"draggable\", \"true\", 1, \"draggable-item\"], [1, \"edit-button\", 2, \"color\", \"rgb(104, 197, 197)\", \"background-color\", \"rgb(67, 67, 67)\", 3, \"click\"]],\n      template: function AppComponent_Template(rf, ctx) {\n        if (rf & 1) {\n          const _r1 = i0.ɵɵgetCurrentView();\n          i0.ɵɵelementStart(0, \"div\", 2)(1, \"button\", 3);\n          i0.ɵɵlistener(\"click\", function AppComponent_Template_button_click_1_listener() {\n            i0.ɵɵrestoreView(_r1);\n            return i0.ɵɵresetView(ctx.exportWorkflow());\n          });\n          i0.ɵɵtext(2, \"Export Workflow\");\n          i0.ɵɵelementEnd();\n          i0.ɵɵelementStart(3, \"button\", 3);\n          i0.ɵɵlistener(\"click\", function AppComponent_Template_button_click_3_listener() {\n            i0.ɵɵrestoreView(_r1);\n            return i0.ɵɵresetView(ctx.triggerFileInput());\n          });\n          i0.ɵɵtext(4, \"Import Workflow\");\n          i0.ɵɵelementEnd();\n          i0.ɵɵelementStart(5, \"input\", 4, 0);\n          i0.ɵɵlistener(\"change\", function AppComponent_Template_input_change_5_listener($event) {\n            i0.ɵɵrestoreView(_r1);\n            return i0.ɵɵresetView(ctx.onFileSelected($event));\n          });\n          i0.ɵɵelementEnd();\n          i0.ɵɵelementStart(7, \"button\", 3);\n          i0.ɵɵlistener(\"click\", function AppComponent_Template_button_click_7_listener() {\n            i0.ɵɵrestoreView(_r1);\n            return i0.ɵɵresetView(ctx.clearWorkflow());\n          });\n          i0.ɵɵtext(8, \"Clear\");\n          i0.ɵɵelementEnd();\n          i0.ɵɵelementStart(9, \"button\", 3);\n          i0.ɵɵlistener(\"click\", function AppComponent_Template_button_click_9_listener() {\n            i0.ɵɵrestoreView(_r1);\n            return i0.ɵɵresetView(ctx.runWorkflow());\n          });\n          i0.ɵɵtext(10, \"Run\");\n          i0.ɵɵelementEnd()();\n          i0.ɵɵelementStart(11, \"div\", 5)(12, \"div\", 6)(13, \"h1\", 7);\n          i0.ɵɵtext(14, \"Nodes List\");\n          i0.ɵɵelementEnd();\n          i0.ɵɵelementStart(15, \"ul\", 8);\n          i0.ɵɵtemplate(16, AppComponent_li_16_Template, 4, 3, \"li\", 9);\n          i0.ɵɵelementEnd();\n          i0.ɵɵelementStart(17, \"button\", 10);\n          i0.ɵɵlistener(\"click\", function AppComponent_Template_button_click_17_listener() {\n            i0.ɵɵrestoreView(_r1);\n            return i0.ɵɵresetView(ctx.openDialog());\n          });\n          i0.ɵɵtext(18, \"Add Node\");\n          i0.ɵɵelementEnd()();\n          i0.ɵɵelement(19, \"div\", 11, 1);\n          i0.ɵɵelementEnd();\n        }\n        if (rf & 2) {\n          i0.ɵɵadvance(16);\n          i0.ɵɵproperty(\"ngForOf\", ctx.items);\n        }\n      },\n      dependencies: [i3.NgForOf, i4.MatButton],\n      styles: [\":root{--border-color: #dfdfdf;--background-color: #ffffff;--background-box-title: rgb(171, 181, 234);--primary-color: #ffffff;--secondary-color: rgb(171, 181, 234);--highlight-color: #add7ff;--text-color: #979797;--button-color: #d1d1d1;--button-hover-color: #c7c7c7;--button-active-color: #cecfd0}html,body{margin:0;padding:0;width:100vw;height:100vh;overflow:hidden;font-family:Roboto,sans-serif;background-color:var(--background-color)}header{height:66px;border-bottom:1px solid var(--border-color);padding-left:20px}header h2{margin:0;line-height:66px}header a{color:#000}.them-edit-link{position:absolute;top:10px;right:100px;color:#000;font-size:40px}.them-edit-link a{text-decoration:none}.github-link{position:absolute;top:10px;right:20px;color:#000}.wrapper{width:100%;height:calc(100vh - 67px);display:flex}.col{overflow:auto;width:300px;height:100%;border-right:1px solid var(--border-color)}.drag-drawflow{line-height:50px;border-bottom:1px solid var(--border-color);padding-left:20px;cursor:move;-webkit-user-select:none;user-select:none}.menu{position:absolute;height:40px;display:block;background:#abb5ea;width:100%}.menu ul{padding:0;margin:0;line-height:40px}.menu ul li{display:inline-block;margin-left:10px;border-right:1px solid var(--border-color);padding-right:10px;line-height:40px;cursor:pointer}.menu ul li.selected{font-weight:700}.btn-export{float:right;position:absolute;top:10px;right:10px;color:#abb5ea;font-weight:700;border:1px solid #cbe3fa;background:var(--button-color);padding:5px 10px;border-radius:4px;cursor:pointer;z-index:5;transition:background-color .3s ease}.btn-export:hover{background:var(--button-hover-color)}.btn-export:active{background:var(--button-active-color)}.btn-clear{float:right;position:absolute;top:10px;right:85px;color:#abb5ea;font-weight:700;border:1px solid #96015b;background:#e3195a;padding:5px 10px;border-radius:4px;cursor:pointer;z-index:5}.swal-wide{width:80%!important}.btn-lock{float:right;position:absolute;bottom:10px;right:140px;display:flex;font-size:24px;color:#abb5ea;padding:5px 10px;background:#555;border-radius:4px;border-right:1px solid var(--border-color);z-index:5;cursor:pointer}.cursor-pointer{cursor:pointer}.edit-button{background:none;border:none;cursor:pointer;color:#007bff;font-size:16px}.bar-zoom{float:right;position:absolute;bottom:10px}.sidebar{display:flex;flex-direction:column;align-items:center}.add-button{margin-top:20px;background-color:#43b993}.bar-zoom{float:right;position:absolute;bottom:10px;right:10px;display:flex;font-size:24px;color:#abb5ea;padding:5px 10px;background:#555;border-radius:4px;border-right:1px solid var(--border-color);z-index:5}.bar-zoom svg{cursor:pointer;padding-left:10px}.bar-zoom svg:nth-child(1){padding-left:0}.floating-button{position:fixed;bottom:20px;right:20px;z-index:1000;background-color:#a1cffa;color:#000}#drawflow{padding-left:200px;display:flex;width:70%;height:100vh;top:40px;background:var(--background-color);background-size:25px 25px;background-image:linear-gradient(to right,#f1f1f1 1px,transparent 1px),linear-gradient(to bottom,#f1f1f1 1px,transparent 1px)}@media only screen and (max-width: 768px){.col{width:50px}.col .drag-drawflow span{display:none}#drawflow{width:calc(100vw - 51px)}}.drawflow .drawflow-node{height:60px;width:120px;display:flex;align-items:center;position:absolute;background:#d2fdfd;width:160px;min-height:40px;border-radius:4px;border:1px solid #907373;color:#000;z-index:2;padding:1px;text-align:center;font-weight:500;font-size:16px;transition:background-color .3s ease}.output-box{position:fixed;bottom:0;width:100%;height:150px;border:1px solid #ccc;padding:10px;box-sizing:border-box;resize:vertical;overflow:auto;background-color:#f9f9f9;-webkit-user-select:none;user-select:none}.output-box:after{content:\\\"\\\";display:block;height:100%;width:100%;position:absolute;top:0;left:0;z-index:1;pointer-events:none}.drawflow .drawflow-node.selected{background:#8994d2;transition:background-color .3s ease;border:1px solid var(--highlight-color);box-shadow:0 2px 20px 2px var(--highlight-color)}.drawflow .drawflow-node.selected .title-box{color:#4b95da}.drawflow .connection .main-path{stroke:#4b95da;stroke-width:3px}.drawflow .drawflow-node .input,.drawflow .drawflow-node .output{height:15px;width:15px;border:2px solid var(--border-color)}.drawflow .drawflow-node .input:hover,.drawflow .drawflow-node .output:hover{background:#badcfc}.node-color-red{background-color:red}.node-color-green{background-color:green}.node-color-blue{background-color:#00f}.drawflow .drawflow-node .output{right:10px}.drawflow .drawflow-node .input{left:-10px;background:#abb5ea}.drawflow>.drawflow-delete{border:2px solid #43b993;background:#abb5ea;color:#43b993;box-shadow:0 2px 20px 2px #43b993}.drawflow-delete{border:2px solid var(--highlight-color);background:#abb5ea;color:var(--highlight-color);box-shadow:0 2px 20px 2px var(--highlight-color)}.drawflow-node .title-box{height:50px;line-height:50px;background:var(--background-box-title);border-bottom:1px solid #e9e9e9;border-radius:10px 10px 0 0;padding-left:10px}.drawflow .title-box svg{position:initial}.drawflow-node .box{padding:10px 20px 20px;font-size:14px;color:var(--text-color)}.drawflow-node .box p{margin-top:5px;margin-bottom:5px}.drawflow-node.welcome{width:250px}.drawflow-node.slack .title-box{border-radius:4px}.drawflow-node input,.drawflow-node select,.drawflow-node textarea{border-radius:4px;border:1px solid var(--border-color);height:30px;line-height:30px;font-size:16px;width:158px;color:var(--text-color)}.drawflow-node textarea{height:100px}.drawflow-node.personalized{background:#f18080;height:200px;text-align:center;transition:background-color .3s ease}.drawflow-node.personalized .input{background:#ff0}.drawflow-node.personalized .output{background:green}.drawflow-node.personalized.selected{background:#b9b9f3}.drawflow .connection .point{stroke:var(--border-color);stroke-width:2;fill:#abb5ea;transform:translate(-9999px,-9999px)}.drawflow .connection .point.selected,.drawflow .connection .point:hover{fill:#a1cffa}.modal{display:none;position:fixed;z-index:7;left:0;top:0;width:100vw;height:100vh;overflow:auto;background-color:#000000b3}.modal-content{position:relative;background-color:#fefefe;margin:15% auto;padding:20px;border:1px solid #888;width:400px;border-radius:10px;animation:fadeIn .5s ease}.modal .close{color:#aaa;float:right;font-size:28px;font-weight:700;cursor:pointer}@media only screen and (max-width: 768px){.modal-content{width:80%}}body{overflow:auto}.container{display:flex;padding:10px}.sidebar{width:250px;margin-right:10px;padding:20px;background-color:var(--secondary-color);border-right:1px solid #ccc;border-radius:10px;box-shadow:0 2px 10px #0000001a;animation:slideIn .5s ease;align-items:center}#draggable-list{list-style-type:none;padding:0}.draggable-item{display:flex;justify-content:space-between;align-items:center;width:234px;padding:10px;margin:5px 0;background-color:#ddd;cursor:grab;border-radius:10px;transition:transform .1s ease,background-color .2s ease}.draggable-item:hover{background-color:#ccc}.draggable-item:active{cursor:grabbing;transform:scale(1.05)}.draggable-item input{flex-grow:1;margin-right:10px;border-radius:5px;padding:5px;border:1px solid var(--border-color)}.draggable-item button{margin-left:5px;padding:5px 10px;background-color:rgb(255,169,169)smoke;color:#abb5ea;border:none;border-radius:5px;cursor:pointer;transition:background-color .3s ease}.draggable-item button:hover{background-color:var(--button-hover-color)}.draggable-item button:active{background-color:var(--button-active-color)}button{padding:5px 20px;background-color:#8a2be2;color:#abb5ea;border:none;border-radius:10px;cursor:pointer;transition:background-color .3s ease}button:hover{background-color:var(--button-hover-color)}button:active{background-color:var(--button-active-color)}@keyframes fadeIn{0%{opacity:0}to{opacity:1}}@keyframes slideIn{0%{transform:translate(-100%)}to{transform:translate(0)}}.export-button{position:absolute;top:10px;right:20px;margin-bottom:20px;margin-right:40px}.header{display:flex;justify-content:flex-end;padding:10px;background-color:#f5f5f5}.run-button{background-color:#4caf50;border:none;color:#fff;padding:5px 10px;text-align:center;text-decoration:none;display:inline-block;font-size:16px;margin:4px 2px;cursor:pointer;border-radius:4px}.run-button:hover{background-color:#45a049}.floating-button{margin-left:10px}.context-menu{position:absolute;background-color:#fff;border:1px solid #ccc;box-shadow:0 2px 10px #0003;z-index:1000}.context-menu-item{padding:8px 12px;cursor:pointer}.context-menu-item:hover{background-color:#f5f5f5}\\n\"],\n      encapsulation: 2\n    });\n  }\n  return AppComponent;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}
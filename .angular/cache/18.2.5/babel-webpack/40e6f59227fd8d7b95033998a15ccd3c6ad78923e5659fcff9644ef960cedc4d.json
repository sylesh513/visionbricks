{"ast":null,"code":"import { __decorate } from \"tslib\";\nimport { Component, ViewEncapsulation, HostListener } from '@angular/core';\nimport { NodeDialogComponent } from './node-dialog/node-dialog.component';\nimport Drawflow from 'drawflow';\nimport interact from 'interactjs';\nimport { io } from 'socket.io-client';\nconst socket = io('http://127.0.0.1:5000'); // Replace with your socket server URL\nlet AppComponent = class AppComponent {\n  dialog;\n  socketSr;\n  drawflow;\n  id = null;\n  items = [{\n    name: 'Node 1',\n    params: '',\n    file: null\n  }];\n  newItemName = '';\n  constructor(dialog, socketSr) {\n    this.dialog = dialog;\n    this.socketSr = socketSr;\n  }\n  ngOnInit() {\n    this.id = document.getElementById('drawflow');\n    this.drawflow = new Drawflow(this.id);\n    this.drawflow.start();\n    // Load workflow data from localStorage\n    const savedWorkflow = localStorage.getItem('workflowData');\n    if (savedWorkflow) {\n      this.importWorkflow(savedWorkflow);\n    }\n    // Initialize draggable items\n    interact('.draggable-item').draggable({\n      inertia: true,\n      autoScroll: true,\n      onstart: event => {\n        // Store the original position\n        const target = event.target;\n        const rect = target.getBoundingClientRect();\n        target.setAttribute('data-start-x', rect.left);\n        target.setAttribute('data-start-y', rect.top);\n      },\n      onmove: this.dragMoveListener,\n      onend: event => {\n        if (!event.target.dropzone) {\n          const startX = event.target.getAttribute('data-start-x');\n          const startY = event.target.getAttribute('data-start-y');\n          // Snap back to original position\n          event.target.style.transform = 'translate(0px, 0px)';\n          event.target.style.left = `${startX}px`;\n          event.target.style.top = `${startY}px`;\n          event.target.removeAttribute('data-x');\n          event.target.removeAttribute('data-y');\n        }\n      }\n    });\n    // Set up the dropzone\n    interact('#drawflow').dropzone({\n      accept: '.draggable-item',\n      // Accept items with class .draggable-item\n      overlap: 0.75,\n      ondrop: event => {\n        const nodeName = event.relatedTarget.getAttribute('data-node-name');\n        const x = event.dragEvent.clientX - event.target.getBoundingClientRect().left - 300;\n        const y = event.dragEvent.clientY - event.target.getBoundingClientRect().top - 40;\n        this.addNode(nodeName, x, y);\n      },\n      ondropdeactivate: event => {\n        const startX = event.relatedTarget.getAttribute('data-start-x');\n        const startY = event.relatedTarget.getAttribute('data-start-y');\n        event.relatedTarget.style.transform = 'translate(0px, 0px)';\n        event.relatedTarget.style.left = `${startX}px`;\n        event.relatedTarget.style.top = `${startY}px`;\n        event.relatedTarget.removeAttribute('data-x');\n        event.relatedTarget.removeAttribute('data-y');\n      }\n    });\n    this.drawflow.on('connectionCreated', event => {\n      console.log('Connection Created:', event);\n      const outputNode = this.drawflow.getNodeFromId(event.output_id);\n      const inputNode = this.drawflow.getNodeFromId(event.input_id);\n      if (outputNode.name === inputNode.name) {\n        alert('Error: Cannot connect two consecutive nodes with the same name!');\n        this.drawflow.removeSingleConnection(event.output_id, event.input_id, event.output_class, event.input_class);\n      } else if (this.hasCycle()) {\n        alert('Error: Cycle detected in the workflow!');\n        this.drawflow.removeSingleConnection(event.output_id, event.input_id, event.output_class, event.input_class);\n      }\n    });\n    this.id.addEventListener('dblclick', event => {\n      const target = event.target;\n      const nodeElement = target.closest('.drawflow-node');\n      if (nodeElement) {\n        const nodeId = nodeElement.id.replace('node-', '');\n        const node = this.drawflow.getNodeFromId(nodeId);\n        const index = this.items.findIndex(item => item.name === node.name);\n        console.log('Node Index:', index);\n        if (index !== -1) {\n          this.openEditDialog(index);\n        }\n      }\n    });\n  }\n  unloadNotification($event) {\n    // Save workflow data to localStorage before the user closes the tab or reloads the page\n    const workflowData = this.drawflow.export();\n    const processedData = this.processWorkflowData(workflowData);\n    localStorage.setItem('workflowData', JSON.stringify(processedData));\n  }\n  openDialog() {\n    const dialogRef = this.dialog.open(NodeDialogComponent, {\n      width: '300px',\n      data: {\n        name: '',\n        mode: 'create',\n        params: ''\n      } // Initialize params\n    });\n    dialogRef.afterClosed().subscribe(result => {\n      if (result && result.action === 'create') {\n        this.newItemName = result.name;\n        const newItemParams = result.params;\n        if (typeof this.newItemName === 'string') {\n          this.items.push({\n            name: this.newItemName,\n            params: newItemParams,\n            file: result.file\n          });\n        }\n      }\n    });\n  }\n  openContextMenu(event, index) {\n    // Create a context menu\n    const contextMenu = document.createElement('div');\n    contextMenu.classList.add('context-menu');\n    contextMenu.style.top = `${event.clientY}px`;\n    contextMenu.style.left = `${event.clientX}px`;\n    // Add menu items\n    const editItem = document.createElement('div');\n    editItem.classList.add('context-menu-item');\n    editItem.innerText = 'Edit';\n    editItem.addEventListener('click', () => {\n      this.openEditDialog(index);\n      document.body.removeChild(contextMenu);\n    });\n    const deleteItem = document.createElement('div');\n    deleteItem.classList.add('context-menu-item');\n    deleteItem.innerText = 'Delete';\n    deleteItem.addEventListener('click', () => {\n      this.deleteItem(index);\n      document.body.removeChild(contextMenu);\n    });\n    contextMenu.appendChild(editItem);\n    contextMenu.appendChild(deleteItem);\n    // Remove any existing context menu\n    const existingMenu = document.querySelector('.context-menu');\n    if (existingMenu) {\n      document.body.removeChild(existingMenu);\n    }\n    // Add the context menu to the body\n    document.body.appendChild(contextMenu);\n    // Remove the context menu when clicking outside\n    document.addEventListener('click', () => {\n      if (contextMenu) {\n        document.body.removeChild(contextMenu);\n      }\n    }, {\n      once: true\n    });\n  }\n  dragMoveListener(event) {\n    const target = event.target;\n    const x = (parseFloat(target.getAttribute('data-x')) || 0) + event.dx;\n    const y = (parseFloat(target.getAttribute('data-y')) || 0) + event.dy;\n    target.style.transform = `translate(${x}px, ${y}px)`;\n    target.setAttribute('data-x', x);\n    target.setAttribute('data-y', y);\n  }\n  addNode(nodeName, x, y) {\n    var html = document.createElement('div');\n    html.innerHTML = nodeName;\n    this.drawflow.registerNode('test', html);\n    return this.drawflow.addNode(nodeName, 1, 1, x, y, 'github', this.items, 'test', true);\n  }\n  openEditDialog(index) {\n    const dialogRef = this.dialog.open(NodeDialogComponent, {\n      width: '300px',\n      // Set the desired width for the dialog\n      maxWidth: '100%',\n      // Ensure the dialog does not exceed the screen width\n      data: {\n        name: this.items[index].name,\n        params: this.items[index].params,\n        file: this.items[index].file,\n        // Include the file in the dialog data\n        index: index,\n        mode: 'edit'\n      }\n    });\n    dialogRef.afterClosed().subscribe(result => {\n      if (result && result.action === 'save') {\n        this.items[index].name = result.name;\n        this.items[index].params = result.params;\n        if (result.file) {\n          this.items[index].file = result.file; // Save the file with the node\n        }\n      } else if (result && result.action === 'delete') {\n        this.deleteItem(index);\n      }\n    });\n  }\n  uploadFile(file, index) {\n    // Implement the file upload logic here\n    const formData = new FormData();\n    formData.append('file', file);\n    // Store the file in the items array\n    this.items[index].file = file;\n    console.log(this.items);\n    // Use your preferred method to upload the file to the API\n    // Example using HttpClient:\n    // this.http.post('your-api-endpoint', formData).subscribe(response => {\n    //   console.log('File uploaded successfully', response);\n    // });\n  }\n  removeNodeFromDrawflow(index) {\n    const item = document.querySelector(`.draggable-item[data-index=\"${index}\"]`);\n    if (item) {\n      item.style.display = 'none';\n      setTimeout(() => {\n        item.style.display = '';\n      }, 0);\n    }\n  }\n  runWorkflow() {\n    // Check if each node has a file\n    for (const item of this.items) {\n      console.log(\"newnew\");\n      if (!item.file || !item.file.name || item.file.name === 'none' || item.file.name === '' || item.file.name === undefined) {\n        alert(`Error: Node \"${item.name}\" does not have an associated file.`);\n        return; // Stop the workflow from running\n      } else {\n        console.log(item.file.name);\n      }\n    }\n    console.log('Run workflow');\n    const workflowData = this.drawflow.export();\n    const processedData = this.processWorkflowData(workflowData);\n    // Send the processed data to the server\n    this.sendWorkflowData(processedData);\n  }\n  sendWorkflowData(workflowData) {\n    const formData = new FormData();\n    formData.append('workflowData', JSON.stringify(workflowData, null, 2));\n    // Append files to the formData\n    workflowData.nodes.forEach((node, index) => {\n      if (node.file) {\n        formData.append(node.name, node.file);\n      }\n    });\n    const url = 'http://127.0.0.1:5000/upload_workflow'; // Replace with your API endpoint\n    fetch(url, {\n      method: 'POST',\n      body: formData\n    }).then(response => response.json()).then(data => {\n      console.log('Workflow data uploaded successfully:', data);\n      this.socketService.emit('run_workflow', {});\n      // Listen for real-time updates from the server\n      this.socketService.on('workflow_output').subscribe(output => {\n        console.log('Real-time output:', output);\n      });\n    }).catch(error => {\n      console.error('Error uploading workflow data:', error);\n    });\n    console.log('Sending workflow data to server:', workflowData);\n  }\n  createNode() {\n    const nodeNameInput = document.getElementById('nodeNameInput');\n    const nodeName = nodeNameInput.value;\n    if (nodeName) {\n      this.addNode(nodeName, 50, 50); // You can adjust the x and y coordinates as needed\n      nodeNameInput.value = ''; // Clear the input field after creating the node\n    } else {\n      alert('Please enter a node name');\n    }\n  }\n  addItem() {\n    if (this.newItemName) {\n      if (this.items.some(item => item.name === this.newItemName)) {\n        alert('Item with this name already exists');\n      } else {\n        this.items.push({\n          name: this.newItemName,\n          params: '',\n          file: null\n        });\n        this.newItemName = '';\n      }\n    } else {\n      alert('Please enter an item name');\n    }\n  }\n  deleteItem(index) {\n    this.items.splice(index, 1);\n    console.log(this.items);\n  }\n  importWorkflow(jsonData) {\n    this.items.length = 0; // Clear the items array\n    try {\n      const workflowData = JSON.parse(jsonData);\n      if (!this.drawflow) {\n        this.id = document.getElementById('drawflow');\n        this.drawflow = new Drawflow(this.id);\n        this.drawflow.start();\n      } else {\n        this.drawflow.clear(); // Clear the current Drawflow data\n      }\n      const nodeIdMap = new Map();\n      const nodeNamesSet = new Set(); // Set to track node names\n      // First, add all nodes to the Drawflow\n      workflowData.nodes.forEach(node => {\n        const nodeId = this.addNode(node.name, node.position.x, node.position.y); // Use positions\n        nodeIdMap.set(node.name, nodeId);\n        const drawflowNode = this.drawflow.getNodeFromId(nodeId);\n        drawflowNode.data = {\n          params: node.params,\n          file: node.file\n        };\n        // Check for duplicate node names\n        if (!nodeNamesSet.has(node.name)) {\n          nodeNamesSet.add(node.name);\n          this.items.push({\n            name: node.name,\n            params: JSON.stringify(node.params),\n            file: node.file\n          });\n        } else {\n          console.warn(`Duplicate node name found: ${node.name}. Skipping this node.`);\n        }\n      });\n      // Then, recreate connections\n      workflowData.nodes.forEach(node => {\n        node.connections.forEach(connection => {\n          const outputNodeId = nodeIdMap.get(node.name);\n          const inputNodeId = nodeIdMap.get(connection);\n          if (outputNodeId && inputNodeId) {\n            this.drawflow.addConnection(outputNodeId, inputNodeId, 'output_1', 'input_1');\n          }\n        });\n      });\n      console.log('Workflow imported successfully:', workflowData);\n    } catch (error) {\n      console.error('Error importing workflow data:', error);\n    }\n  }\n  onFileSelected(event) {\n    const file = event.target.files[0];\n    if (file) {\n      const reader = new FileReader();\n      reader.onload = e => {\n        const jsonData = e.target.result;\n        this.importWorkflow(jsonData);\n      };\n      reader.readAsText(file);\n    }\n  }\n  clearWorkflow() {\n    this.drawflow.clear();\n    this.items = [];\n    localStorage.removeItem('workflowData');\n  }\n  exportWorkflow() {\n    const workflowData = this.drawflow.export();\n    const processedData = this.processWorkflowData(workflowData);\n    console.log('Exported Workflow Data:', processedData);\n    if (processedData !== undefined) {\n      this.downloadWorkflow(processedData);\n    }\n  }\n  triggerFileInput() {\n    const fileInput = document.querySelector('input[type=\"file\"]');\n    if (fileInput) {\n      fileInput.click();\n    }\n  }\n  processWorkflowData(workflowData) {\n    const processedData = {\n      nodes: []\n    };\n    for (const key in workflowData.drawflow.Home.data) {\n      const node = workflowData.drawflow.Home.data[key];\n      const item = this.items.find(item => item.name === node.name);\n      const connections = [];\n      // Collect names of connected nodes\n      for (const outputKey in node.outputs) {\n        const outputConnections = node.outputs[outputKey].connections;\n        for (const connection of outputConnections) {\n          const connectedNode = workflowData.drawflow.Home.data[connection.node];\n          connections.push(connectedNode.name);\n        }\n      }\n      try {\n        processedData.nodes.push({\n          id: node.id,\n          name: node.name,\n          params: item.params ? JSON.parse(item.params) : {},\n          // Parse if params is a string\n          file: item ? item.file : null,\n          filePath: item && item.file ? item.file.path : null,\n          // Include full file path\n          connections: connections,\n          position: {\n            x: node.pos_x,\n            y: node.pos_y\n          } // Include positions\n        });\n      } catch (error) {\n        alert('Error parsing JSON parameters: ' + error.message);\n        return;\n      }\n    }\n    return processedData;\n  }\n  downloadWorkflow(workflowData) {\n    const dataStr = JSON.stringify(workflowData, null, 2);\n    const blob = new Blob([dataStr], {\n      type: 'application/json'\n    });\n    const url = URL.createObjectURL(blob);\n    const a = document.createElement('a');\n    a.href = url;\n    a.download = 'workflow.json';\n    document.body.appendChild(a);\n    a.click();\n    document.body.removeChild(a);\n    URL.revokeObjectURL(url);\n  }\n  hasCycle() {\n    const workflowData = this.drawflow.export();\n    const graph = this.buildGraph(workflowData);\n    return this.detectCycle(graph);\n  }\n  buildGraph(workflowData) {\n    const graph = new Map();\n    for (const key in workflowData.drawflow.Home.data) {\n      const node = workflowData.drawflow.Home.data[key];\n      graph.set(key, []);\n      for (const outputKey in node.outputs) {\n        const connections = node.outputs[outputKey].connections;\n        for (const connection of connections) {\n          graph.get(key).push(connection.node);\n        }\n      }\n    }\n    return graph;\n  }\n  detectCycle(graph) {\n    const visited = new Set();\n    const recStack = new Set();\n    const dfs = node => {\n      if (!visited.has(node)) {\n        visited.add(node);\n        recStack.add(node);\n        const neighbors = graph.get(node) || [];\n        for (const neighbor of neighbors) {\n          if (!visited.has(neighbor) && dfs(neighbor)) {\n            return true;\n          } else if (recStack.has(neighbor)) {\n            return true;\n          }\n        }\n      }\n      recStack.delete(node);\n      return false;\n    };\n    for (const node of graph.keys()) {\n      if (dfs(node)) {\n        return true;\n      }\n    }\n    return false;\n  }\n};\n__decorate([HostListener('window:beforeunload', ['$event'])], AppComponent.prototype, \"unloadNotification\", null);\nAppComponent = __decorate([Component({\n  selector: 'my-app',\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css'],\n  encapsulation: ViewEncapsulation.None // Disable encapsulation\n})], AppComponent);\nexport { AppComponent };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}
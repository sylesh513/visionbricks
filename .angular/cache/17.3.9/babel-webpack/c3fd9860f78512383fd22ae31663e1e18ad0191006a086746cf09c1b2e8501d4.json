{"ast":null,"code":"import { __decorate } from \"tslib\";\nimport { Component, ViewEncapsulation } from '@angular/core';\nimport { NodeDialogComponent } from './node-dialog/node-dialog.component';\nimport Drawflow from 'drawflow';\nimport interact from 'interactjs';\nlet AppComponent = class AppComponent {\n  dialog;\n  drawflow;\n  id = null;\n  data = {\n    name: '',\n    params: ''\n  };\n  items = [{\n    name: 'Node 1',\n    params: ''\n  }];\n  newItemName = '';\n  constructor(dialog) {\n    this.dialog = dialog;\n  }\n  ngOnInit() {\n    this.id = document.getElementById('drawflow');\n    this.drawflow = new Drawflow(this.id);\n    this.drawflow.start();\n    // Initialize draggable items\n    interact('.draggable-item').draggable({\n      inertia: true,\n      autoScroll: true,\n      onstart: event => {\n        // Store the original position\n        const target = event.target;\n        const rect = target.getBoundingClientRect();\n        target.setAttribute('data-start-x', rect.left);\n        target.setAttribute('data-start-y', rect.top);\n      },\n      onmove: this.dragMoveListener,\n      onend: event => {\n        if (!event.target.dropzone) {\n          const startX = event.target.getAttribute('data-start-x');\n          const startY = event.target.getAttribute('data-start-y');\n          // Snap back to original position\n          event.target.style.transform = 'translate(0px, 0px)';\n          event.target.style.left = `${startX}px`;\n          event.target.style.top = `${startY}px`;\n          event.target.removeAttribute('data-x');\n          event.target.removeAttribute('data-y');\n        }\n      }\n    });\n    // Set up the dropzone\n    interact('#drawflow').dropzone({\n      accept: '.draggable-item',\n      // Accept items with class .draggable-item\n      overlap: 0.75,\n      ondrop: event => {\n        const nodeName = event.relatedTarget.getAttribute('data-node-name');\n        const index = event.relatedTarget.getAttribute('data-index');\n        const x = event.dragEvent.clientX - event.target.getBoundingClientRect().left - 300;\n        const y = event.dragEvent.clientY - event.target.getBoundingClientRect().top - 40;\n        this.addNode(nodeName, x, y);\n        // Check for cycles after adding the node\n        // if (this.hasCycle()) {\n        //   alert('Error: Cycle detected in the workflow!');\n        // }\n      },\n      ondropdeactivate: event => {\n        const startX = event.relatedTarget.getAttribute('data-start-x');\n        const startY = event.relatedTarget.getAttribute('data-start-y');\n        event.relatedTarget.style.transform = 'translate(0px, 0px)';\n        event.relatedTarget.style.left = `${startX}px`;\n        event.relatedTarget.style.top = `${startY}px`;\n        event.relatedTarget.removeAttribute('data-x');\n        event.relatedTarget.removeAttribute('data-y');\n      }\n    });\n    this.drawflow.on('connectionCreated', event => {\n      console.log('Connection Created:', event);\n      const outputNode = this.drawflow.getNodeFromId(event.output_id);\n      const inputNode = this.drawflow.getNodeFromId(event.input_id);\n      if (outputNode.name === inputNode.name) {\n        alert('Error: Cannot connect two consecutive nodes with the same name!');\n        this.drawflow.removeSingleConnection(event.output_id, event.input_id, event.output_class, event.input_class);\n      } else if (this.hasCycle()) {\n        alert('Error: Cycle detected in the workflow!');\n        this.drawflow.removeSingleConnection(event.output_id, event.input_id, event.output_class, event.input_class);\n      }\n    });\n  }\n  openDialog() {\n    const dialogRef = this.dialog.open(NodeDialogComponent, {\n      width: '250px',\n      data: {\n        name: '',\n        mode: 'create',\n        params: ''\n      } // Initialize params\n    });\n    dialogRef.afterClosed().subscribe(result => {\n      if (result && result.action === 'create') {\n        this.newItemName = result.name;\n        const newItemParams = result.params;\n        if (typeof this.newItemName === 'string') {\n          this.items.push({\n            name: this.newItemName,\n            params: newItemParams\n          });\n        }\n      }\n    });\n  }\n  dragMoveListener(event) {\n    const target = event.target;\n    const x = (parseFloat(target.getAttribute('data-x')) || 0) + event.dx;\n    const y = (parseFloat(target.getAttribute('data-y')) || 0) + event.dy;\n    target.style.transform = `translate(${x}px, ${y}px)`;\n    target.setAttribute('data-x', x);\n    target.setAttribute('data-y', y);\n  }\n  addNode(nodeName, x, y) {\n    var html = document.createElement('div');\n    html.innerHTML = nodeName;\n    this.drawflow.registerNode('test', html);\n    this.drawflow.addNode(nodeName, 1, 1, x, y, 'github', this.data, 'test', true);\n  }\n  openEditDialog(index) {\n    const dialogRef = this.dialog.open(NodeDialogComponent, {\n      width: '250px',\n      data: {\n        name: this.items[index].name,\n        params: this.items[index].params,\n        // Pass the params property\n        index: index,\n        mode: 'edit'\n      }\n    });\n    dialogRef.afterClosed().subscribe(result => {\n      if (result && result.action === 'save') {\n        this.items[index].name = result.name;\n        this.items[index].params = result.params; // Update the params property\n      } else if (result && result.action === 'delete') {\n        this.deleteItem(index);\n      }\n    });\n  }\n  removeNodeFromDrawflow(index) {\n    const item = document.querySelector(`.draggable-item[data-index=\"${index}\"]`);\n    if (item) {\n      item.style.display = 'none';\n      setTimeout(() => {\n        item.style.display = '';\n      }, 0);\n    }\n  }\n  createNode() {\n    const nodeNameInput = document.getElementById('nodeNameInput');\n    const nodeName = nodeNameInput.value;\n    if (nodeName) {\n      this.addNode(nodeName, 50, 50); // You can adjust the x and y coordinates as needed\n      nodeNameInput.value = ''; // Clear the input field after creating the node\n    } else {\n      alert('Please enter a node name');\n    }\n  }\n  addItem() {\n    if (this.newItemName) {\n      if (this.items.some(item => item.name === this.newItemName)) {\n        alert('Item with this name already exists');\n      } else {\n        this.items.push({\n          name: this.newItemName,\n          params: ''\n        });\n        this.newItemName = '';\n      }\n    } else {\n      alert('Please enter an item name');\n    }\n  }\n  deleteItem(index) {\n    this.items.splice(index, 1);\n    console.log(this.items);\n  }\n  exportWorkflow() {\n    const workflowData = this.drawflow.export();\n    console.log('Exported Workflow Data:', workflowData);\n    const processedData = this.processWorkflowData(workflowData);\n    this.downloadWorkflow(processedData);\n    // You can now process or store the workflowData as needed\n  }\n  processWorkflowData(workflowData) {\n    const processedData = {\n      nodes: []\n    };\n    for (const key in workflowData.drawflow.Home.data) {\n      const node = workflowData.drawflow.Home.data[key];\n      const itemName = this.items.find(item => item.name === node.name)?.name || node.name;\n      const connections = [];\n      // Collect names of connected nodes\n      for (const outputKey in node.outputs) {\n        const outputConnections = node.outputs[outputKey].connections;\n        for (const connection of outputConnections) {\n          const connectedNode = workflowData.drawflow.Home.data[connection.node];\n          const connectedNodeName = this.items.find(item => item.name === connectedNode.name)?.name || connectedNode.name;\n          connections.push(connectedNodeName);\n        }\n      }\n      processedData.nodes.push({\n        id: node.id,\n        name: itemName,\n        connections: connections\n      });\n    }\n    return processedData;\n  }\n  downloadWorkflow(workflowData) {\n    const dataStr = JSON.stringify(workflowData, null, 2);\n    const blob = new Blob([dataStr], {\n      type: 'application/json'\n    });\n    const url = URL.createObjectURL(blob);\n    const a = document.createElement('a');\n    a.href = url;\n    a.download = 'workflow.json';\n    document.body.appendChild(a);\n    a.click();\n    document.body.removeChild(a);\n    URL.revokeObjectURL(url);\n  }\n  hasCycle() {\n    const workflowData = this.drawflow.export();\n    const graph = this.buildGraph(workflowData);\n    return this.detectCycle(graph);\n  }\n  buildGraph(workflowData) {\n    const graph = new Map();\n    for (const key in workflowData.drawflow.Home.data) {\n      const node = workflowData.drawflow.Home.data[key];\n      graph.set(key, []);\n      for (const outputKey in node.outputs) {\n        const connections = node.outputs[outputKey].connections;\n        for (const connection of connections) {\n          graph.get(key).push(connection.node);\n        }\n      }\n    }\n    return graph;\n  }\n  detectCycle(graph) {\n    const visited = new Set();\n    const recStack = new Set();\n    const dfs = node => {\n      if (!visited.has(node)) {\n        visited.add(node);\n        recStack.add(node);\n        const neighbors = graph.get(node) || [];\n        for (const neighbor of neighbors) {\n          if (!visited.has(neighbor) && dfs(neighbor)) {\n            return true;\n          } else if (recStack.has(neighbor)) {\n            return true;\n          }\n        }\n      }\n      recStack.delete(node);\n      return false;\n    };\n    for (const node of graph.keys()) {\n      if (dfs(node)) {\n        return true;\n      }\n    }\n    return false;\n  }\n};\nAppComponent = __decorate([Component({\n  selector: 'my-app',\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css'],\n  encapsulation: ViewEncapsulation.None // Disable encapsulation\n})], AppComponent);\nexport { AppComponent };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}
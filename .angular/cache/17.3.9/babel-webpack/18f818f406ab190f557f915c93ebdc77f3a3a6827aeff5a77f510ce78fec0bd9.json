{"ast":null,"code":"/* interact.js 1.10.27 | https://raw.github.com/taye/interact.js/main/LICENSE */\n\n!function (t, e) {\n  \"object\" == typeof exports && \"undefined\" != typeof module ? module.exports = e() : \"function\" == typeof define && define.amd ? define(e) : (t = \"undefined\" != typeof globalThis ? globalThis : t || self).interact = e();\n}(this, function () {\n  \"use strict\";\n\n  function t(t, e) {\n    var n = Object.keys(t);\n    if (Object.getOwnPropertySymbols) {\n      var r = Object.getOwnPropertySymbols(t);\n      e && (r = r.filter(function (e) {\n        return Object.getOwnPropertyDescriptor(t, e).enumerable;\n      })), n.push.apply(n, r);\n    }\n    return n;\n  }\n  function e(e) {\n    for (var n = 1; n < arguments.length; n++) {\n      var r = null != arguments[n] ? arguments[n] : {};\n      n % 2 ? t(Object(r), !0).forEach(function (t) {\n        a(e, t, r[t]);\n      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : t(Object(r)).forEach(function (t) {\n        Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(r, t));\n      });\n    }\n    return e;\n  }\n  function n(t) {\n    return n = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (t) {\n      return typeof t;\n    } : function (t) {\n      return t && \"function\" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? \"symbol\" : typeof t;\n    }, n(t);\n  }\n  function r(t, e) {\n    if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n  }\n  function i(t, e) {\n    for (var n = 0; n < e.length; n++) {\n      var r = e[n];\n      r.enumerable = r.enumerable || !1, r.configurable = !0, \"value\" in r && (r.writable = !0), Object.defineProperty(t, d(r.key), r);\n    }\n  }\n  function o(t, e, n) {\n    return e && i(t.prototype, e), n && i(t, n), Object.defineProperty(t, \"prototype\", {\n      writable: !1\n    }), t;\n  }\n  function a(t, e, n) {\n    return (e = d(e)) in t ? Object.defineProperty(t, e, {\n      value: n,\n      enumerable: !0,\n      configurable: !0,\n      writable: !0\n    }) : t[e] = n, t;\n  }\n  function s(t, e) {\n    if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\");\n    t.prototype = Object.create(e && e.prototype, {\n      constructor: {\n        value: t,\n        writable: !0,\n        configurable: !0\n      }\n    }), Object.defineProperty(t, \"prototype\", {\n      writable: !1\n    }), e && l(t, e);\n  }\n  function c(t) {\n    return c = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {\n      return t.__proto__ || Object.getPrototypeOf(t);\n    }, c(t);\n  }\n  function l(t, e) {\n    return l = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {\n      return t.__proto__ = e, t;\n    }, l(t, e);\n  }\n  function u(t) {\n    if (void 0 === t) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    return t;\n  }\n  function p(t) {\n    var e = function () {\n      if (\"undefined\" == typeof Reflect || !Reflect.construct) return !1;\n      if (Reflect.construct.sham) return !1;\n      if (\"function\" == typeof Proxy) return !0;\n      try {\n        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0;\n      } catch (t) {\n        return !1;\n      }\n    }();\n    return function () {\n      var n,\n        r = c(t);\n      if (e) {\n        var i = c(this).constructor;\n        n = Reflect.construct(r, arguments, i);\n      } else n = r.apply(this, arguments);\n      return function (t, e) {\n        if (e && (\"object\" == typeof e || \"function\" == typeof e)) return e;\n        if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\");\n        return u(t);\n      }(this, n);\n    };\n  }\n  function f() {\n    return f = \"undefined\" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (t, e, n) {\n      var r = function (t, e) {\n        for (; !Object.prototype.hasOwnProperty.call(t, e) && null !== (t = c(t)););\n        return t;\n      }(t, e);\n      if (r) {\n        var i = Object.getOwnPropertyDescriptor(r, e);\n        return i.get ? i.get.call(arguments.length < 3 ? t : n) : i.value;\n      }\n    }, f.apply(this, arguments);\n  }\n  function d(t) {\n    var e = function (t, e) {\n      if (\"object\" != typeof t || null === t) return t;\n      var n = t[Symbol.toPrimitive];\n      if (void 0 !== n) {\n        var r = n.call(t, e || \"default\");\n        if (\"object\" != typeof r) return r;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n      }\n      return (\"string\" === e ? String : Number)(t);\n    }(t, \"string\");\n    return \"symbol\" == typeof e ? e : e + \"\";\n  }\n  var h = function (t) {\n      return !(!t || !t.Window) && t instanceof t.Window;\n    },\n    v = void 0,\n    g = void 0;\n  function m(t) {\n    v = t;\n    var e = t.document.createTextNode(\"\");\n    e.ownerDocument !== t.document && \"function\" == typeof t.wrap && t.wrap(e) === e && (t = t.wrap(t)), g = t;\n  }\n  function y(t) {\n    return h(t) ? t : (t.ownerDocument || t).defaultView || g.window;\n  }\n  \"undefined\" != typeof window && window && m(window);\n  var b = function (t) {\n      return !!t && \"object\" === n(t);\n    },\n    x = function (t) {\n      return \"function\" == typeof t;\n    },\n    w = {\n      window: function (t) {\n        return t === g || h(t);\n      },\n      docFrag: function (t) {\n        return b(t) && 11 === t.nodeType;\n      },\n      object: b,\n      func: x,\n      number: function (t) {\n        return \"number\" == typeof t;\n      },\n      bool: function (t) {\n        return \"boolean\" == typeof t;\n      },\n      string: function (t) {\n        return \"string\" == typeof t;\n      },\n      element: function (t) {\n        if (!t || \"object\" !== n(t)) return !1;\n        var e = y(t) || g;\n        return /object|function/.test(\"undefined\" == typeof Element ? \"undefined\" : n(Element)) ? t instanceof Element || t instanceof e.Element : 1 === t.nodeType && \"string\" == typeof t.nodeName;\n      },\n      plainObject: function (t) {\n        return b(t) && !!t.constructor && /function Object\\b/.test(t.constructor.toString());\n      },\n      array: function (t) {\n        return b(t) && void 0 !== t.length && x(t.splice);\n      }\n    };\n  function E(t) {\n    var e = t.interaction;\n    if (\"drag\" === e.prepared.name) {\n      var n = e.prepared.axis;\n      \"x\" === n ? (e.coords.cur.page.y = e.coords.start.page.y, e.coords.cur.client.y = e.coords.start.client.y, e.coords.velocity.client.y = 0, e.coords.velocity.page.y = 0) : \"y\" === n && (e.coords.cur.page.x = e.coords.start.page.x, e.coords.cur.client.x = e.coords.start.client.x, e.coords.velocity.client.x = 0, e.coords.velocity.page.x = 0);\n    }\n  }\n  function T(t) {\n    var e = t.iEvent,\n      n = t.interaction;\n    if (\"drag\" === n.prepared.name) {\n      var r = n.prepared.axis;\n      if (\"x\" === r || \"y\" === r) {\n        var i = \"x\" === r ? \"y\" : \"x\";\n        e.page[i] = n.coords.start.page[i], e.client[i] = n.coords.start.client[i], e.delta[i] = 0;\n      }\n    }\n  }\n  var S = {\n      id: \"actions/drag\",\n      install: function (t) {\n        var e = t.actions,\n          n = t.Interactable,\n          r = t.defaults;\n        n.prototype.draggable = S.draggable, e.map.drag = S, e.methodDict.drag = \"draggable\", r.actions.drag = S.defaults;\n      },\n      listeners: {\n        \"interactions:before-action-move\": E,\n        \"interactions:action-resume\": E,\n        \"interactions:action-move\": T,\n        \"auto-start:check\": function (t) {\n          var e = t.interaction,\n            n = t.interactable,\n            r = t.buttons,\n            i = n.options.drag;\n          if (i && i.enabled && (!e.pointerIsDown || !/mouse|pointer/.test(e.pointerType) || 0 != (r & n.options.drag.mouseButtons))) return t.action = {\n            name: \"drag\",\n            axis: \"start\" === i.lockAxis ? i.startAxis : i.lockAxis\n          }, !1;\n        }\n      },\n      draggable: function (t) {\n        return w.object(t) ? (this.options.drag.enabled = !1 !== t.enabled, this.setPerAction(\"drag\", t), this.setOnEvents(\"drag\", t), /^(xy|x|y|start)$/.test(t.lockAxis) && (this.options.drag.lockAxis = t.lockAxis), /^(xy|x|y)$/.test(t.startAxis) && (this.options.drag.startAxis = t.startAxis), this) : w.bool(t) ? (this.options.drag.enabled = t, this) : this.options.drag;\n      },\n      beforeMove: E,\n      move: T,\n      defaults: {\n        startAxis: \"xy\",\n        lockAxis: \"xy\"\n      },\n      getCursor: function () {\n        return \"move\";\n      },\n      filterEventType: function (t) {\n        return 0 === t.search(\"drag\");\n      }\n    },\n    _ = S,\n    P = {\n      init: function (t) {\n        var e = t;\n        P.document = e.document, P.DocumentFragment = e.DocumentFragment || O, P.SVGElement = e.SVGElement || O, P.SVGSVGElement = e.SVGSVGElement || O, P.SVGElementInstance = e.SVGElementInstance || O, P.Element = e.Element || O, P.HTMLElement = e.HTMLElement || P.Element, P.Event = e.Event, P.Touch = e.Touch || O, P.PointerEvent = e.PointerEvent || e.MSPointerEvent;\n      },\n      document: null,\n      DocumentFragment: null,\n      SVGElement: null,\n      SVGSVGElement: null,\n      SVGElementInstance: null,\n      Element: null,\n      HTMLElement: null,\n      Event: null,\n      Touch: null,\n      PointerEvent: null\n    };\n  function O() {}\n  var k = P;\n  var D = {\n    init: function (t) {\n      var e = k.Element,\n        n = t.navigator || {};\n      D.supportsTouch = \"ontouchstart\" in t || w.func(t.DocumentTouch) && k.document instanceof t.DocumentTouch, D.supportsPointerEvent = !1 !== n.pointerEnabled && !!k.PointerEvent, D.isIOS = /iP(hone|od|ad)/.test(n.platform), D.isIOS7 = /iP(hone|od|ad)/.test(n.platform) && /OS 7[^\\d]/.test(n.appVersion), D.isIe9 = /MSIE 9/.test(n.userAgent), D.isOperaMobile = \"Opera\" === n.appName && D.supportsTouch && /Presto/.test(n.userAgent), D.prefixedMatchesSelector = \"matches\" in e.prototype ? \"matches\" : \"webkitMatchesSelector\" in e.prototype ? \"webkitMatchesSelector\" : \"mozMatchesSelector\" in e.prototype ? \"mozMatchesSelector\" : \"oMatchesSelector\" in e.prototype ? \"oMatchesSelector\" : \"msMatchesSelector\", D.pEventTypes = D.supportsPointerEvent ? k.PointerEvent === t.MSPointerEvent ? {\n        up: \"MSPointerUp\",\n        down: \"MSPointerDown\",\n        over: \"mouseover\",\n        out: \"mouseout\",\n        move: \"MSPointerMove\",\n        cancel: \"MSPointerCancel\"\n      } : {\n        up: \"pointerup\",\n        down: \"pointerdown\",\n        over: \"pointerover\",\n        out: \"pointerout\",\n        move: \"pointermove\",\n        cancel: \"pointercancel\"\n      } : null, D.wheelEvent = k.document && \"onmousewheel\" in k.document ? \"mousewheel\" : \"wheel\";\n    },\n    supportsTouch: null,\n    supportsPointerEvent: null,\n    isIOS7: null,\n    isIOS: null,\n    isIe9: null,\n    isOperaMobile: null,\n    prefixedMatchesSelector: null,\n    pEventTypes: null,\n    wheelEvent: null\n  };\n  var I = D;\n  function M(t, e) {\n    if (t.contains) return t.contains(e);\n    for (; e;) {\n      if (e === t) return !0;\n      e = e.parentNode;\n    }\n    return !1;\n  }\n  function z(t, e) {\n    for (; w.element(t);) {\n      if (R(t, e)) return t;\n      t = A(t);\n    }\n    return null;\n  }\n  function A(t) {\n    var e = t.parentNode;\n    if (w.docFrag(e)) {\n      for (; (e = e.host) && w.docFrag(e););\n      return e;\n    }\n    return e;\n  }\n  function R(t, e) {\n    return g !== v && (e = e.replace(/\\/deep\\//g, \" \")), t[I.prefixedMatchesSelector](e);\n  }\n  var C = function (t) {\n    return t.parentNode || t.host;\n  };\n  function j(t, e) {\n    for (var n, r = [], i = t; (n = C(i)) && i !== e && n !== i.ownerDocument;) r.unshift(i), i = n;\n    return r;\n  }\n  function F(t, e, n) {\n    for (; w.element(t);) {\n      if (R(t, e)) return !0;\n      if ((t = A(t)) === n) return R(t, e);\n    }\n    return !1;\n  }\n  function X(t) {\n    return t.correspondingUseElement || t;\n  }\n  function Y(t) {\n    var e = t instanceof k.SVGElement ? t.getBoundingClientRect() : t.getClientRects()[0];\n    return e && {\n      left: e.left,\n      right: e.right,\n      top: e.top,\n      bottom: e.bottom,\n      width: e.width || e.right - e.left,\n      height: e.height || e.bottom - e.top\n    };\n  }\n  function L(t) {\n    var e,\n      n = Y(t);\n    if (!I.isIOS7 && n) {\n      var r = {\n        x: (e = (e = y(t)) || g).scrollX || e.document.documentElement.scrollLeft,\n        y: e.scrollY || e.document.documentElement.scrollTop\n      };\n      n.left += r.x, n.right += r.x, n.top += r.y, n.bottom += r.y;\n    }\n    return n;\n  }\n  function q(t) {\n    for (var e = []; t;) e.push(t), t = A(t);\n    return e;\n  }\n  function B(t) {\n    return !!w.string(t) && (k.document.querySelector(t), !0);\n  }\n  function V(t, e) {\n    for (var n in e) t[n] = e[n];\n    return t;\n  }\n  function W(t, e, n) {\n    return \"parent\" === t ? A(n) : \"self\" === t ? e.getRect(n) : z(n, t);\n  }\n  function G(t, e, n, r) {\n    var i = t;\n    return w.string(i) ? i = W(i, e, n) : w.func(i) && (i = i.apply(void 0, r)), w.element(i) && (i = L(i)), i;\n  }\n  function N(t) {\n    return t && {\n      x: \"x\" in t ? t.x : t.left,\n      y: \"y\" in t ? t.y : t.top\n    };\n  }\n  function U(t) {\n    return !t || \"x\" in t && \"y\" in t || ((t = V({}, t)).x = t.left || 0, t.y = t.top || 0, t.width = t.width || (t.right || 0) - t.x, t.height = t.height || (t.bottom || 0) - t.y), t;\n  }\n  function H(t, e, n) {\n    t.left && (e.left += n.x), t.right && (e.right += n.x), t.top && (e.top += n.y), t.bottom && (e.bottom += n.y), e.width = e.right - e.left, e.height = e.bottom - e.top;\n  }\n  function K(t, e, n) {\n    var r = n && t.options[n];\n    return N(G(r && r.origin || t.options.origin, t, e, [t && e])) || {\n      x: 0,\n      y: 0\n    };\n  }\n  function $(t, e) {\n    var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : function (t) {\n        return !0;\n      },\n      r = arguments.length > 3 ? arguments[3] : void 0;\n    if (r = r || {}, w.string(t) && -1 !== t.search(\" \") && (t = J(t)), w.array(t)) return t.forEach(function (t) {\n      return $(t, e, n, r);\n    }), r;\n    if (w.object(t) && (e = t, t = \"\"), w.func(e) && n(t)) r[t] = r[t] || [], r[t].push(e);else if (w.array(e)) for (var i = 0, o = e; i < o.length; i++) {\n      var a = o[i];\n      $(t, a, n, r);\n    } else if (w.object(e)) for (var s in e) {\n      $(J(s).map(function (e) {\n        return \"\".concat(t).concat(e);\n      }), e[s], n, r);\n    }\n    return r;\n  }\n  function J(t) {\n    return t.trim().split(/ +/);\n  }\n  var Q = function (t, e) {\n      return Math.sqrt(t * t + e * e);\n    },\n    Z = [\"webkit\", \"moz\"];\n  function tt(t, e) {\n    t.__set || (t.__set = {});\n    var n = function (n) {\n      if (Z.some(function (t) {\n        return 0 === n.indexOf(t);\n      })) return 1;\n      \"function\" != typeof t[n] && \"__set\" !== n && Object.defineProperty(t, n, {\n        get: function () {\n          return n in t.__set ? t.__set[n] : t.__set[n] = e[n];\n        },\n        set: function (e) {\n          t.__set[n] = e;\n        },\n        configurable: !0\n      });\n    };\n    for (var r in e) n(r);\n    return t;\n  }\n  function et(t, e) {\n    t.page = t.page || {}, t.page.x = e.page.x, t.page.y = e.page.y, t.client = t.client || {}, t.client.x = e.client.x, t.client.y = e.client.y, t.timeStamp = e.timeStamp;\n  }\n  function nt(t) {\n    t.page.x = 0, t.page.y = 0, t.client.x = 0, t.client.y = 0;\n  }\n  function rt(t) {\n    return t instanceof k.Event || t instanceof k.Touch;\n  }\n  function it(t, e, n) {\n    return t = t || \"page\", (n = n || {}).x = e[t + \"X\"], n.y = e[t + \"Y\"], n;\n  }\n  function ot(t, e) {\n    return e = e || {\n      x: 0,\n      y: 0\n    }, I.isOperaMobile && rt(t) ? (it(\"screen\", t, e), e.x += window.scrollX, e.y += window.scrollY) : it(\"page\", t, e), e;\n  }\n  function at(t) {\n    return w.number(t.pointerId) ? t.pointerId : t.identifier;\n  }\n  function st(t, e, n) {\n    var r = e.length > 1 ? lt(e) : e[0];\n    ot(r, t.page), function (t, e) {\n      e = e || {}, I.isOperaMobile && rt(t) ? it(\"screen\", t, e) : it(\"client\", t, e);\n    }(r, t.client), t.timeStamp = n;\n  }\n  function ct(t) {\n    var e = [];\n    return w.array(t) ? (e[0] = t[0], e[1] = t[1]) : \"touchend\" === t.type ? 1 === t.touches.length ? (e[0] = t.touches[0], e[1] = t.changedTouches[0]) : 0 === t.touches.length && (e[0] = t.changedTouches[0], e[1] = t.changedTouches[1]) : (e[0] = t.touches[0], e[1] = t.touches[1]), e;\n  }\n  function lt(t) {\n    for (var e = {\n        pageX: 0,\n        pageY: 0,\n        clientX: 0,\n        clientY: 0,\n        screenX: 0,\n        screenY: 0\n      }, n = 0; n < t.length; n++) {\n      var r = t[n];\n      for (var i in e) e[i] += r[i];\n    }\n    for (var o in e) e[o] /= t.length;\n    return e;\n  }\n  function ut(t) {\n    if (!t.length) return null;\n    var e = ct(t),\n      n = Math.min(e[0].pageX, e[1].pageX),\n      r = Math.min(e[0].pageY, e[1].pageY),\n      i = Math.max(e[0].pageX, e[1].pageX),\n      o = Math.max(e[0].pageY, e[1].pageY);\n    return {\n      x: n,\n      y: r,\n      left: n,\n      top: r,\n      right: i,\n      bottom: o,\n      width: i - n,\n      height: o - r\n    };\n  }\n  function pt(t, e) {\n    var n = e + \"X\",\n      r = e + \"Y\",\n      i = ct(t),\n      o = i[0][n] - i[1][n],\n      a = i[0][r] - i[1][r];\n    return Q(o, a);\n  }\n  function ft(t, e) {\n    var n = e + \"X\",\n      r = e + \"Y\",\n      i = ct(t),\n      o = i[1][n] - i[0][n],\n      a = i[1][r] - i[0][r];\n    return 180 * Math.atan2(a, o) / Math.PI;\n  }\n  function dt(t) {\n    return w.string(t.pointerType) ? t.pointerType : w.number(t.pointerType) ? [void 0, void 0, \"touch\", \"pen\", \"mouse\"][t.pointerType] : /touch/.test(t.type || \"\") || t instanceof k.Touch ? \"touch\" : \"mouse\";\n  }\n  function ht(t) {\n    var e = w.func(t.composedPath) ? t.composedPath() : t.path;\n    return [X(e ? e[0] : t.target), X(t.currentTarget)];\n  }\n  var vt = function () {\n    function t(e) {\n      r(this, t), this.immediatePropagationStopped = !1, this.propagationStopped = !1, this._interaction = e;\n    }\n    return o(t, [{\n      key: \"preventDefault\",\n      value: function () {}\n    }, {\n      key: \"stopPropagation\",\n      value: function () {\n        this.propagationStopped = !0;\n      }\n    }, {\n      key: \"stopImmediatePropagation\",\n      value: function () {\n        this.immediatePropagationStopped = this.propagationStopped = !0;\n      }\n    }]), t;\n  }();\n  Object.defineProperty(vt.prototype, \"interaction\", {\n    get: function () {\n      return this._interaction._proxy;\n    },\n    set: function () {}\n  });\n  var gt = function (t, e) {\n      for (var n = 0; n < e.length; n++) {\n        var r = e[n];\n        t.push(r);\n      }\n      return t;\n    },\n    mt = function (t) {\n      return gt([], t);\n    },\n    yt = function (t, e) {\n      for (var n = 0; n < t.length; n++) if (e(t[n], n, t)) return n;\n      return -1;\n    },\n    bt = function (t, e) {\n      return t[yt(t, e)];\n    },\n    xt = function (t) {\n      s(n, t);\n      var e = p(n);\n      function n(t, i, o) {\n        var a;\n        r(this, n), (a = e.call(this, i._interaction)).dropzone = void 0, a.dragEvent = void 0, a.relatedTarget = void 0, a.draggable = void 0, a.propagationStopped = !1, a.immediatePropagationStopped = !1;\n        var s = \"dragleave\" === o ? t.prev : t.cur,\n          c = s.element,\n          l = s.dropzone;\n        return a.type = o, a.target = c, a.currentTarget = c, a.dropzone = l, a.dragEvent = i, a.relatedTarget = i.target, a.draggable = i.interactable, a.timeStamp = i.timeStamp, a;\n      }\n      return o(n, [{\n        key: \"reject\",\n        value: function () {\n          var t = this,\n            e = this._interaction.dropState;\n          if (\"dropactivate\" === this.type || this.dropzone && e.cur.dropzone === this.dropzone && e.cur.element === this.target) if (e.prev.dropzone = this.dropzone, e.prev.element = this.target, e.rejected = !0, e.events.enter = null, this.stopImmediatePropagation(), \"dropactivate\" === this.type) {\n            var r = e.activeDrops,\n              i = yt(r, function (e) {\n                var n = e.dropzone,\n                  r = e.element;\n                return n === t.dropzone && r === t.target;\n              });\n            e.activeDrops.splice(i, 1);\n            var o = new n(e, this.dragEvent, \"dropdeactivate\");\n            o.dropzone = this.dropzone, o.target = this.target, this.dropzone.fire(o);\n          } else this.dropzone.fire(new n(e, this.dragEvent, \"dragleave\"));\n        }\n      }, {\n        key: \"preventDefault\",\n        value: function () {}\n      }, {\n        key: \"stopPropagation\",\n        value: function () {\n          this.propagationStopped = !0;\n        }\n      }, {\n        key: \"stopImmediatePropagation\",\n        value: function () {\n          this.immediatePropagationStopped = this.propagationStopped = !0;\n        }\n      }]), n;\n    }(vt);\n  function wt(t, e) {\n    for (var n = 0, r = t.slice(); n < r.length; n++) {\n      var i = r[n],\n        o = i.dropzone,\n        a = i.element;\n      e.dropzone = o, e.target = a, o.fire(e), e.propagationStopped = e.immediatePropagationStopped = !1;\n    }\n  }\n  function Et(t, e) {\n    for (var n = function (t, e) {\n        for (var n = [], r = 0, i = t.interactables.list; r < i.length; r++) {\n          var o = i[r];\n          if (o.options.drop.enabled) {\n            var a = o.options.drop.accept;\n            if (!(w.element(a) && a !== e || w.string(a) && !R(e, a) || w.func(a) && !a({\n              dropzone: o,\n              draggableElement: e\n            }))) for (var s = 0, c = o.getAllElements(); s < c.length; s++) {\n              var l = c[s];\n              l !== e && n.push({\n                dropzone: o,\n                element: l,\n                rect: o.getRect(l)\n              });\n            }\n          }\n        }\n        return n;\n      }(t, e), r = 0; r < n.length; r++) {\n      var i = n[r];\n      i.rect = i.dropzone.getRect(i.element);\n    }\n    return n;\n  }\n  function Tt(t, e, n) {\n    for (var r = t.dropState, i = t.interactable, o = t.element, a = [], s = 0, c = r.activeDrops; s < c.length; s++) {\n      var l = c[s],\n        u = l.dropzone,\n        p = l.element,\n        f = l.rect,\n        d = u.dropCheck(e, n, i, o, p, f);\n      a.push(d ? p : null);\n    }\n    var h = function (t) {\n      for (var e, n, r, i = [], o = 0; o < t.length; o++) {\n        var a = t[o],\n          s = t[e];\n        if (a && o !== e) if (s) {\n          var c = C(a),\n            l = C(s);\n          if (c !== a.ownerDocument) if (l !== a.ownerDocument) {\n            if (c !== l) {\n              i = i.length ? i : j(s);\n              var u = void 0;\n              if (s instanceof k.HTMLElement && a instanceof k.SVGElement && !(a instanceof k.SVGSVGElement)) {\n                if (a === l) continue;\n                u = a.ownerSVGElement;\n              } else u = a;\n              for (var p = j(u, s.ownerDocument), f = 0; p[f] && p[f] === i[f];) f++;\n              var d = [p[f - 1], p[f], i[f]];\n              if (d[0]) for (var h = d[0].lastChild; h;) {\n                if (h === d[1]) {\n                  e = o, i = p;\n                  break;\n                }\n                if (h === d[2]) break;\n                h = h.previousSibling;\n              }\n            } else r = s, void 0, void 0, (parseInt(y(n = a).getComputedStyle(n).zIndex, 10) || 0) >= (parseInt(y(r).getComputedStyle(r).zIndex, 10) || 0) && (e = o);\n          } else e = o;\n        } else e = o;\n      }\n      return e;\n    }(a);\n    return r.activeDrops[h] || null;\n  }\n  function St(t, e, n) {\n    var r = t.dropState,\n      i = {\n        enter: null,\n        leave: null,\n        activate: null,\n        deactivate: null,\n        move: null,\n        drop: null\n      };\n    return \"dragstart\" === n.type && (i.activate = new xt(r, n, \"dropactivate\"), i.activate.target = null, i.activate.dropzone = null), \"dragend\" === n.type && (i.deactivate = new xt(r, n, \"dropdeactivate\"), i.deactivate.target = null, i.deactivate.dropzone = null), r.rejected || (r.cur.element !== r.prev.element && (r.prev.dropzone && (i.leave = new xt(r, n, \"dragleave\"), n.dragLeave = i.leave.target = r.prev.element, n.prevDropzone = i.leave.dropzone = r.prev.dropzone), r.cur.dropzone && (i.enter = new xt(r, n, \"dragenter\"), n.dragEnter = r.cur.element, n.dropzone = r.cur.dropzone)), \"dragend\" === n.type && r.cur.dropzone && (i.drop = new xt(r, n, \"drop\"), n.dropzone = r.cur.dropzone, n.relatedTarget = r.cur.element), \"dragmove\" === n.type && r.cur.dropzone && (i.move = new xt(r, n, \"dropmove\"), n.dropzone = r.cur.dropzone)), i;\n  }\n  function _t(t, e) {\n    var n = t.dropState,\n      r = n.activeDrops,\n      i = n.cur,\n      o = n.prev;\n    e.leave && o.dropzone.fire(e.leave), e.enter && i.dropzone.fire(e.enter), e.move && i.dropzone.fire(e.move), e.drop && i.dropzone.fire(e.drop), e.deactivate && wt(r, e.deactivate), n.prev.dropzone = i.dropzone, n.prev.element = i.element;\n  }\n  function Pt(t, e) {\n    var n = t.interaction,\n      r = t.iEvent,\n      i = t.event;\n    if (\"dragmove\" === r.type || \"dragend\" === r.type) {\n      var o = n.dropState;\n      e.dynamicDrop && (o.activeDrops = Et(e, n.element));\n      var a = r,\n        s = Tt(n, a, i);\n      o.rejected = o.rejected && !!s && s.dropzone === o.cur.dropzone && s.element === o.cur.element, o.cur.dropzone = s && s.dropzone, o.cur.element = s && s.element, o.events = St(n, 0, a);\n    }\n  }\n  var Ot = {\n      id: \"actions/drop\",\n      install: function (t) {\n        var e = t.actions,\n          n = t.interactStatic,\n          r = t.Interactable,\n          i = t.defaults;\n        t.usePlugin(_), r.prototype.dropzone = function (t) {\n          return function (t, e) {\n            if (w.object(e)) {\n              if (t.options.drop.enabled = !1 !== e.enabled, e.listeners) {\n                var n = $(e.listeners),\n                  r = Object.keys(n).reduce(function (t, e) {\n                    return t[/^(enter|leave)/.test(e) ? \"drag\".concat(e) : /^(activate|deactivate|move)/.test(e) ? \"drop\".concat(e) : e] = n[e], t;\n                  }, {}),\n                  i = t.options.drop.listeners;\n                i && t.off(i), t.on(r), t.options.drop.listeners = r;\n              }\n              return w.func(e.ondrop) && t.on(\"drop\", e.ondrop), w.func(e.ondropactivate) && t.on(\"dropactivate\", e.ondropactivate), w.func(e.ondropdeactivate) && t.on(\"dropdeactivate\", e.ondropdeactivate), w.func(e.ondragenter) && t.on(\"dragenter\", e.ondragenter), w.func(e.ondragleave) && t.on(\"dragleave\", e.ondragleave), w.func(e.ondropmove) && t.on(\"dropmove\", e.ondropmove), /^(pointer|center)$/.test(e.overlap) ? t.options.drop.overlap = e.overlap : w.number(e.overlap) && (t.options.drop.overlap = Math.max(Math.min(1, e.overlap), 0)), \"accept\" in e && (t.options.drop.accept = e.accept), \"checker\" in e && (t.options.drop.checker = e.checker), t;\n            }\n            if (w.bool(e)) return t.options.drop.enabled = e, t;\n            return t.options.drop;\n          }(this, t);\n        }, r.prototype.dropCheck = function (t, e, n, r, i, o) {\n          return function (t, e, n, r, i, o, a) {\n            var s = !1;\n            if (!(a = a || t.getRect(o))) return !!t.options.drop.checker && t.options.drop.checker(e, n, s, t, o, r, i);\n            var c = t.options.drop.overlap;\n            if (\"pointer\" === c) {\n              var l = K(r, i, \"drag\"),\n                u = ot(e);\n              u.x += l.x, u.y += l.y;\n              var p = u.x > a.left && u.x < a.right,\n                f = u.y > a.top && u.y < a.bottom;\n              s = p && f;\n            }\n            var d = r.getRect(i);\n            if (d && \"center\" === c) {\n              var h = d.left + d.width / 2,\n                v = d.top + d.height / 2;\n              s = h >= a.left && h <= a.right && v >= a.top && v <= a.bottom;\n            }\n            if (d && w.number(c)) {\n              s = Math.max(0, Math.min(a.right, d.right) - Math.max(a.left, d.left)) * Math.max(0, Math.min(a.bottom, d.bottom) - Math.max(a.top, d.top)) / (d.width * d.height) >= c;\n            }\n            t.options.drop.checker && (s = t.options.drop.checker(e, n, s, t, o, r, i));\n            return s;\n          }(this, t, e, n, r, i, o);\n        }, n.dynamicDrop = function (e) {\n          return w.bool(e) ? (t.dynamicDrop = e, n) : t.dynamicDrop;\n        }, V(e.phaselessTypes, {\n          dragenter: !0,\n          dragleave: !0,\n          dropactivate: !0,\n          dropdeactivate: !0,\n          dropmove: !0,\n          drop: !0\n        }), e.methodDict.drop = \"dropzone\", t.dynamicDrop = !1, i.actions.drop = Ot.defaults;\n      },\n      listeners: {\n        \"interactions:before-action-start\": function (t) {\n          var e = t.interaction;\n          \"drag\" === e.prepared.name && (e.dropState = {\n            cur: {\n              dropzone: null,\n              element: null\n            },\n            prev: {\n              dropzone: null,\n              element: null\n            },\n            rejected: null,\n            events: null,\n            activeDrops: []\n          });\n        },\n        \"interactions:after-action-start\": function (t, e) {\n          var n = t.interaction,\n            r = (t.event, t.iEvent);\n          if (\"drag\" === n.prepared.name) {\n            var i = n.dropState;\n            i.activeDrops = [], i.events = {}, i.activeDrops = Et(e, n.element), i.events = St(n, 0, r), i.events.activate && (wt(i.activeDrops, i.events.activate), e.fire(\"actions/drop:start\", {\n              interaction: n,\n              dragEvent: r\n            }));\n          }\n        },\n        \"interactions:action-move\": Pt,\n        \"interactions:after-action-move\": function (t, e) {\n          var n = t.interaction,\n            r = t.iEvent;\n          if (\"drag\" === n.prepared.name) {\n            var i = n.dropState;\n            _t(n, i.events), e.fire(\"actions/drop:move\", {\n              interaction: n,\n              dragEvent: r\n            }), i.events = {};\n          }\n        },\n        \"interactions:action-end\": function (t, e) {\n          if (\"drag\" === t.interaction.prepared.name) {\n            var n = t.interaction,\n              r = t.iEvent;\n            Pt(t, e), _t(n, n.dropState.events), e.fire(\"actions/drop:end\", {\n              interaction: n,\n              dragEvent: r\n            });\n          }\n        },\n        \"interactions:stop\": function (t) {\n          var e = t.interaction;\n          if (\"drag\" === e.prepared.name) {\n            var n = e.dropState;\n            n && (n.activeDrops = null, n.events = null, n.cur.dropzone = null, n.cur.element = null, n.prev.dropzone = null, n.prev.element = null, n.rejected = !1);\n          }\n        }\n      },\n      getActiveDrops: Et,\n      getDrop: Tt,\n      getDropEvents: St,\n      fireDropEvents: _t,\n      filterEventType: function (t) {\n        return 0 === t.search(\"drag\") || 0 === t.search(\"drop\");\n      },\n      defaults: {\n        enabled: !1,\n        accept: null,\n        overlap: \"pointer\"\n      }\n    },\n    kt = Ot;\n  function Dt(t) {\n    var e = t.interaction,\n      n = t.iEvent,\n      r = t.phase;\n    if (\"gesture\" === e.prepared.name) {\n      var i = e.pointers.map(function (t) {\n          return t.pointer;\n        }),\n        o = \"start\" === r,\n        a = \"end\" === r,\n        s = e.interactable.options.deltaSource;\n      if (n.touches = [i[0], i[1]], o) n.distance = pt(i, s), n.box = ut(i), n.scale = 1, n.ds = 0, n.angle = ft(i, s), n.da = 0, e.gesture.startDistance = n.distance, e.gesture.startAngle = n.angle;else if (a || e.pointers.length < 2) {\n        var c = e.prevEvent;\n        n.distance = c.distance, n.box = c.box, n.scale = c.scale, n.ds = 0, n.angle = c.angle, n.da = 0;\n      } else n.distance = pt(i, s), n.box = ut(i), n.scale = n.distance / e.gesture.startDistance, n.angle = ft(i, s), n.ds = n.scale - e.gesture.scale, n.da = n.angle - e.gesture.angle;\n      e.gesture.distance = n.distance, e.gesture.angle = n.angle, w.number(n.scale) && n.scale !== 1 / 0 && !isNaN(n.scale) && (e.gesture.scale = n.scale);\n    }\n  }\n  var It = {\n      id: \"actions/gesture\",\n      before: [\"actions/drag\", \"actions/resize\"],\n      install: function (t) {\n        var e = t.actions,\n          n = t.Interactable,\n          r = t.defaults;\n        n.prototype.gesturable = function (t) {\n          return w.object(t) ? (this.options.gesture.enabled = !1 !== t.enabled, this.setPerAction(\"gesture\", t), this.setOnEvents(\"gesture\", t), this) : w.bool(t) ? (this.options.gesture.enabled = t, this) : this.options.gesture;\n        }, e.map.gesture = It, e.methodDict.gesture = \"gesturable\", r.actions.gesture = It.defaults;\n      },\n      listeners: {\n        \"interactions:action-start\": Dt,\n        \"interactions:action-move\": Dt,\n        \"interactions:action-end\": Dt,\n        \"interactions:new\": function (t) {\n          t.interaction.gesture = {\n            angle: 0,\n            distance: 0,\n            scale: 1,\n            startAngle: 0,\n            startDistance: 0\n          };\n        },\n        \"auto-start:check\": function (t) {\n          if (!(t.interaction.pointers.length < 2)) {\n            var e = t.interactable.options.gesture;\n            if (e && e.enabled) return t.action = {\n              name: \"gesture\"\n            }, !1;\n          }\n        }\n      },\n      defaults: {},\n      getCursor: function () {\n        return \"\";\n      },\n      filterEventType: function (t) {\n        return 0 === t.search(\"gesture\");\n      }\n    },\n    Mt = It;\n  function zt(t, e, n, r, i, o, a) {\n    if (!e) return !1;\n    if (!0 === e) {\n      var s = w.number(o.width) ? o.width : o.right - o.left,\n        c = w.number(o.height) ? o.height : o.bottom - o.top;\n      if (a = Math.min(a, Math.abs((\"left\" === t || \"right\" === t ? s : c) / 2)), s < 0 && (\"left\" === t ? t = \"right\" : \"right\" === t && (t = \"left\")), c < 0 && (\"top\" === t ? t = \"bottom\" : \"bottom\" === t && (t = \"top\")), \"left\" === t) {\n        var l = s >= 0 ? o.left : o.right;\n        return n.x < l + a;\n      }\n      if (\"top\" === t) {\n        var u = c >= 0 ? o.top : o.bottom;\n        return n.y < u + a;\n      }\n      if (\"right\" === t) return n.x > (s >= 0 ? o.right : o.left) - a;\n      if (\"bottom\" === t) return n.y > (c >= 0 ? o.bottom : o.top) - a;\n    }\n    return !!w.element(r) && (w.element(e) ? e === r : F(r, e, i));\n  }\n  function At(t) {\n    var e = t.iEvent,\n      n = t.interaction;\n    if (\"resize\" === n.prepared.name && n.resizeAxes) {\n      var r = e;\n      n.interactable.options.resize.square ? (\"y\" === n.resizeAxes ? r.delta.x = r.delta.y : r.delta.y = r.delta.x, r.axes = \"xy\") : (r.axes = n.resizeAxes, \"x\" === n.resizeAxes ? r.delta.y = 0 : \"y\" === n.resizeAxes && (r.delta.x = 0));\n    }\n  }\n  var Rt,\n    Ct,\n    jt = {\n      id: \"actions/resize\",\n      before: [\"actions/drag\"],\n      install: function (t) {\n        var e = t.actions,\n          n = t.browser,\n          r = t.Interactable,\n          i = t.defaults;\n        jt.cursors = function (t) {\n          return t.isIe9 ? {\n            x: \"e-resize\",\n            y: \"s-resize\",\n            xy: \"se-resize\",\n            top: \"n-resize\",\n            left: \"w-resize\",\n            bottom: \"s-resize\",\n            right: \"e-resize\",\n            topleft: \"se-resize\",\n            bottomright: \"se-resize\",\n            topright: \"ne-resize\",\n            bottomleft: \"ne-resize\"\n          } : {\n            x: \"ew-resize\",\n            y: \"ns-resize\",\n            xy: \"nwse-resize\",\n            top: \"ns-resize\",\n            left: \"ew-resize\",\n            bottom: \"ns-resize\",\n            right: \"ew-resize\",\n            topleft: \"nwse-resize\",\n            bottomright: \"nwse-resize\",\n            topright: \"nesw-resize\",\n            bottomleft: \"nesw-resize\"\n          };\n        }(n), jt.defaultMargin = n.supportsTouch || n.supportsPointerEvent ? 20 : 10, r.prototype.resizable = function (e) {\n          return function (t, e, n) {\n            if (w.object(e)) return t.options.resize.enabled = !1 !== e.enabled, t.setPerAction(\"resize\", e), t.setOnEvents(\"resize\", e), w.string(e.axis) && /^x$|^y$|^xy$/.test(e.axis) ? t.options.resize.axis = e.axis : null === e.axis && (t.options.resize.axis = n.defaults.actions.resize.axis), w.bool(e.preserveAspectRatio) ? t.options.resize.preserveAspectRatio = e.preserveAspectRatio : w.bool(e.square) && (t.options.resize.square = e.square), t;\n            if (w.bool(e)) return t.options.resize.enabled = e, t;\n            return t.options.resize;\n          }(this, e, t);\n        }, e.map.resize = jt, e.methodDict.resize = \"resizable\", i.actions.resize = jt.defaults;\n      },\n      listeners: {\n        \"interactions:new\": function (t) {\n          t.interaction.resizeAxes = \"xy\";\n        },\n        \"interactions:action-start\": function (t) {\n          !function (t) {\n            var e = t.iEvent,\n              n = t.interaction;\n            if (\"resize\" === n.prepared.name && n.prepared.edges) {\n              var r = e,\n                i = n.rect;\n              n._rects = {\n                start: V({}, i),\n                corrected: V({}, i),\n                previous: V({}, i),\n                delta: {\n                  left: 0,\n                  right: 0,\n                  width: 0,\n                  top: 0,\n                  bottom: 0,\n                  height: 0\n                }\n              }, r.edges = n.prepared.edges, r.rect = n._rects.corrected, r.deltaRect = n._rects.delta;\n            }\n          }(t), At(t);\n        },\n        \"interactions:action-move\": function (t) {\n          !function (t) {\n            var e = t.iEvent,\n              n = t.interaction;\n            if (\"resize\" === n.prepared.name && n.prepared.edges) {\n              var r = e,\n                i = n.interactable.options.resize.invert,\n                o = \"reposition\" === i || \"negate\" === i,\n                a = n.rect,\n                s = n._rects,\n                c = s.start,\n                l = s.corrected,\n                u = s.delta,\n                p = s.previous;\n              if (V(p, l), o) {\n                if (V(l, a), \"reposition\" === i) {\n                  if (l.top > l.bottom) {\n                    var f = l.top;\n                    l.top = l.bottom, l.bottom = f;\n                  }\n                  if (l.left > l.right) {\n                    var d = l.left;\n                    l.left = l.right, l.right = d;\n                  }\n                }\n              } else l.top = Math.min(a.top, c.bottom), l.bottom = Math.max(a.bottom, c.top), l.left = Math.min(a.left, c.right), l.right = Math.max(a.right, c.left);\n              for (var h in l.width = l.right - l.left, l.height = l.bottom - l.top, l) u[h] = l[h] - p[h];\n              r.edges = n.prepared.edges, r.rect = l, r.deltaRect = u;\n            }\n          }(t), At(t);\n        },\n        \"interactions:action-end\": function (t) {\n          var e = t.iEvent,\n            n = t.interaction;\n          if (\"resize\" === n.prepared.name && n.prepared.edges) {\n            var r = e;\n            r.edges = n.prepared.edges, r.rect = n._rects.corrected, r.deltaRect = n._rects.delta;\n          }\n        },\n        \"auto-start:check\": function (t) {\n          var e = t.interaction,\n            n = t.interactable,\n            r = t.element,\n            i = t.rect,\n            o = t.buttons;\n          if (i) {\n            var a = V({}, e.coords.cur.page),\n              s = n.options.resize;\n            if (s && s.enabled && (!e.pointerIsDown || !/mouse|pointer/.test(e.pointerType) || 0 != (o & s.mouseButtons))) {\n              if (w.object(s.edges)) {\n                var c = {\n                  left: !1,\n                  right: !1,\n                  top: !1,\n                  bottom: !1\n                };\n                for (var l in c) c[l] = zt(l, s.edges[l], a, e._latestPointer.eventTarget, r, i, s.margin || jt.defaultMargin);\n                c.left = c.left && !c.right, c.top = c.top && !c.bottom, (c.left || c.right || c.top || c.bottom) && (t.action = {\n                  name: \"resize\",\n                  edges: c\n                });\n              } else {\n                var u = \"y\" !== s.axis && a.x > i.right - jt.defaultMargin,\n                  p = \"x\" !== s.axis && a.y > i.bottom - jt.defaultMargin;\n                (u || p) && (t.action = {\n                  name: \"resize\",\n                  axes: (u ? \"x\" : \"\") + (p ? \"y\" : \"\")\n                });\n              }\n              return !t.action && void 0;\n            }\n          }\n        }\n      },\n      defaults: {\n        square: !1,\n        preserveAspectRatio: !1,\n        axis: \"xy\",\n        margin: NaN,\n        edges: null,\n        invert: \"none\"\n      },\n      cursors: null,\n      getCursor: function (t) {\n        var e = t.edges,\n          n = t.axis,\n          r = t.name,\n          i = jt.cursors,\n          o = null;\n        if (n) o = i[r + n];else if (e) {\n          for (var a = \"\", s = 0, c = [\"top\", \"bottom\", \"left\", \"right\"]; s < c.length; s++) {\n            var l = c[s];\n            e[l] && (a += l);\n          }\n          o = i[a];\n        }\n        return o;\n      },\n      filterEventType: function (t) {\n        return 0 === t.search(\"resize\");\n      },\n      defaultMargin: null\n    },\n    Ft = jt,\n    Xt = {\n      id: \"actions\",\n      install: function (t) {\n        t.usePlugin(Mt), t.usePlugin(Ft), t.usePlugin(_), t.usePlugin(kt);\n      }\n    },\n    Yt = 0;\n  var Lt = {\n    request: function (t) {\n      return Rt(t);\n    },\n    cancel: function (t) {\n      return Ct(t);\n    },\n    init: function (t) {\n      if (Rt = t.requestAnimationFrame, Ct = t.cancelAnimationFrame, !Rt) for (var e = [\"ms\", \"moz\", \"webkit\", \"o\"], n = 0; n < e.length; n++) {\n        var r = e[n];\n        Rt = t[\"\".concat(r, \"RequestAnimationFrame\")], Ct = t[\"\".concat(r, \"CancelAnimationFrame\")] || t[\"\".concat(r, \"CancelRequestAnimationFrame\")];\n      }\n      Rt = Rt && Rt.bind(t), Ct = Ct && Ct.bind(t), Rt || (Rt = function (e) {\n        var n = Date.now(),\n          r = Math.max(0, 16 - (n - Yt)),\n          i = t.setTimeout(function () {\n            e(n + r);\n          }, r);\n        return Yt = n + r, i;\n      }, Ct = function (t) {\n        return clearTimeout(t);\n      });\n    }\n  };\n  var qt = {\n    defaults: {\n      enabled: !1,\n      margin: 60,\n      container: null,\n      speed: 300\n    },\n    now: Date.now,\n    interaction: null,\n    i: 0,\n    x: 0,\n    y: 0,\n    isScrolling: !1,\n    prevTime: 0,\n    margin: 0,\n    speed: 0,\n    start: function (t) {\n      qt.isScrolling = !0, Lt.cancel(qt.i), t.autoScroll = qt, qt.interaction = t, qt.prevTime = qt.now(), qt.i = Lt.request(qt.scroll);\n    },\n    stop: function () {\n      qt.isScrolling = !1, qt.interaction && (qt.interaction.autoScroll = null), Lt.cancel(qt.i);\n    },\n    scroll: function () {\n      var t = qt.interaction,\n        e = t.interactable,\n        n = t.element,\n        r = t.prepared.name,\n        i = e.options[r].autoScroll,\n        o = Bt(i.container, e, n),\n        a = qt.now(),\n        s = (a - qt.prevTime) / 1e3,\n        c = i.speed * s;\n      if (c >= 1) {\n        var l = {\n          x: qt.x * c,\n          y: qt.y * c\n        };\n        if (l.x || l.y) {\n          var u = Vt(o);\n          w.window(o) ? o.scrollBy(l.x, l.y) : o && (o.scrollLeft += l.x, o.scrollTop += l.y);\n          var p = Vt(o),\n            f = {\n              x: p.x - u.x,\n              y: p.y - u.y\n            };\n          (f.x || f.y) && e.fire({\n            type: \"autoscroll\",\n            target: n,\n            interactable: e,\n            delta: f,\n            interaction: t,\n            container: o\n          });\n        }\n        qt.prevTime = a;\n      }\n      qt.isScrolling && (Lt.cancel(qt.i), qt.i = Lt.request(qt.scroll));\n    },\n    check: function (t, e) {\n      var n;\n      return null == (n = t.options[e].autoScroll) ? void 0 : n.enabled;\n    },\n    onInteractionMove: function (t) {\n      var e = t.interaction,\n        n = t.pointer;\n      if (e.interacting() && qt.check(e.interactable, e.prepared.name)) if (e.simulation) qt.x = qt.y = 0;else {\n        var r,\n          i,\n          o,\n          a,\n          s = e.interactable,\n          c = e.element,\n          l = e.prepared.name,\n          u = s.options[l].autoScroll,\n          p = Bt(u.container, s, c);\n        if (w.window(p)) a = n.clientX < qt.margin, r = n.clientY < qt.margin, i = n.clientX > p.innerWidth - qt.margin, o = n.clientY > p.innerHeight - qt.margin;else {\n          var f = Y(p);\n          a = n.clientX < f.left + qt.margin, r = n.clientY < f.top + qt.margin, i = n.clientX > f.right - qt.margin, o = n.clientY > f.bottom - qt.margin;\n        }\n        qt.x = i ? 1 : a ? -1 : 0, qt.y = o ? 1 : r ? -1 : 0, qt.isScrolling || (qt.margin = u.margin, qt.speed = u.speed, qt.start(e));\n      }\n    }\n  };\n  function Bt(t, e, n) {\n    return (w.string(t) ? W(t, e, n) : t) || y(n);\n  }\n  function Vt(t) {\n    return w.window(t) && (t = window.document.body), {\n      x: t.scrollLeft,\n      y: t.scrollTop\n    };\n  }\n  var Wt = {\n      id: \"auto-scroll\",\n      install: function (t) {\n        var e = t.defaults,\n          n = t.actions;\n        t.autoScroll = qt, qt.now = function () {\n          return t.now();\n        }, n.phaselessTypes.autoscroll = !0, e.perAction.autoScroll = qt.defaults;\n      },\n      listeners: {\n        \"interactions:new\": function (t) {\n          t.interaction.autoScroll = null;\n        },\n        \"interactions:destroy\": function (t) {\n          t.interaction.autoScroll = null, qt.stop(), qt.interaction && (qt.interaction = null);\n        },\n        \"interactions:stop\": qt.stop,\n        \"interactions:action-move\": function (t) {\n          return qt.onInteractionMove(t);\n        }\n      }\n    },\n    Gt = Wt;\n  function Nt(t, e) {\n    var n = !1;\n    return function () {\n      return n || (g.console.warn(e), n = !0), t.apply(this, arguments);\n    };\n  }\n  function Ut(t, e) {\n    return t.name = e.name, t.axis = e.axis, t.edges = e.edges, t;\n  }\n  function Ht(t) {\n    return w.bool(t) ? (this.options.styleCursor = t, this) : null === t ? (delete this.options.styleCursor, this) : this.options.styleCursor;\n  }\n  function Kt(t) {\n    return w.func(t) ? (this.options.actionChecker = t, this) : null === t ? (delete this.options.actionChecker, this) : this.options.actionChecker;\n  }\n  var $t = {\n    id: \"auto-start/interactableMethods\",\n    install: function (t) {\n      var e = t.Interactable;\n      e.prototype.getAction = function (e, n, r, i) {\n        var o = function (t, e, n, r, i) {\n          var o = t.getRect(r),\n            a = e.buttons || {\n              0: 1,\n              1: 4,\n              3: 8,\n              4: 16\n            }[e.button],\n            s = {\n              action: null,\n              interactable: t,\n              interaction: n,\n              element: r,\n              rect: o,\n              buttons: a\n            };\n          return i.fire(\"auto-start:check\", s), s.action;\n        }(this, n, r, i, t);\n        return this.options.actionChecker ? this.options.actionChecker(e, n, o, this, i, r) : o;\n      }, e.prototype.ignoreFrom = Nt(function (t) {\n        return this._backCompatOption(\"ignoreFrom\", t);\n      }, \"Interactable.ignoreFrom() has been deprecated. Use Interactble.draggable({ignoreFrom: newValue}).\"), e.prototype.allowFrom = Nt(function (t) {\n        return this._backCompatOption(\"allowFrom\", t);\n      }, \"Interactable.allowFrom() has been deprecated. Use Interactble.draggable({allowFrom: newValue}).\"), e.prototype.actionChecker = Kt, e.prototype.styleCursor = Ht;\n    }\n  };\n  function Jt(t, e, n, r, i) {\n    return e.testIgnoreAllow(e.options[t.name], n, r) && e.options[t.name].enabled && ee(e, n, t, i) ? t : null;\n  }\n  function Qt(t, e, n, r, i, o, a) {\n    for (var s = 0, c = r.length; s < c; s++) {\n      var l = r[s],\n        u = i[s],\n        p = l.getAction(e, n, t, u);\n      if (p) {\n        var f = Jt(p, l, u, o, a);\n        if (f) return {\n          action: f,\n          interactable: l,\n          element: u\n        };\n      }\n    }\n    return {\n      action: null,\n      interactable: null,\n      element: null\n    };\n  }\n  function Zt(t, e, n, r, i) {\n    var o = [],\n      a = [],\n      s = r;\n    function c(t) {\n      o.push(t), a.push(s);\n    }\n    for (; w.element(s);) {\n      o = [], a = [], i.interactables.forEachMatch(s, c);\n      var l = Qt(t, e, n, o, a, r, i);\n      if (l.action && !l.interactable.options[l.action.name].manualStart) return l;\n      s = A(s);\n    }\n    return {\n      action: null,\n      interactable: null,\n      element: null\n    };\n  }\n  function te(t, e, n) {\n    var r = e.action,\n      i = e.interactable,\n      o = e.element;\n    r = r || {\n      name: null\n    }, t.interactable = i, t.element = o, Ut(t.prepared, r), t.rect = i && r.name ? i.getRect(o) : null, ie(t, n), n.fire(\"autoStart:prepared\", {\n      interaction: t\n    });\n  }\n  function ee(t, e, n, r) {\n    var i = t.options,\n      o = i[n.name].max,\n      a = i[n.name].maxPerElement,\n      s = r.autoStart.maxInteractions,\n      c = 0,\n      l = 0,\n      u = 0;\n    if (!(o && a && s)) return !1;\n    for (var p = 0, f = r.interactions.list; p < f.length; p++) {\n      var d = f[p],\n        h = d.prepared.name;\n      if (d.interacting()) {\n        if (++c >= s) return !1;\n        if (d.interactable === t) {\n          if ((l += h === n.name ? 1 : 0) >= o) return !1;\n          if (d.element === e && (u++, h === n.name && u >= a)) return !1;\n        }\n      }\n    }\n    return s > 0;\n  }\n  function ne(t, e) {\n    return w.number(t) ? (e.autoStart.maxInteractions = t, this) : e.autoStart.maxInteractions;\n  }\n  function re(t, e, n) {\n    var r = n.autoStart.cursorElement;\n    r && r !== t && (r.style.cursor = \"\"), t.ownerDocument.documentElement.style.cursor = e, t.style.cursor = e, n.autoStart.cursorElement = e ? t : null;\n  }\n  function ie(t, e) {\n    var n = t.interactable,\n      r = t.element,\n      i = t.prepared;\n    if (\"mouse\" === t.pointerType && n && n.options.styleCursor) {\n      var o = \"\";\n      if (i.name) {\n        var a = n.options[i.name].cursorChecker;\n        o = w.func(a) ? a(i, n, r, t._interacting) : e.actions.map[i.name].getCursor(i);\n      }\n      re(t.element, o || \"\", e);\n    } else e.autoStart.cursorElement && re(e.autoStart.cursorElement, \"\", e);\n  }\n  var oe = {\n      id: \"auto-start/base\",\n      before: [\"actions\"],\n      install: function (t) {\n        var e = t.interactStatic,\n          n = t.defaults;\n        t.usePlugin($t), n.base.actionChecker = null, n.base.styleCursor = !0, V(n.perAction, {\n          manualStart: !1,\n          max: 1 / 0,\n          maxPerElement: 1,\n          allowFrom: null,\n          ignoreFrom: null,\n          mouseButtons: 1\n        }), e.maxInteractions = function (e) {\n          return ne(e, t);\n        }, t.autoStart = {\n          maxInteractions: 1 / 0,\n          withinInteractionLimit: ee,\n          cursorElement: null\n        };\n      },\n      listeners: {\n        \"interactions:down\": function (t, e) {\n          var n = t.interaction,\n            r = t.pointer,\n            i = t.event,\n            o = t.eventTarget;\n          n.interacting() || te(n, Zt(n, r, i, o, e), e);\n        },\n        \"interactions:move\": function (t, e) {\n          !function (t, e) {\n            var n = t.interaction,\n              r = t.pointer,\n              i = t.event,\n              o = t.eventTarget;\n            \"mouse\" !== n.pointerType || n.pointerIsDown || n.interacting() || te(n, Zt(n, r, i, o, e), e);\n          }(t, e), function (t, e) {\n            var n = t.interaction;\n            if (n.pointerIsDown && !n.interacting() && n.pointerWasMoved && n.prepared.name) {\n              e.fire(\"autoStart:before-start\", t);\n              var r = n.interactable,\n                i = n.prepared.name;\n              i && r && (r.options[i].manualStart || !ee(r, n.element, n.prepared, e) ? n.stop() : (n.start(n.prepared, r, n.element), ie(n, e)));\n            }\n          }(t, e);\n        },\n        \"interactions:stop\": function (t, e) {\n          var n = t.interaction,\n            r = n.interactable;\n          r && r.options.styleCursor && re(n.element, \"\", e);\n        }\n      },\n      maxInteractions: ne,\n      withinInteractionLimit: ee,\n      validateAction: Jt\n    },\n    ae = oe;\n  var se = {\n    id: \"auto-start/dragAxis\",\n    listeners: {\n      \"autoStart:before-start\": function (t, e) {\n        var n = t.interaction,\n          r = t.eventTarget,\n          i = t.dx,\n          o = t.dy;\n        if (\"drag\" === n.prepared.name) {\n          var a = Math.abs(i),\n            s = Math.abs(o),\n            c = n.interactable.options.drag,\n            l = c.startAxis,\n            u = a > s ? \"x\" : a < s ? \"y\" : \"xy\";\n          if (n.prepared.axis = \"start\" === c.lockAxis ? u[0] : c.lockAxis, \"xy\" !== u && \"xy\" !== l && l !== u) {\n            n.prepared.name = null;\n            for (var p = r, f = function (t) {\n                if (t !== n.interactable) {\n                  var i = n.interactable.options.drag;\n                  if (!i.manualStart && t.testIgnoreAllow(i, p, r)) {\n                    var o = t.getAction(n.downPointer, n.downEvent, n, p);\n                    if (o && \"drag\" === o.name && function (t, e) {\n                      if (!e) return !1;\n                      var n = e.options.drag.startAxis;\n                      return \"xy\" === t || \"xy\" === n || n === t;\n                    }(u, t) && ae.validateAction(o, t, p, r, e)) return t;\n                  }\n                }\n              }; w.element(p);) {\n              var d = e.interactables.forEachMatch(p, f);\n              if (d) {\n                n.prepared.name = \"drag\", n.interactable = d, n.element = p;\n                break;\n              }\n              p = A(p);\n            }\n          }\n        }\n      }\n    }\n  };\n  function ce(t) {\n    var e = t.prepared && t.prepared.name;\n    if (!e) return null;\n    var n = t.interactable.options;\n    return n[e].hold || n[e].delay;\n  }\n  var le = {\n      id: \"auto-start/hold\",\n      install: function (t) {\n        var e = t.defaults;\n        t.usePlugin(ae), e.perAction.hold = 0, e.perAction.delay = 0;\n      },\n      listeners: {\n        \"interactions:new\": function (t) {\n          t.interaction.autoStartHoldTimer = null;\n        },\n        \"autoStart:prepared\": function (t) {\n          var e = t.interaction,\n            n = ce(e);\n          n > 0 && (e.autoStartHoldTimer = setTimeout(function () {\n            e.start(e.prepared, e.interactable, e.element);\n          }, n));\n        },\n        \"interactions:move\": function (t) {\n          var e = t.interaction,\n            n = t.duplicate;\n          e.autoStartHoldTimer && e.pointerWasMoved && !n && (clearTimeout(e.autoStartHoldTimer), e.autoStartHoldTimer = null);\n        },\n        \"autoStart:before-start\": function (t) {\n          var e = t.interaction;\n          ce(e) > 0 && (e.prepared.name = null);\n        }\n      },\n      getHoldDuration: ce\n    },\n    ue = le,\n    pe = {\n      id: \"auto-start\",\n      install: function (t) {\n        t.usePlugin(ae), t.usePlugin(ue), t.usePlugin(se);\n      }\n    },\n    fe = function (t) {\n      return /^(always|never|auto)$/.test(t) ? (this.options.preventDefault = t, this) : w.bool(t) ? (this.options.preventDefault = t ? \"always\" : \"never\", this) : this.options.preventDefault;\n    };\n  function de(t) {\n    var e = t.interaction,\n      n = t.event;\n    e.interactable && e.interactable.checkAndPreventDefault(n);\n  }\n  var he = {\n    id: \"core/interactablePreventDefault\",\n    install: function (t) {\n      var e = t.Interactable;\n      e.prototype.preventDefault = fe, e.prototype.checkAndPreventDefault = function (e) {\n        return function (t, e, n) {\n          var r = t.options.preventDefault;\n          if (\"never\" !== r) if (\"always\" !== r) {\n            if (e.events.supportsPassive && /^touch(start|move)$/.test(n.type)) {\n              var i = y(n.target).document,\n                o = e.getDocOptions(i);\n              if (!o || !o.events || !1 !== o.events.passive) return;\n            }\n            /^(mouse|pointer|touch)*(down|start)/i.test(n.type) || w.element(n.target) && R(n.target, \"input,select,textarea,[contenteditable=true],[contenteditable=true] *\") || n.preventDefault();\n          } else n.preventDefault();\n        }(this, t, e);\n      }, t.interactions.docEvents.push({\n        type: \"dragstart\",\n        listener: function (e) {\n          for (var n = 0, r = t.interactions.list; n < r.length; n++) {\n            var i = r[n];\n            if (i.element && (i.element === e.target || M(i.element, e.target))) return void i.interactable.checkAndPreventDefault(e);\n          }\n        }\n      });\n    },\n    listeners: [\"down\", \"move\", \"up\", \"cancel\"].reduce(function (t, e) {\n      return t[\"interactions:\".concat(e)] = de, t;\n    }, {})\n  };\n  function ve(t, e) {\n    if (e.phaselessTypes[t]) return !0;\n    for (var n in e.map) if (0 === t.indexOf(n) && t.substr(n.length) in e.phases) return !0;\n    return !1;\n  }\n  function ge(t) {\n    var e = {};\n    for (var n in t) {\n      var r = t[n];\n      w.plainObject(r) ? e[n] = ge(r) : w.array(r) ? e[n] = mt(r) : e[n] = r;\n    }\n    return e;\n  }\n  var me = function () {\n    function t(e) {\n      r(this, t), this.states = [], this.startOffset = {\n        left: 0,\n        right: 0,\n        top: 0,\n        bottom: 0\n      }, this.startDelta = void 0, this.result = void 0, this.endResult = void 0, this.startEdges = void 0, this.edges = void 0, this.interaction = void 0, this.interaction = e, this.result = ye(), this.edges = {\n        left: !1,\n        right: !1,\n        top: !1,\n        bottom: !1\n      };\n    }\n    return o(t, [{\n      key: \"start\",\n      value: function (t, e) {\n        var n,\n          r,\n          i = t.phase,\n          o = this.interaction,\n          a = function (t) {\n            var e = t.interactable.options[t.prepared.name],\n              n = e.modifiers;\n            if (n && n.length) return n;\n            return [\"snap\", \"snapSize\", \"snapEdges\", \"restrict\", \"restrictEdges\", \"restrictSize\"].map(function (t) {\n              var n = e[t];\n              return n && n.enabled && {\n                options: n,\n                methods: n._methods\n              };\n            }).filter(function (t) {\n              return !!t;\n            });\n          }(o);\n        this.prepareStates(a), this.startEdges = V({}, o.edges), this.edges = V({}, this.startEdges), this.startOffset = (n = o.rect, r = e, n ? {\n          left: r.x - n.left,\n          top: r.y - n.top,\n          right: n.right - r.x,\n          bottom: n.bottom - r.y\n        } : {\n          left: 0,\n          top: 0,\n          right: 0,\n          bottom: 0\n        }), this.startDelta = {\n          x: 0,\n          y: 0\n        };\n        var s = this.fillArg({\n          phase: i,\n          pageCoords: e,\n          preEnd: !1\n        });\n        return this.result = ye(), this.startAll(s), this.result = this.setAll(s);\n      }\n    }, {\n      key: \"fillArg\",\n      value: function (t) {\n        var e = this.interaction;\n        return t.interaction = e, t.interactable = e.interactable, t.element = e.element, t.rect || (t.rect = e.rect), t.edges || (t.edges = this.startEdges), t.startOffset = this.startOffset, t;\n      }\n    }, {\n      key: \"startAll\",\n      value: function (t) {\n        for (var e = 0, n = this.states; e < n.length; e++) {\n          var r = n[e];\n          r.methods.start && (t.state = r, r.methods.start(t));\n        }\n      }\n    }, {\n      key: \"setAll\",\n      value: function (t) {\n        var e = t.phase,\n          n = t.preEnd,\n          r = t.skipModifiers,\n          i = t.rect,\n          o = t.edges;\n        t.coords = V({}, t.pageCoords), t.rect = V({}, i), t.edges = V({}, o);\n        for (var a = r ? this.states.slice(r) : this.states, s = ye(t.coords, t.rect), c = 0; c < a.length; c++) {\n          var l,\n            u = a[c],\n            p = u.options,\n            f = V({}, t.coords),\n            d = null;\n          null != (l = u.methods) && l.set && this.shouldDo(p, n, e) && (t.state = u, d = u.methods.set(t), H(t.edges, t.rect, {\n            x: t.coords.x - f.x,\n            y: t.coords.y - f.y\n          })), s.eventProps.push(d);\n        }\n        V(this.edges, t.edges), s.delta.x = t.coords.x - t.pageCoords.x, s.delta.y = t.coords.y - t.pageCoords.y, s.rectDelta.left = t.rect.left - i.left, s.rectDelta.right = t.rect.right - i.right, s.rectDelta.top = t.rect.top - i.top, s.rectDelta.bottom = t.rect.bottom - i.bottom;\n        var h = this.result.coords,\n          v = this.result.rect;\n        if (h && v) {\n          var g = s.rect.left !== v.left || s.rect.right !== v.right || s.rect.top !== v.top || s.rect.bottom !== v.bottom;\n          s.changed = g || h.x !== s.coords.x || h.y !== s.coords.y;\n        }\n        return s;\n      }\n    }, {\n      key: \"applyToInteraction\",\n      value: function (t) {\n        var e = this.interaction,\n          n = t.phase,\n          r = e.coords.cur,\n          i = e.coords.start,\n          o = this.result,\n          a = this.startDelta,\n          s = o.delta;\n        \"start\" === n && V(this.startDelta, o.delta);\n        for (var c = 0, l = [[i, a], [r, s]]; c < l.length; c++) {\n          var u = l[c],\n            p = u[0],\n            f = u[1];\n          p.page.x += f.x, p.page.y += f.y, p.client.x += f.x, p.client.y += f.y;\n        }\n        var d = this.result.rectDelta,\n          h = t.rect || e.rect;\n        h.left += d.left, h.right += d.right, h.top += d.top, h.bottom += d.bottom, h.width = h.right - h.left, h.height = h.bottom - h.top;\n      }\n    }, {\n      key: \"setAndApply\",\n      value: function (t) {\n        var e = this.interaction,\n          n = t.phase,\n          r = t.preEnd,\n          i = t.skipModifiers,\n          o = this.setAll(this.fillArg({\n            preEnd: r,\n            phase: n,\n            pageCoords: t.modifiedCoords || e.coords.cur.page\n          }));\n        if (this.result = o, !o.changed && (!i || i < this.states.length) && e.interacting()) return !1;\n        if (t.modifiedCoords) {\n          var a = e.coords.cur.page,\n            s = {\n              x: t.modifiedCoords.x - a.x,\n              y: t.modifiedCoords.y - a.y\n            };\n          o.coords.x += s.x, o.coords.y += s.y, o.delta.x += s.x, o.delta.y += s.y;\n        }\n        this.applyToInteraction(t);\n      }\n    }, {\n      key: \"beforeEnd\",\n      value: function (t) {\n        var e = t.interaction,\n          n = t.event,\n          r = this.states;\n        if (r && r.length) {\n          for (var i = !1, o = 0; o < r.length; o++) {\n            var a = r[o];\n            t.state = a;\n            var s = a.options,\n              c = a.methods,\n              l = c.beforeEnd && c.beforeEnd(t);\n            if (l) return this.endResult = l, !1;\n            i = i || !i && this.shouldDo(s, !0, t.phase, !0);\n          }\n          i && e.move({\n            event: n,\n            preEnd: !0\n          });\n        }\n      }\n    }, {\n      key: \"stop\",\n      value: function (t) {\n        var e = t.interaction;\n        if (this.states && this.states.length) {\n          var n = V({\n            states: this.states,\n            interactable: e.interactable,\n            element: e.element,\n            rect: null\n          }, t);\n          this.fillArg(n);\n          for (var r = 0, i = this.states; r < i.length; r++) {\n            var o = i[r];\n            n.state = o, o.methods.stop && o.methods.stop(n);\n          }\n          this.states = null, this.endResult = null;\n        }\n      }\n    }, {\n      key: \"prepareStates\",\n      value: function (t) {\n        this.states = [];\n        for (var e = 0; e < t.length; e++) {\n          var n = t[e],\n            r = n.options,\n            i = n.methods,\n            o = n.name;\n          this.states.push({\n            options: r,\n            methods: i,\n            index: e,\n            name: o\n          });\n        }\n        return this.states;\n      }\n    }, {\n      key: \"restoreInteractionCoords\",\n      value: function (t) {\n        var e = t.interaction,\n          n = e.coords,\n          r = e.rect,\n          i = e.modification;\n        if (i.result) {\n          for (var o = i.startDelta, a = i.result, s = a.delta, c = a.rectDelta, l = 0, u = [[n.start, o], [n.cur, s]]; l < u.length; l++) {\n            var p = u[l],\n              f = p[0],\n              d = p[1];\n            f.page.x -= d.x, f.page.y -= d.y, f.client.x -= d.x, f.client.y -= d.y;\n          }\n          r.left -= c.left, r.right -= c.right, r.top -= c.top, r.bottom -= c.bottom;\n        }\n      }\n    }, {\n      key: \"shouldDo\",\n      value: function (t, e, n, r) {\n        return !(!t || !1 === t.enabled || r && !t.endOnly || t.endOnly && !e || \"start\" === n && !t.setStart);\n      }\n    }, {\n      key: \"copyFrom\",\n      value: function (t) {\n        this.startOffset = t.startOffset, this.startDelta = t.startDelta, this.startEdges = t.startEdges, this.edges = t.edges, this.states = t.states.map(function (t) {\n          return ge(t);\n        }), this.result = ye(V({}, t.result.coords), V({}, t.result.rect));\n      }\n    }, {\n      key: \"destroy\",\n      value: function () {\n        for (var t in this) this[t] = null;\n      }\n    }]), t;\n  }();\n  function ye(t, e) {\n    return {\n      rect: e,\n      coords: t,\n      delta: {\n        x: 0,\n        y: 0\n      },\n      rectDelta: {\n        left: 0,\n        right: 0,\n        top: 0,\n        bottom: 0\n      },\n      eventProps: [],\n      changed: !0\n    };\n  }\n  function be(t, e) {\n    var n = t.defaults,\n      r = {\n        start: t.start,\n        set: t.set,\n        beforeEnd: t.beforeEnd,\n        stop: t.stop\n      },\n      i = function (t) {\n        var i = t || {};\n        for (var o in i.enabled = !1 !== i.enabled, n) o in i || (i[o] = n[o]);\n        var a = {\n          options: i,\n          methods: r,\n          name: e,\n          enable: function () {\n            return i.enabled = !0, a;\n          },\n          disable: function () {\n            return i.enabled = !1, a;\n          }\n        };\n        return a;\n      };\n    return e && \"string\" == typeof e && (i._defaults = n, i._methods = r), i;\n  }\n  function xe(t) {\n    var e = t.iEvent,\n      n = t.interaction.modification.result;\n    n && (e.modifiers = n.eventProps);\n  }\n  var we = {\n      id: \"modifiers/base\",\n      before: [\"actions\"],\n      install: function (t) {\n        t.defaults.perAction.modifiers = [];\n      },\n      listeners: {\n        \"interactions:new\": function (t) {\n          var e = t.interaction;\n          e.modification = new me(e);\n        },\n        \"interactions:before-action-start\": function (t) {\n          var e = t.interaction,\n            n = t.interaction.modification;\n          n.start(t, e.coords.start.page), e.edges = n.edges, n.applyToInteraction(t);\n        },\n        \"interactions:before-action-move\": function (t) {\n          var e = t.interaction,\n            n = e.modification,\n            r = n.setAndApply(t);\n          return e.edges = n.edges, r;\n        },\n        \"interactions:before-action-end\": function (t) {\n          var e = t.interaction,\n            n = e.modification,\n            r = n.beforeEnd(t);\n          return e.edges = n.startEdges, r;\n        },\n        \"interactions:action-start\": xe,\n        \"interactions:action-move\": xe,\n        \"interactions:action-end\": xe,\n        \"interactions:after-action-start\": function (t) {\n          return t.interaction.modification.restoreInteractionCoords(t);\n        },\n        \"interactions:after-action-move\": function (t) {\n          return t.interaction.modification.restoreInteractionCoords(t);\n        },\n        \"interactions:stop\": function (t) {\n          return t.interaction.modification.stop(t);\n        }\n      }\n    },\n    Ee = we,\n    Te = {\n      base: {\n        preventDefault: \"auto\",\n        deltaSource: \"page\"\n      },\n      perAction: {\n        enabled: !1,\n        origin: {\n          x: 0,\n          y: 0\n        }\n      },\n      actions: {}\n    },\n    Se = function (t) {\n      s(n, t);\n      var e = p(n);\n      function n(t, i, o, a, s, c, l) {\n        var p;\n        r(this, n), (p = e.call(this, t)).relatedTarget = null, p.screenX = void 0, p.screenY = void 0, p.button = void 0, p.buttons = void 0, p.ctrlKey = void 0, p.shiftKey = void 0, p.altKey = void 0, p.metaKey = void 0, p.page = void 0, p.client = void 0, p.delta = void 0, p.rect = void 0, p.x0 = void 0, p.y0 = void 0, p.t0 = void 0, p.dt = void 0, p.duration = void 0, p.clientX0 = void 0, p.clientY0 = void 0, p.velocity = void 0, p.speed = void 0, p.swipe = void 0, p.axes = void 0, p.preEnd = void 0, s = s || t.element;\n        var f = t.interactable,\n          d = (f && f.options || Te).deltaSource,\n          h = K(f, s, o),\n          v = \"start\" === a,\n          g = \"end\" === a,\n          m = v ? u(p) : t.prevEvent,\n          y = v ? t.coords.start : g ? {\n            page: m.page,\n            client: m.client,\n            timeStamp: t.coords.cur.timeStamp\n          } : t.coords.cur;\n        return p.page = V({}, y.page), p.client = V({}, y.client), p.rect = V({}, t.rect), p.timeStamp = y.timeStamp, g || (p.page.x -= h.x, p.page.y -= h.y, p.client.x -= h.x, p.client.y -= h.y), p.ctrlKey = i.ctrlKey, p.altKey = i.altKey, p.shiftKey = i.shiftKey, p.metaKey = i.metaKey, p.button = i.button, p.buttons = i.buttons, p.target = s, p.currentTarget = s, p.preEnd = c, p.type = l || o + (a || \"\"), p.interactable = f, p.t0 = v ? t.pointers[t.pointers.length - 1].downTime : m.t0, p.x0 = t.coords.start.page.x - h.x, p.y0 = t.coords.start.page.y - h.y, p.clientX0 = t.coords.start.client.x - h.x, p.clientY0 = t.coords.start.client.y - h.y, p.delta = v || g ? {\n          x: 0,\n          y: 0\n        } : {\n          x: p[d].x - m[d].x,\n          y: p[d].y - m[d].y\n        }, p.dt = t.coords.delta.timeStamp, p.duration = p.timeStamp - p.t0, p.velocity = V({}, t.coords.velocity[d]), p.speed = Q(p.velocity.x, p.velocity.y), p.swipe = g || \"inertiastart\" === a ? p.getSwipe() : null, p;\n      }\n      return o(n, [{\n        key: \"getSwipe\",\n        value: function () {\n          var t = this._interaction;\n          if (t.prevEvent.speed < 600 || this.timeStamp - t.prevEvent.timeStamp > 150) return null;\n          var e = 180 * Math.atan2(t.prevEvent.velocityY, t.prevEvent.velocityX) / Math.PI;\n          e < 0 && (e += 360);\n          var n = 112.5 <= e && e < 247.5,\n            r = 202.5 <= e && e < 337.5;\n          return {\n            up: r,\n            down: !r && 22.5 <= e && e < 157.5,\n            left: n,\n            right: !n && (292.5 <= e || e < 67.5),\n            angle: e,\n            speed: t.prevEvent.speed,\n            velocity: {\n              x: t.prevEvent.velocityX,\n              y: t.prevEvent.velocityY\n            }\n          };\n        }\n      }, {\n        key: \"preventDefault\",\n        value: function () {}\n      }, {\n        key: \"stopImmediatePropagation\",\n        value: function () {\n          this.immediatePropagationStopped = this.propagationStopped = !0;\n        }\n      }, {\n        key: \"stopPropagation\",\n        value: function () {\n          this.propagationStopped = !0;\n        }\n      }]), n;\n    }(vt);\n  Object.defineProperties(Se.prototype, {\n    pageX: {\n      get: function () {\n        return this.page.x;\n      },\n      set: function (t) {\n        this.page.x = t;\n      }\n    },\n    pageY: {\n      get: function () {\n        return this.page.y;\n      },\n      set: function (t) {\n        this.page.y = t;\n      }\n    },\n    clientX: {\n      get: function () {\n        return this.client.x;\n      },\n      set: function (t) {\n        this.client.x = t;\n      }\n    },\n    clientY: {\n      get: function () {\n        return this.client.y;\n      },\n      set: function (t) {\n        this.client.y = t;\n      }\n    },\n    dx: {\n      get: function () {\n        return this.delta.x;\n      },\n      set: function (t) {\n        this.delta.x = t;\n      }\n    },\n    dy: {\n      get: function () {\n        return this.delta.y;\n      },\n      set: function (t) {\n        this.delta.y = t;\n      }\n    },\n    velocityX: {\n      get: function () {\n        return this.velocity.x;\n      },\n      set: function (t) {\n        this.velocity.x = t;\n      }\n    },\n    velocityY: {\n      get: function () {\n        return this.velocity.y;\n      },\n      set: function (t) {\n        this.velocity.y = t;\n      }\n    }\n  });\n  var _e = o(function t(e, n, i, o, a) {\n      r(this, t), this.id = void 0, this.pointer = void 0, this.event = void 0, this.downTime = void 0, this.downTarget = void 0, this.id = e, this.pointer = n, this.event = i, this.downTime = o, this.downTarget = a;\n    }),\n    Pe = function (t) {\n      return t.interactable = \"\", t.element = \"\", t.prepared = \"\", t.pointerIsDown = \"\", t.pointerWasMoved = \"\", t._proxy = \"\", t;\n    }({}),\n    Oe = function (t) {\n      return t.start = \"\", t.move = \"\", t.end = \"\", t.stop = \"\", t.interacting = \"\", t;\n    }({}),\n    ke = 0,\n    De = function () {\n      function t(e) {\n        var n = this,\n          i = e.pointerType,\n          o = e.scopeFire;\n        r(this, t), this.interactable = null, this.element = null, this.rect = null, this._rects = void 0, this.edges = null, this._scopeFire = void 0, this.prepared = {\n          name: null,\n          axis: null,\n          edges: null\n        }, this.pointerType = void 0, this.pointers = [], this.downEvent = null, this.downPointer = {}, this._latestPointer = {\n          pointer: null,\n          event: null,\n          eventTarget: null\n        }, this.prevEvent = null, this.pointerIsDown = !1, this.pointerWasMoved = !1, this._interacting = !1, this._ending = !1, this._stopped = !0, this._proxy = void 0, this.simulation = null, this.doMove = Nt(function (t) {\n          this.move(t);\n        }, \"The interaction.doMove() method has been renamed to interaction.move()\"), this.coords = {\n          start: {\n            page: {\n              x: 0,\n              y: 0\n            },\n            client: {\n              x: 0,\n              y: 0\n            },\n            timeStamp: 0\n          },\n          prev: {\n            page: {\n              x: 0,\n              y: 0\n            },\n            client: {\n              x: 0,\n              y: 0\n            },\n            timeStamp: 0\n          },\n          cur: {\n            page: {\n              x: 0,\n              y: 0\n            },\n            client: {\n              x: 0,\n              y: 0\n            },\n            timeStamp: 0\n          },\n          delta: {\n            page: {\n              x: 0,\n              y: 0\n            },\n            client: {\n              x: 0,\n              y: 0\n            },\n            timeStamp: 0\n          },\n          velocity: {\n            page: {\n              x: 0,\n              y: 0\n            },\n            client: {\n              x: 0,\n              y: 0\n            },\n            timeStamp: 0\n          }\n        }, this._id = ke++, this._scopeFire = o, this.pointerType = i;\n        var a = this;\n        this._proxy = {};\n        var s = function (t) {\n          Object.defineProperty(n._proxy, t, {\n            get: function () {\n              return a[t];\n            }\n          });\n        };\n        for (var c in Pe) s(c);\n        var l = function (t) {\n          Object.defineProperty(n._proxy, t, {\n            value: function () {\n              return a[t].apply(a, arguments);\n            }\n          });\n        };\n        for (var u in Oe) l(u);\n        this._scopeFire(\"interactions:new\", {\n          interaction: this\n        });\n      }\n      return o(t, [{\n        key: \"pointerMoveTolerance\",\n        get: function () {\n          return 1;\n        }\n      }, {\n        key: \"pointerDown\",\n        value: function (t, e, n) {\n          var r = this.updatePointer(t, e, n, !0),\n            i = this.pointers[r];\n          this._scopeFire(\"interactions:down\", {\n            pointer: t,\n            event: e,\n            eventTarget: n,\n            pointerIndex: r,\n            pointerInfo: i,\n            type: \"down\",\n            interaction: this\n          });\n        }\n      }, {\n        key: \"start\",\n        value: function (t, e, n) {\n          return !(this.interacting() || !this.pointerIsDown || this.pointers.length < (\"gesture\" === t.name ? 2 : 1) || !e.options[t.name].enabled) && (Ut(this.prepared, t), this.interactable = e, this.element = n, this.rect = e.getRect(n), this.edges = this.prepared.edges ? V({}, this.prepared.edges) : {\n            left: !0,\n            right: !0,\n            top: !0,\n            bottom: !0\n          }, this._stopped = !1, this._interacting = this._doPhase({\n            interaction: this,\n            event: this.downEvent,\n            phase: \"start\"\n          }) && !this._stopped, this._interacting);\n        }\n      }, {\n        key: \"pointerMove\",\n        value: function (t, e, n) {\n          this.simulation || this.modification && this.modification.endResult || this.updatePointer(t, e, n, !1);\n          var r,\n            i,\n            o = this.coords.cur.page.x === this.coords.prev.page.x && this.coords.cur.page.y === this.coords.prev.page.y && this.coords.cur.client.x === this.coords.prev.client.x && this.coords.cur.client.y === this.coords.prev.client.y;\n          this.pointerIsDown && !this.pointerWasMoved && (r = this.coords.cur.client.x - this.coords.start.client.x, i = this.coords.cur.client.y - this.coords.start.client.y, this.pointerWasMoved = Q(r, i) > this.pointerMoveTolerance);\n          var a,\n            s,\n            c,\n            l = this.getPointerIndex(t),\n            u = {\n              pointer: t,\n              pointerIndex: l,\n              pointerInfo: this.pointers[l],\n              event: e,\n              type: \"move\",\n              eventTarget: n,\n              dx: r,\n              dy: i,\n              duplicate: o,\n              interaction: this\n            };\n          o || (a = this.coords.velocity, s = this.coords.delta, c = Math.max(s.timeStamp / 1e3, .001), a.page.x = s.page.x / c, a.page.y = s.page.y / c, a.client.x = s.client.x / c, a.client.y = s.client.y / c, a.timeStamp = c), this._scopeFire(\"interactions:move\", u), o || this.simulation || (this.interacting() && (u.type = null, this.move(u)), this.pointerWasMoved && et(this.coords.prev, this.coords.cur));\n        }\n      }, {\n        key: \"move\",\n        value: function (t) {\n          t && t.event || nt(this.coords.delta), (t = V({\n            pointer: this._latestPointer.pointer,\n            event: this._latestPointer.event,\n            eventTarget: this._latestPointer.eventTarget,\n            interaction: this\n          }, t || {})).phase = \"move\", this._doPhase(t);\n        }\n      }, {\n        key: \"pointerUp\",\n        value: function (t, e, n, r) {\n          var i = this.getPointerIndex(t);\n          -1 === i && (i = this.updatePointer(t, e, n, !1));\n          var o = /cancel$/i.test(e.type) ? \"cancel\" : \"up\";\n          this._scopeFire(\"interactions:\".concat(o), {\n            pointer: t,\n            pointerIndex: i,\n            pointerInfo: this.pointers[i],\n            event: e,\n            eventTarget: n,\n            type: o,\n            curEventTarget: r,\n            interaction: this\n          }), this.simulation || this.end(e), this.removePointer(t, e);\n        }\n      }, {\n        key: \"documentBlur\",\n        value: function (t) {\n          this.end(t), this._scopeFire(\"interactions:blur\", {\n            event: t,\n            type: \"blur\",\n            interaction: this\n          });\n        }\n      }, {\n        key: \"end\",\n        value: function (t) {\n          var e;\n          this._ending = !0, t = t || this._latestPointer.event, this.interacting() && (e = this._doPhase({\n            event: t,\n            interaction: this,\n            phase: \"end\"\n          })), this._ending = !1, !0 === e && this.stop();\n        }\n      }, {\n        key: \"currentAction\",\n        value: function () {\n          return this._interacting ? this.prepared.name : null;\n        }\n      }, {\n        key: \"interacting\",\n        value: function () {\n          return this._interacting;\n        }\n      }, {\n        key: \"stop\",\n        value: function () {\n          this._scopeFire(\"interactions:stop\", {\n            interaction: this\n          }), this.interactable = this.element = null, this._interacting = !1, this._stopped = !0, this.prepared.name = this.prevEvent = null;\n        }\n      }, {\n        key: \"getPointerIndex\",\n        value: function (t) {\n          var e = at(t);\n          return \"mouse\" === this.pointerType || \"pen\" === this.pointerType ? this.pointers.length - 1 : yt(this.pointers, function (t) {\n            return t.id === e;\n          });\n        }\n      }, {\n        key: \"getPointerInfo\",\n        value: function (t) {\n          return this.pointers[this.getPointerIndex(t)];\n        }\n      }, {\n        key: \"updatePointer\",\n        value: function (t, e, n, r) {\n          var i,\n            o,\n            a,\n            s = at(t),\n            c = this.getPointerIndex(t),\n            l = this.pointers[c];\n          return r = !1 !== r && (r || /(down|start)$/i.test(e.type)), l ? l.pointer = t : (l = new _e(s, t, e, null, null), c = this.pointers.length, this.pointers.push(l)), st(this.coords.cur, this.pointers.map(function (t) {\n            return t.pointer;\n          }), this._now()), i = this.coords.delta, o = this.coords.prev, a = this.coords.cur, i.page.x = a.page.x - o.page.x, i.page.y = a.page.y - o.page.y, i.client.x = a.client.x - o.client.x, i.client.y = a.client.y - o.client.y, i.timeStamp = a.timeStamp - o.timeStamp, r && (this.pointerIsDown = !0, l.downTime = this.coords.cur.timeStamp, l.downTarget = n, tt(this.downPointer, t), this.interacting() || (et(this.coords.start, this.coords.cur), et(this.coords.prev, this.coords.cur), this.downEvent = e, this.pointerWasMoved = !1)), this._updateLatestPointer(t, e, n), this._scopeFire(\"interactions:update-pointer\", {\n            pointer: t,\n            event: e,\n            eventTarget: n,\n            down: r,\n            pointerInfo: l,\n            pointerIndex: c,\n            interaction: this\n          }), c;\n        }\n      }, {\n        key: \"removePointer\",\n        value: function (t, e) {\n          var n = this.getPointerIndex(t);\n          if (-1 !== n) {\n            var r = this.pointers[n];\n            this._scopeFire(\"interactions:remove-pointer\", {\n              pointer: t,\n              event: e,\n              eventTarget: null,\n              pointerIndex: n,\n              pointerInfo: r,\n              interaction: this\n            }), this.pointers.splice(n, 1), this.pointerIsDown = !1;\n          }\n        }\n      }, {\n        key: \"_updateLatestPointer\",\n        value: function (t, e, n) {\n          this._latestPointer.pointer = t, this._latestPointer.event = e, this._latestPointer.eventTarget = n;\n        }\n      }, {\n        key: \"destroy\",\n        value: function () {\n          this._latestPointer.pointer = null, this._latestPointer.event = null, this._latestPointer.eventTarget = null;\n        }\n      }, {\n        key: \"_createPreparedEvent\",\n        value: function (t, e, n, r) {\n          return new Se(this, t, this.prepared.name, e, this.element, n, r);\n        }\n      }, {\n        key: \"_fireEvent\",\n        value: function (t) {\n          var e;\n          null == (e = this.interactable) || e.fire(t), (!this.prevEvent || t.timeStamp >= this.prevEvent.timeStamp) && (this.prevEvent = t);\n        }\n      }, {\n        key: \"_doPhase\",\n        value: function (t) {\n          var e = t.event,\n            n = t.phase,\n            r = t.preEnd,\n            i = t.type,\n            o = this.rect;\n          if (o && \"move\" === n && (H(this.edges, o, this.coords.delta[this.interactable.options.deltaSource]), o.width = o.right - o.left, o.height = o.bottom - o.top), !1 === this._scopeFire(\"interactions:before-action-\".concat(n), t)) return !1;\n          var a = t.iEvent = this._createPreparedEvent(e, n, r, i);\n          return this._scopeFire(\"interactions:action-\".concat(n), t), \"start\" === n && (this.prevEvent = a), this._fireEvent(a), this._scopeFire(\"interactions:after-action-\".concat(n), t), !0;\n        }\n      }, {\n        key: \"_now\",\n        value: function () {\n          return Date.now();\n        }\n      }]), t;\n    }();\n  function Ie(t) {\n    Me(t.interaction);\n  }\n  function Me(t) {\n    if (!function (t) {\n      return !(!t.offset.pending.x && !t.offset.pending.y);\n    }(t)) return !1;\n    var e = t.offset.pending;\n    return Ae(t.coords.cur, e), Ae(t.coords.delta, e), H(t.edges, t.rect, e), e.x = 0, e.y = 0, !0;\n  }\n  function ze(t) {\n    var e = t.x,\n      n = t.y;\n    this.offset.pending.x += e, this.offset.pending.y += n, this.offset.total.x += e, this.offset.total.y += n;\n  }\n  function Ae(t, e) {\n    var n = t.page,\n      r = t.client,\n      i = e.x,\n      o = e.y;\n    n.x += i, n.y += o, r.x += i, r.y += o;\n  }\n  Oe.offsetBy = \"\";\n  var Re = {\n      id: \"offset\",\n      before: [\"modifiers\", \"pointer-events\", \"actions\", \"inertia\"],\n      install: function (t) {\n        t.Interaction.prototype.offsetBy = ze;\n      },\n      listeners: {\n        \"interactions:new\": function (t) {\n          t.interaction.offset = {\n            total: {\n              x: 0,\n              y: 0\n            },\n            pending: {\n              x: 0,\n              y: 0\n            }\n          };\n        },\n        \"interactions:update-pointer\": function (t) {\n          return function (t) {\n            t.pointerIsDown && (Ae(t.coords.cur, t.offset.total), t.offset.pending.x = 0, t.offset.pending.y = 0);\n          }(t.interaction);\n        },\n        \"interactions:before-action-start\": Ie,\n        \"interactions:before-action-move\": Ie,\n        \"interactions:before-action-end\": function (t) {\n          var e = t.interaction;\n          if (Me(e)) return e.move({\n            offset: !0\n          }), e.end(), !1;\n        },\n        \"interactions:stop\": function (t) {\n          var e = t.interaction;\n          e.offset.total.x = 0, e.offset.total.y = 0, e.offset.pending.x = 0, e.offset.pending.y = 0;\n        }\n      }\n    },\n    Ce = Re;\n  var je = function () {\n    function t(e) {\n      r(this, t), this.active = !1, this.isModified = !1, this.smoothEnd = !1, this.allowResume = !1, this.modification = void 0, this.modifierCount = 0, this.modifierArg = void 0, this.startCoords = void 0, this.t0 = 0, this.v0 = 0, this.te = 0, this.targetOffset = void 0, this.modifiedOffset = void 0, this.currentOffset = void 0, this.lambda_v0 = 0, this.one_ve_v0 = 0, this.timeout = void 0, this.interaction = void 0, this.interaction = e;\n    }\n    return o(t, [{\n      key: \"start\",\n      value: function (t) {\n        var e = this.interaction,\n          n = Fe(e);\n        if (!n || !n.enabled) return !1;\n        var r = e.coords.velocity.client,\n          i = Q(r.x, r.y),\n          o = this.modification || (this.modification = new me(e));\n        if (o.copyFrom(e.modification), this.t0 = e._now(), this.allowResume = n.allowResume, this.v0 = i, this.currentOffset = {\n          x: 0,\n          y: 0\n        }, this.startCoords = e.coords.cur.page, this.modifierArg = o.fillArg({\n          pageCoords: this.startCoords,\n          preEnd: !0,\n          phase: \"inertiastart\"\n        }), this.t0 - e.coords.cur.timeStamp < 50 && i > n.minSpeed && i > n.endSpeed) this.startInertia();else {\n          if (o.result = o.setAll(this.modifierArg), !o.result.changed) return !1;\n          this.startSmoothEnd();\n        }\n        return e.modification.result.rect = null, e.offsetBy(this.targetOffset), e._doPhase({\n          interaction: e,\n          event: t,\n          phase: \"inertiastart\"\n        }), e.offsetBy({\n          x: -this.targetOffset.x,\n          y: -this.targetOffset.y\n        }), e.modification.result.rect = null, this.active = !0, e.simulation = this, !0;\n      }\n    }, {\n      key: \"startInertia\",\n      value: function () {\n        var t = this,\n          e = this.interaction.coords.velocity.client,\n          n = Fe(this.interaction),\n          r = n.resistance,\n          i = -Math.log(n.endSpeed / this.v0) / r;\n        this.targetOffset = {\n          x: (e.x - i) / r,\n          y: (e.y - i) / r\n        }, this.te = i, this.lambda_v0 = r / this.v0, this.one_ve_v0 = 1 - n.endSpeed / this.v0;\n        var o = this.modification,\n          a = this.modifierArg;\n        a.pageCoords = {\n          x: this.startCoords.x + this.targetOffset.x,\n          y: this.startCoords.y + this.targetOffset.y\n        }, o.result = o.setAll(a), o.result.changed && (this.isModified = !0, this.modifiedOffset = {\n          x: this.targetOffset.x + o.result.delta.x,\n          y: this.targetOffset.y + o.result.delta.y\n        }), this.onNextFrame(function () {\n          return t.inertiaTick();\n        });\n      }\n    }, {\n      key: \"startSmoothEnd\",\n      value: function () {\n        var t = this;\n        this.smoothEnd = !0, this.isModified = !0, this.targetOffset = {\n          x: this.modification.result.delta.x,\n          y: this.modification.result.delta.y\n        }, this.onNextFrame(function () {\n          return t.smoothEndTick();\n        });\n      }\n    }, {\n      key: \"onNextFrame\",\n      value: function (t) {\n        var e = this;\n        this.timeout = Lt.request(function () {\n          e.active && t();\n        });\n      }\n    }, {\n      key: \"inertiaTick\",\n      value: function () {\n        var t,\n          e,\n          n,\n          r,\n          i,\n          o,\n          a,\n          s = this,\n          c = this.interaction,\n          l = Fe(c).resistance,\n          u = (c._now() - this.t0) / 1e3;\n        if (u < this.te) {\n          var p,\n            f = 1 - (Math.exp(-l * u) - this.lambda_v0) / this.one_ve_v0;\n          this.isModified ? (t = 0, e = 0, n = this.targetOffset.x, r = this.targetOffset.y, i = this.modifiedOffset.x, o = this.modifiedOffset.y, p = {\n            x: Ye(a = f, t, n, i),\n            y: Ye(a, e, r, o)\n          }) : p = {\n            x: this.targetOffset.x * f,\n            y: this.targetOffset.y * f\n          };\n          var d = {\n            x: p.x - this.currentOffset.x,\n            y: p.y - this.currentOffset.y\n          };\n          this.currentOffset.x += d.x, this.currentOffset.y += d.y, c.offsetBy(d), c.move(), this.onNextFrame(function () {\n            return s.inertiaTick();\n          });\n        } else c.offsetBy({\n          x: this.modifiedOffset.x - this.currentOffset.x,\n          y: this.modifiedOffset.y - this.currentOffset.y\n        }), this.end();\n      }\n    }, {\n      key: \"smoothEndTick\",\n      value: function () {\n        var t = this,\n          e = this.interaction,\n          n = e._now() - this.t0,\n          r = Fe(e).smoothEndDuration;\n        if (n < r) {\n          var i = {\n              x: Le(n, 0, this.targetOffset.x, r),\n              y: Le(n, 0, this.targetOffset.y, r)\n            },\n            o = {\n              x: i.x - this.currentOffset.x,\n              y: i.y - this.currentOffset.y\n            };\n          this.currentOffset.x += o.x, this.currentOffset.y += o.y, e.offsetBy(o), e.move({\n            skipModifiers: this.modifierCount\n          }), this.onNextFrame(function () {\n            return t.smoothEndTick();\n          });\n        } else e.offsetBy({\n          x: this.targetOffset.x - this.currentOffset.x,\n          y: this.targetOffset.y - this.currentOffset.y\n        }), this.end();\n      }\n    }, {\n      key: \"resume\",\n      value: function (t) {\n        var e = t.pointer,\n          n = t.event,\n          r = t.eventTarget,\n          i = this.interaction;\n        i.offsetBy({\n          x: -this.currentOffset.x,\n          y: -this.currentOffset.y\n        }), i.updatePointer(e, n, r, !0), i._doPhase({\n          interaction: i,\n          event: n,\n          phase: \"resume\"\n        }), et(i.coords.prev, i.coords.cur), this.stop();\n      }\n    }, {\n      key: \"end\",\n      value: function () {\n        this.interaction.move(), this.interaction.end(), this.stop();\n      }\n    }, {\n      key: \"stop\",\n      value: function () {\n        this.active = this.smoothEnd = !1, this.interaction.simulation = null, Lt.cancel(this.timeout);\n      }\n    }]), t;\n  }();\n  function Fe(t) {\n    var e = t.interactable,\n      n = t.prepared;\n    return e && e.options && n.name && e.options[n.name].inertia;\n  }\n  var Xe = {\n    id: \"inertia\",\n    before: [\"modifiers\", \"actions\"],\n    install: function (t) {\n      var e = t.defaults;\n      t.usePlugin(Ce), t.usePlugin(Ee), t.actions.phases.inertiastart = !0, t.actions.phases.resume = !0, e.perAction.inertia = {\n        enabled: !1,\n        resistance: 10,\n        minSpeed: 100,\n        endSpeed: 10,\n        allowResume: !0,\n        smoothEndDuration: 300\n      };\n    },\n    listeners: {\n      \"interactions:new\": function (t) {\n        var e = t.interaction;\n        e.inertia = new je(e);\n      },\n      \"interactions:before-action-end\": function (t) {\n        var e = t.interaction,\n          n = t.event;\n        return (!e._interacting || e.simulation || !e.inertia.start(n)) && null;\n      },\n      \"interactions:down\": function (t) {\n        var e = t.interaction,\n          n = t.eventTarget,\n          r = e.inertia;\n        if (r.active) for (var i = n; w.element(i);) {\n          if (i === e.element) {\n            r.resume(t);\n            break;\n          }\n          i = A(i);\n        }\n      },\n      \"interactions:stop\": function (t) {\n        var e = t.interaction.inertia;\n        e.active && e.stop();\n      },\n      \"interactions:before-action-resume\": function (t) {\n        var e = t.interaction.modification;\n        e.stop(t), e.start(t, t.interaction.coords.cur.page), e.applyToInteraction(t);\n      },\n      \"interactions:before-action-inertiastart\": function (t) {\n        return t.interaction.modification.setAndApply(t);\n      },\n      \"interactions:action-resume\": xe,\n      \"interactions:action-inertiastart\": xe,\n      \"interactions:after-action-inertiastart\": function (t) {\n        return t.interaction.modification.restoreInteractionCoords(t);\n      },\n      \"interactions:after-action-resume\": function (t) {\n        return t.interaction.modification.restoreInteractionCoords(t);\n      }\n    }\n  };\n  function Ye(t, e, n, r) {\n    var i = 1 - t;\n    return i * i * e + 2 * i * t * n + t * t * r;\n  }\n  function Le(t, e, n, r) {\n    return -n * (t /= r) * (t - 2) + e;\n  }\n  var qe = Xe;\n  function Be(t, e) {\n    for (var n = 0; n < e.length; n++) {\n      var r = e[n];\n      if (t.immediatePropagationStopped) break;\n      r(t);\n    }\n  }\n  var Ve = function () {\n    function t(e) {\n      r(this, t), this.options = void 0, this.types = {}, this.propagationStopped = !1, this.immediatePropagationStopped = !1, this.global = void 0, this.options = V({}, e || {});\n    }\n    return o(t, [{\n      key: \"fire\",\n      value: function (t) {\n        var e,\n          n = this.global;\n        (e = this.types[t.type]) && Be(t, e), !t.propagationStopped && n && (e = n[t.type]) && Be(t, e);\n      }\n    }, {\n      key: \"on\",\n      value: function (t, e) {\n        var n = $(t, e);\n        for (t in n) this.types[t] = gt(this.types[t] || [], n[t]);\n      }\n    }, {\n      key: \"off\",\n      value: function (t, e) {\n        var n = $(t, e);\n        for (t in n) {\n          var r = this.types[t];\n          if (r && r.length) for (var i = 0, o = n[t]; i < o.length; i++) {\n            var a = o[i],\n              s = r.indexOf(a);\n            -1 !== s && r.splice(s, 1);\n          }\n        }\n      }\n    }, {\n      key: \"getRect\",\n      value: function (t) {\n        return null;\n      }\n    }]), t;\n  }();\n  var We = function () {\n    function t(e) {\n      r(this, t), this.currentTarget = void 0, this.originalEvent = void 0, this.type = void 0, this.originalEvent = e, tt(this, e);\n    }\n    return o(t, [{\n      key: \"preventOriginalDefault\",\n      value: function () {\n        this.originalEvent.preventDefault();\n      }\n    }, {\n      key: \"stopPropagation\",\n      value: function () {\n        this.originalEvent.stopPropagation();\n      }\n    }, {\n      key: \"stopImmediatePropagation\",\n      value: function () {\n        this.originalEvent.stopImmediatePropagation();\n      }\n    }]), t;\n  }();\n  function Ge(t) {\n    return w.object(t) ? {\n      capture: !!t.capture,\n      passive: !!t.passive\n    } : {\n      capture: !!t,\n      passive: !1\n    };\n  }\n  function Ne(t, e) {\n    return t === e || (\"boolean\" == typeof t ? !!e.capture === t && !1 == !!e.passive : !!t.capture == !!e.capture && !!t.passive == !!e.passive);\n  }\n  var Ue = {\n      id: \"events\",\n      install: function (t) {\n        var e,\n          n = [],\n          r = {},\n          i = [],\n          o = {\n            add: a,\n            remove: s,\n            addDelegate: function (t, e, n, o, s) {\n              var u = Ge(s);\n              if (!r[n]) {\n                r[n] = [];\n                for (var p = 0; p < i.length; p++) {\n                  var f = i[p];\n                  a(f, n, c), a(f, n, l, !0);\n                }\n              }\n              var d = r[n],\n                h = bt(d, function (n) {\n                  return n.selector === t && n.context === e;\n                });\n              h || (h = {\n                selector: t,\n                context: e,\n                listeners: []\n              }, d.push(h));\n              h.listeners.push({\n                func: o,\n                options: u\n              });\n            },\n            removeDelegate: function (t, e, n, i, o) {\n              var a,\n                u = Ge(o),\n                p = r[n],\n                f = !1;\n              if (!p) return;\n              for (a = p.length - 1; a >= 0; a--) {\n                var d = p[a];\n                if (d.selector === t && d.context === e) {\n                  for (var h = d.listeners, v = h.length - 1; v >= 0; v--) {\n                    var g = h[v];\n                    if (g.func === i && Ne(g.options, u)) {\n                      h.splice(v, 1), h.length || (p.splice(a, 1), s(e, n, c), s(e, n, l, !0)), f = !0;\n                      break;\n                    }\n                  }\n                  if (f) break;\n                }\n              }\n            },\n            delegateListener: c,\n            delegateUseCapture: l,\n            delegatedEvents: r,\n            documents: i,\n            targets: n,\n            supportsOptions: !1,\n            supportsPassive: !1\n          };\n        function a(t, e, r, i) {\n          if (t.addEventListener) {\n            var a = Ge(i),\n              s = bt(n, function (e) {\n                return e.eventTarget === t;\n              });\n            s || (s = {\n              eventTarget: t,\n              events: {}\n            }, n.push(s)), s.events[e] || (s.events[e] = []), bt(s.events[e], function (t) {\n              return t.func === r && Ne(t.options, a);\n            }) || (t.addEventListener(e, r, o.supportsOptions ? a : a.capture), s.events[e].push({\n              func: r,\n              options: a\n            }));\n          }\n        }\n        function s(t, e, r, i) {\n          if (t.addEventListener && t.removeEventListener) {\n            var a = yt(n, function (e) {\n                return e.eventTarget === t;\n              }),\n              c = n[a];\n            if (c && c.events) if (\"all\" !== e) {\n              var l = !1,\n                u = c.events[e];\n              if (u) {\n                if (\"all\" === r) {\n                  for (var p = u.length - 1; p >= 0; p--) {\n                    var f = u[p];\n                    s(t, e, f.func, f.options);\n                  }\n                  return;\n                }\n                for (var d = Ge(i), h = 0; h < u.length; h++) {\n                  var v = u[h];\n                  if (v.func === r && Ne(v.options, d)) {\n                    t.removeEventListener(e, r, o.supportsOptions ? d : d.capture), u.splice(h, 1), 0 === u.length && (delete c.events[e], l = !0);\n                    break;\n                  }\n                }\n              }\n              l && !Object.keys(c.events).length && n.splice(a, 1);\n            } else for (e in c.events) c.events.hasOwnProperty(e) && s(t, e, \"all\");\n          }\n        }\n        function c(t, e) {\n          for (var n = Ge(e), i = new We(t), o = r[t.type], a = ht(t)[0], s = a; w.element(s);) {\n            for (var c = 0; c < o.length; c++) {\n              var l = o[c],\n                u = l.selector,\n                p = l.context;\n              if (R(s, u) && M(p, a) && M(p, s)) {\n                var f = l.listeners;\n                i.currentTarget = s;\n                for (var d = 0; d < f.length; d++) {\n                  var h = f[d];\n                  Ne(h.options, n) && h.func(i);\n                }\n              }\n            }\n            s = A(s);\n          }\n        }\n        function l(t) {\n          return c(t, !0);\n        }\n        return null == (e = t.document) || e.createElement(\"div\").addEventListener(\"test\", null, {\n          get capture() {\n            return o.supportsOptions = !0;\n          },\n          get passive() {\n            return o.supportsPassive = !0;\n          }\n        }), t.events = o, o;\n      }\n    },\n    He = {\n      methodOrder: [\"simulationResume\", \"mouseOrPen\", \"hasPointer\", \"idle\"],\n      search: function (t) {\n        for (var e = 0, n = He.methodOrder; e < n.length; e++) {\n          var r = n[e],\n            i = He[r](t);\n          if (i) return i;\n        }\n        return null;\n      },\n      simulationResume: function (t) {\n        var e = t.pointerType,\n          n = t.eventType,\n          r = t.eventTarget,\n          i = t.scope;\n        if (!/down|start/i.test(n)) return null;\n        for (var o = 0, a = i.interactions.list; o < a.length; o++) {\n          var s = a[o],\n            c = r;\n          if (s.simulation && s.simulation.allowResume && s.pointerType === e) for (; c;) {\n            if (c === s.element) return s;\n            c = A(c);\n          }\n        }\n        return null;\n      },\n      mouseOrPen: function (t) {\n        var e,\n          n = t.pointerId,\n          r = t.pointerType,\n          i = t.eventType,\n          o = t.scope;\n        if (\"mouse\" !== r && \"pen\" !== r) return null;\n        for (var a = 0, s = o.interactions.list; a < s.length; a++) {\n          var c = s[a];\n          if (c.pointerType === r) {\n            if (c.simulation && !Ke(c, n)) continue;\n            if (c.interacting()) return c;\n            e || (e = c);\n          }\n        }\n        if (e) return e;\n        for (var l = 0, u = o.interactions.list; l < u.length; l++) {\n          var p = u[l];\n          if (!(p.pointerType !== r || /down/i.test(i) && p.simulation)) return p;\n        }\n        return null;\n      },\n      hasPointer: function (t) {\n        for (var e = t.pointerId, n = 0, r = t.scope.interactions.list; n < r.length; n++) {\n          var i = r[n];\n          if (Ke(i, e)) return i;\n        }\n        return null;\n      },\n      idle: function (t) {\n        for (var e = t.pointerType, n = 0, r = t.scope.interactions.list; n < r.length; n++) {\n          var i = r[n];\n          if (1 === i.pointers.length) {\n            var o = i.interactable;\n            if (o && (!o.options.gesture || !o.options.gesture.enabled)) continue;\n          } else if (i.pointers.length >= 2) continue;\n          if (!i.interacting() && e === i.pointerType) return i;\n        }\n        return null;\n      }\n    };\n  function Ke(t, e) {\n    return t.pointers.some(function (t) {\n      return t.id === e;\n    });\n  }\n  var $e = He,\n    Je = [\"pointerDown\", \"pointerMove\", \"pointerUp\", \"updatePointer\", \"removePointer\", \"windowBlur\"];\n  function Qe(t, e) {\n    return function (n) {\n      var r = e.interactions.list,\n        i = dt(n),\n        o = ht(n),\n        a = o[0],\n        s = o[1],\n        c = [];\n      if (/^touch/.test(n.type)) {\n        e.prevTouchTime = e.now();\n        for (var l = 0, u = n.changedTouches; l < u.length; l++) {\n          var p = u[l],\n            f = {\n              pointer: p,\n              pointerId: at(p),\n              pointerType: i,\n              eventType: n.type,\n              eventTarget: a,\n              curEventTarget: s,\n              scope: e\n            },\n            d = Ze(f);\n          c.push([f.pointer, f.eventTarget, f.curEventTarget, d]);\n        }\n      } else {\n        var h = !1;\n        if (!I.supportsPointerEvent && /mouse/.test(n.type)) {\n          for (var v = 0; v < r.length && !h; v++) h = \"mouse\" !== r[v].pointerType && r[v].pointerIsDown;\n          h = h || e.now() - e.prevTouchTime < 500 || 0 === n.timeStamp;\n        }\n        if (!h) {\n          var g = {\n              pointer: n,\n              pointerId: at(n),\n              pointerType: i,\n              eventType: n.type,\n              curEventTarget: s,\n              eventTarget: a,\n              scope: e\n            },\n            m = Ze(g);\n          c.push([g.pointer, g.eventTarget, g.curEventTarget, m]);\n        }\n      }\n      for (var y = 0; y < c.length; y++) {\n        var b = c[y],\n          x = b[0],\n          w = b[1],\n          E = b[2];\n        b[3][t](x, n, w, E);\n      }\n    };\n  }\n  function Ze(t) {\n    var e = t.pointerType,\n      n = t.scope,\n      r = {\n        interaction: $e.search(t),\n        searchDetails: t\n      };\n    return n.fire(\"interactions:find\", r), r.interaction || n.interactions.new({\n      pointerType: e\n    });\n  }\n  function tn(t, e) {\n    var n = t.doc,\n      r = t.scope,\n      i = t.options,\n      o = r.interactions.docEvents,\n      a = r.events,\n      s = a[e];\n    for (var c in r.browser.isIOS && !i.events && (i.events = {\n      passive: !1\n    }), a.delegatedEvents) s(n, c, a.delegateListener), s(n, c, a.delegateUseCapture, !0);\n    for (var l = i && i.events, u = 0; u < o.length; u++) {\n      var p = o[u];\n      s(n, p.type, p.listener, l);\n    }\n  }\n  var en = {\n      id: \"core/interactions\",\n      install: function (t) {\n        for (var e = {}, n = 0; n < Je.length; n++) {\n          var i = Je[n];\n          e[i] = Qe(i, t);\n        }\n        var a,\n          c = I.pEventTypes;\n        function l() {\n          for (var e = 0, n = t.interactions.list; e < n.length; e++) {\n            var r = n[e];\n            if (r.pointerIsDown && \"touch\" === r.pointerType && !r._interacting) for (var i = function () {\n                var e = a[o];\n                t.documents.some(function (t) {\n                  return M(t.doc, e.downTarget);\n                }) || r.removePointer(e.pointer, e.event);\n              }, o = 0, a = r.pointers; o < a.length; o++) i();\n          }\n        }\n        (a = k.PointerEvent ? [{\n          type: c.down,\n          listener: l\n        }, {\n          type: c.down,\n          listener: e.pointerDown\n        }, {\n          type: c.move,\n          listener: e.pointerMove\n        }, {\n          type: c.up,\n          listener: e.pointerUp\n        }, {\n          type: c.cancel,\n          listener: e.pointerUp\n        }] : [{\n          type: \"mousedown\",\n          listener: e.pointerDown\n        }, {\n          type: \"mousemove\",\n          listener: e.pointerMove\n        }, {\n          type: \"mouseup\",\n          listener: e.pointerUp\n        }, {\n          type: \"touchstart\",\n          listener: l\n        }, {\n          type: \"touchstart\",\n          listener: e.pointerDown\n        }, {\n          type: \"touchmove\",\n          listener: e.pointerMove\n        }, {\n          type: \"touchend\",\n          listener: e.pointerUp\n        }, {\n          type: \"touchcancel\",\n          listener: e.pointerUp\n        }]).push({\n          type: \"blur\",\n          listener: function (e) {\n            for (var n = 0, r = t.interactions.list; n < r.length; n++) {\n              r[n].documentBlur(e);\n            }\n          }\n        }), t.prevTouchTime = 0, t.Interaction = function (e) {\n          s(i, e);\n          var n = p(i);\n          function i() {\n            return r(this, i), n.apply(this, arguments);\n          }\n          return o(i, [{\n            key: \"pointerMoveTolerance\",\n            get: function () {\n              return t.interactions.pointerMoveTolerance;\n            },\n            set: function (e) {\n              t.interactions.pointerMoveTolerance = e;\n            }\n          }, {\n            key: \"_now\",\n            value: function () {\n              return t.now();\n            }\n          }]), i;\n        }(De), t.interactions = {\n          list: [],\n          new: function (e) {\n            e.scopeFire = function (e, n) {\n              return t.fire(e, n);\n            };\n            var n = new t.Interaction(e);\n            return t.interactions.list.push(n), n;\n          },\n          listeners: e,\n          docEvents: a,\n          pointerMoveTolerance: 1\n        }, t.usePlugin(he);\n      },\n      listeners: {\n        \"scope:add-document\": function (t) {\n          return tn(t, \"add\");\n        },\n        \"scope:remove-document\": function (t) {\n          return tn(t, \"remove\");\n        },\n        \"interactable:unset\": function (t, e) {\n          for (var n = t.interactable, r = e.interactions.list.length - 1; r >= 0; r--) {\n            var i = e.interactions.list[r];\n            i.interactable === n && (i.stop(), e.fire(\"interactions:destroy\", {\n              interaction: i\n            }), i.destroy(), e.interactions.list.length > 2 && e.interactions.list.splice(r, 1));\n          }\n        }\n      },\n      onDocSignal: tn,\n      doOnInteractions: Qe,\n      methodNames: Je\n    },\n    nn = en,\n    rn = function (t) {\n      return t[t.On = 0] = \"On\", t[t.Off = 1] = \"Off\", t;\n    }(rn || {}),\n    on = function () {\n      function t(e, n, i, o) {\n        r(this, t), this.target = void 0, this.options = void 0, this._actions = void 0, this.events = new Ve(), this._context = void 0, this._win = void 0, this._doc = void 0, this._scopeEvents = void 0, this._actions = n.actions, this.target = e, this._context = n.context || i, this._win = y(B(e) ? this._context : e), this._doc = this._win.document, this._scopeEvents = o, this.set(n);\n      }\n      return o(t, [{\n        key: \"_defaults\",\n        get: function () {\n          return {\n            base: {},\n            perAction: {},\n            actions: {}\n          };\n        }\n      }, {\n        key: \"setOnEvents\",\n        value: function (t, e) {\n          return w.func(e.onstart) && this.on(\"\".concat(t, \"start\"), e.onstart), w.func(e.onmove) && this.on(\"\".concat(t, \"move\"), e.onmove), w.func(e.onend) && this.on(\"\".concat(t, \"end\"), e.onend), w.func(e.oninertiastart) && this.on(\"\".concat(t, \"inertiastart\"), e.oninertiastart), this;\n        }\n      }, {\n        key: \"updatePerActionListeners\",\n        value: function (t, e, n) {\n          var r,\n            i = this,\n            o = null == (r = this._actions.map[t]) ? void 0 : r.filterEventType,\n            a = function (t) {\n              return (null == o || o(t)) && ve(t, i._actions);\n            };\n          (w.array(e) || w.object(e)) && this._onOff(rn.Off, t, e, void 0, a), (w.array(n) || w.object(n)) && this._onOff(rn.On, t, n, void 0, a);\n        }\n      }, {\n        key: \"setPerAction\",\n        value: function (t, e) {\n          var n = this._defaults;\n          for (var r in e) {\n            var i = r,\n              o = this.options[t],\n              a = e[i];\n            \"listeners\" === i && this.updatePerActionListeners(t, o.listeners, a), w.array(a) ? o[i] = mt(a) : w.plainObject(a) ? (o[i] = V(o[i] || {}, ge(a)), w.object(n.perAction[i]) && \"enabled\" in n.perAction[i] && (o[i].enabled = !1 !== a.enabled)) : w.bool(a) && w.object(n.perAction[i]) ? o[i].enabled = a : o[i] = a;\n          }\n        }\n      }, {\n        key: \"getRect\",\n        value: function (t) {\n          return t = t || (w.element(this.target) ? this.target : null), w.string(this.target) && (t = t || this._context.querySelector(this.target)), L(t);\n        }\n      }, {\n        key: \"rectChecker\",\n        value: function (t) {\n          var e = this;\n          return w.func(t) ? (this.getRect = function (n) {\n            var r = V({}, t.apply(e, n));\n            return \"width\" in r || (r.width = r.right - r.left, r.height = r.bottom - r.top), r;\n          }, this) : null === t ? (delete this.getRect, this) : this.getRect;\n        }\n      }, {\n        key: \"_backCompatOption\",\n        value: function (t, e) {\n          if (B(e) || w.object(e)) {\n            for (var n in this.options[t] = e, this._actions.map) this.options[n][t] = e;\n            return this;\n          }\n          return this.options[t];\n        }\n      }, {\n        key: \"origin\",\n        value: function (t) {\n          return this._backCompatOption(\"origin\", t);\n        }\n      }, {\n        key: \"deltaSource\",\n        value: function (t) {\n          return \"page\" === t || \"client\" === t ? (this.options.deltaSource = t, this) : this.options.deltaSource;\n        }\n      }, {\n        key: \"getAllElements\",\n        value: function () {\n          var t = this.target;\n          return w.string(t) ? Array.from(this._context.querySelectorAll(t)) : w.func(t) && t.getAllElements ? t.getAllElements() : w.element(t) ? [t] : [];\n        }\n      }, {\n        key: \"context\",\n        value: function () {\n          return this._context;\n        }\n      }, {\n        key: \"inContext\",\n        value: function (t) {\n          return this._context === t.ownerDocument || M(this._context, t);\n        }\n      }, {\n        key: \"testIgnoreAllow\",\n        value: function (t, e, n) {\n          return !this.testIgnore(t.ignoreFrom, e, n) && this.testAllow(t.allowFrom, e, n);\n        }\n      }, {\n        key: \"testAllow\",\n        value: function (t, e, n) {\n          return !t || !!w.element(n) && (w.string(t) ? F(n, t, e) : !!w.element(t) && M(t, n));\n        }\n      }, {\n        key: \"testIgnore\",\n        value: function (t, e, n) {\n          return !(!t || !w.element(n)) && (w.string(t) ? F(n, t, e) : !!w.element(t) && M(t, n));\n        }\n      }, {\n        key: \"fire\",\n        value: function (t) {\n          return this.events.fire(t), this;\n        }\n      }, {\n        key: \"_onOff\",\n        value: function (t, e, n, r, i) {\n          w.object(e) && !w.array(e) && (r = n, n = null);\n          var o = $(e, n, i);\n          for (var a in o) {\n            \"wheel\" === a && (a = I.wheelEvent);\n            for (var s = 0, c = o[a]; s < c.length; s++) {\n              var l = c[s];\n              ve(a, this._actions) ? this.events[t === rn.On ? \"on\" : \"off\"](a, l) : w.string(this.target) ? this._scopeEvents[t === rn.On ? \"addDelegate\" : \"removeDelegate\"](this.target, this._context, a, l, r) : this._scopeEvents[t === rn.On ? \"add\" : \"remove\"](this.target, a, l, r);\n            }\n          }\n          return this;\n        }\n      }, {\n        key: \"on\",\n        value: function (t, e, n) {\n          return this._onOff(rn.On, t, e, n);\n        }\n      }, {\n        key: \"off\",\n        value: function (t, e, n) {\n          return this._onOff(rn.Off, t, e, n);\n        }\n      }, {\n        key: \"set\",\n        value: function (t) {\n          var e = this._defaults;\n          for (var n in w.object(t) || (t = {}), this.options = ge(e.base), this._actions.methodDict) {\n            var r = n,\n              i = this._actions.methodDict[r];\n            this.options[r] = {}, this.setPerAction(r, V(V({}, e.perAction), e.actions[r])), this[i](t[r]);\n          }\n          for (var o in t) \"getRect\" !== o ? w.func(this[o]) && this[o](t[o]) : this.rectChecker(t.getRect);\n          return this;\n        }\n      }, {\n        key: \"unset\",\n        value: function () {\n          if (w.string(this.target)) for (var t in this._scopeEvents.delegatedEvents) for (var e = this._scopeEvents.delegatedEvents[t], n = e.length - 1; n >= 0; n--) {\n            var r = e[n],\n              i = r.selector,\n              o = r.context,\n              a = r.listeners;\n            i === this.target && o === this._context && e.splice(n, 1);\n            for (var s = a.length - 1; s >= 0; s--) this._scopeEvents.removeDelegate(this.target, this._context, t, a[s][0], a[s][1]);\n          } else this._scopeEvents.remove(this.target, \"all\");\n        }\n      }]), t;\n    }(),\n    an = function () {\n      function t(e) {\n        var n = this;\n        r(this, t), this.list = [], this.selectorMap = {}, this.scope = void 0, this.scope = e, e.addListeners({\n          \"interactable:unset\": function (t) {\n            var e = t.interactable,\n              r = e.target,\n              i = w.string(r) ? n.selectorMap[r] : r[n.scope.id],\n              o = yt(i, function (t) {\n                return t === e;\n              });\n            i.splice(o, 1);\n          }\n        });\n      }\n      return o(t, [{\n        key: \"new\",\n        value: function (t, e) {\n          e = V(e || {}, {\n            actions: this.scope.actions\n          });\n          var n = new this.scope.Interactable(t, e, this.scope.document, this.scope.events);\n          return this.scope.addDocument(n._doc), this.list.push(n), w.string(t) ? (this.selectorMap[t] || (this.selectorMap[t] = []), this.selectorMap[t].push(n)) : (n.target[this.scope.id] || Object.defineProperty(t, this.scope.id, {\n            value: [],\n            configurable: !0\n          }), t[this.scope.id].push(n)), this.scope.fire(\"interactable:new\", {\n            target: t,\n            options: e,\n            interactable: n,\n            win: this.scope._win\n          }), n;\n        }\n      }, {\n        key: \"getExisting\",\n        value: function (t, e) {\n          var n = e && e.context || this.scope.document,\n            r = w.string(t),\n            i = r ? this.selectorMap[t] : t[this.scope.id];\n          if (i) return bt(i, function (e) {\n            return e._context === n && (r || e.inContext(t));\n          });\n        }\n      }, {\n        key: \"forEachMatch\",\n        value: function (t, e) {\n          for (var n = 0, r = this.list; n < r.length; n++) {\n            var i = r[n],\n              o = void 0;\n            if ((w.string(i.target) ? w.element(t) && R(t, i.target) : t === i.target) && i.inContext(t) && (o = e(i)), void 0 !== o) return o;\n          }\n        }\n      }]), t;\n    }();\n  var sn = function () {\n    function t() {\n      var e = this;\n      r(this, t), this.id = \"__interact_scope_\".concat(Math.floor(100 * Math.random())), this.isInitialized = !1, this.listenerMaps = [], this.browser = I, this.defaults = ge(Te), this.Eventable = Ve, this.actions = {\n        map: {},\n        phases: {\n          start: !0,\n          move: !0,\n          end: !0\n        },\n        methodDict: {},\n        phaselessTypes: {}\n      }, this.interactStatic = function (t) {\n        var e = function e(n, r) {\n          var i = t.interactables.getExisting(n, r);\n          return i || ((i = t.interactables.new(n, r)).events.global = e.globalEvents), i;\n        };\n        return e.getPointerAverage = lt, e.getTouchBBox = ut, e.getTouchDistance = pt, e.getTouchAngle = ft, e.getElementRect = L, e.getElementClientRect = Y, e.matchesSelector = R, e.closest = z, e.globalEvents = {}, e.version = \"1.10.27\", e.scope = t, e.use = function (t, e) {\n          return this.scope.usePlugin(t, e), this;\n        }, e.isSet = function (t, e) {\n          return !!this.scope.interactables.get(t, e && e.context);\n        }, e.on = Nt(function (t, e, n) {\n          if (w.string(t) && -1 !== t.search(\" \") && (t = t.trim().split(/ +/)), w.array(t)) {\n            for (var r = 0, i = t; r < i.length; r++) {\n              var o = i[r];\n              this.on(o, e, n);\n            }\n            return this;\n          }\n          if (w.object(t)) {\n            for (var a in t) this.on(a, t[a], e);\n            return this;\n          }\n          return ve(t, this.scope.actions) ? this.globalEvents[t] ? this.globalEvents[t].push(e) : this.globalEvents[t] = [e] : this.scope.events.add(this.scope.document, t, e, {\n            options: n\n          }), this;\n        }, \"The interact.on() method is being deprecated\"), e.off = Nt(function (t, e, n) {\n          if (w.string(t) && -1 !== t.search(\" \") && (t = t.trim().split(/ +/)), w.array(t)) {\n            for (var r = 0, i = t; r < i.length; r++) {\n              var o = i[r];\n              this.off(o, e, n);\n            }\n            return this;\n          }\n          if (w.object(t)) {\n            for (var a in t) this.off(a, t[a], e);\n            return this;\n          }\n          var s;\n          return ve(t, this.scope.actions) ? t in this.globalEvents && -1 !== (s = this.globalEvents[t].indexOf(e)) && this.globalEvents[t].splice(s, 1) : this.scope.events.remove(this.scope.document, t, e, n), this;\n        }, \"The interact.off() method is being deprecated\"), e.debug = function () {\n          return this.scope;\n        }, e.supportsTouch = function () {\n          return I.supportsTouch;\n        }, e.supportsPointerEvent = function () {\n          return I.supportsPointerEvent;\n        }, e.stop = function () {\n          for (var t = 0, e = this.scope.interactions.list; t < e.length; t++) e[t].stop();\n          return this;\n        }, e.pointerMoveTolerance = function (t) {\n          return w.number(t) ? (this.scope.interactions.pointerMoveTolerance = t, this) : this.scope.interactions.pointerMoveTolerance;\n        }, e.addDocument = function (t, e) {\n          this.scope.addDocument(t, e);\n        }, e.removeDocument = function (t) {\n          this.scope.removeDocument(t);\n        }, e;\n      }(this), this.InteractEvent = Se, this.Interactable = void 0, this.interactables = new an(this), this._win = void 0, this.document = void 0, this.window = void 0, this.documents = [], this._plugins = {\n        list: [],\n        map: {}\n      }, this.onWindowUnload = function (t) {\n        return e.removeDocument(t.target);\n      };\n      var n = this;\n      this.Interactable = function (t) {\n        s(i, t);\n        var e = p(i);\n        function i() {\n          return r(this, i), e.apply(this, arguments);\n        }\n        return o(i, [{\n          key: \"_defaults\",\n          get: function () {\n            return n.defaults;\n          }\n        }, {\n          key: \"set\",\n          value: function (t) {\n            return f(c(i.prototype), \"set\", this).call(this, t), n.fire(\"interactable:set\", {\n              options: t,\n              interactable: this\n            }), this;\n          }\n        }, {\n          key: \"unset\",\n          value: function () {\n            f(c(i.prototype), \"unset\", this).call(this);\n            var t = n.interactables.list.indexOf(this);\n            t < 0 || (n.interactables.list.splice(t, 1), n.fire(\"interactable:unset\", {\n              interactable: this\n            }));\n          }\n        }]), i;\n      }(on);\n    }\n    return o(t, [{\n      key: \"addListeners\",\n      value: function (t, e) {\n        this.listenerMaps.push({\n          id: e,\n          map: t\n        });\n      }\n    }, {\n      key: \"fire\",\n      value: function (t, e) {\n        for (var n = 0, r = this.listenerMaps; n < r.length; n++) {\n          var i = r[n].map[t];\n          if (i && !1 === i(e, this, t)) return !1;\n        }\n      }\n    }, {\n      key: \"init\",\n      value: function (t) {\n        return this.isInitialized ? this : function (t, e) {\n          t.isInitialized = !0, w.window(e) && m(e);\n          return k.init(e), I.init(e), Lt.init(e), t.window = e, t.document = e.document, t.usePlugin(nn), t.usePlugin(Ue), t;\n        }(this, t);\n      }\n    }, {\n      key: \"pluginIsInstalled\",\n      value: function (t) {\n        var e = t.id;\n        return e ? !!this._plugins.map[e] : -1 !== this._plugins.list.indexOf(t);\n      }\n    }, {\n      key: \"usePlugin\",\n      value: function (t, e) {\n        if (!this.isInitialized) return this;\n        if (this.pluginIsInstalled(t)) return this;\n        if (t.id && (this._plugins.map[t.id] = t), this._plugins.list.push(t), t.install && t.install(this, e), t.listeners && t.before) {\n          for (var n = 0, r = this.listenerMaps.length, i = t.before.reduce(function (t, e) {\n              return t[e] = !0, t[cn(e)] = !0, t;\n            }, {}); n < r; n++) {\n            var o = this.listenerMaps[n].id;\n            if (o && (i[o] || i[cn(o)])) break;\n          }\n          this.listenerMaps.splice(n, 0, {\n            id: t.id,\n            map: t.listeners\n          });\n        } else t.listeners && this.listenerMaps.push({\n          id: t.id,\n          map: t.listeners\n        });\n        return this;\n      }\n    }, {\n      key: \"addDocument\",\n      value: function (t, e) {\n        if (-1 !== this.getDocIndex(t)) return !1;\n        var n = y(t);\n        e = e ? V({}, e) : {}, this.documents.push({\n          doc: t,\n          options: e\n        }), this.events.documents.push(t), t !== this.document && this.events.add(n, \"unload\", this.onWindowUnload), this.fire(\"scope:add-document\", {\n          doc: t,\n          window: n,\n          scope: this,\n          options: e\n        });\n      }\n    }, {\n      key: \"removeDocument\",\n      value: function (t) {\n        var e = this.getDocIndex(t),\n          n = y(t),\n          r = this.documents[e].options;\n        this.events.remove(n, \"unload\", this.onWindowUnload), this.documents.splice(e, 1), this.events.documents.splice(e, 1), this.fire(\"scope:remove-document\", {\n          doc: t,\n          window: n,\n          scope: this,\n          options: r\n        });\n      }\n    }, {\n      key: \"getDocIndex\",\n      value: function (t) {\n        for (var e = 0; e < this.documents.length; e++) if (this.documents[e].doc === t) return e;\n        return -1;\n      }\n    }, {\n      key: \"getDocOptions\",\n      value: function (t) {\n        var e = this.getDocIndex(t);\n        return -1 === e ? null : this.documents[e].options;\n      }\n    }, {\n      key: \"now\",\n      value: function () {\n        return (this.window.Date || Date).now();\n      }\n    }]), t;\n  }();\n  function cn(t) {\n    return t && t.replace(/\\/.*$/, \"\");\n  }\n  var ln = new sn(),\n    un = ln.interactStatic,\n    pn = \"undefined\" != typeof globalThis ? globalThis : window;\n  ln.init(pn);\n  var fn = Object.freeze({\n      __proto__: null,\n      edgeTarget: function () {},\n      elements: function () {},\n      grid: function (t) {\n        var e = [[\"x\", \"y\"], [\"left\", \"top\"], [\"right\", \"bottom\"], [\"width\", \"height\"]].filter(function (e) {\n            var n = e[0],\n              r = e[1];\n            return n in t || r in t;\n          }),\n          n = function (n, r) {\n            for (var i = t.range, o = t.limits, a = void 0 === o ? {\n                left: -1 / 0,\n                right: 1 / 0,\n                top: -1 / 0,\n                bottom: 1 / 0\n              } : o, s = t.offset, c = void 0 === s ? {\n                x: 0,\n                y: 0\n              } : s, l = {\n                range: i,\n                grid: t,\n                x: null,\n                y: null\n              }, u = 0; u < e.length; u++) {\n              var p = e[u],\n                f = p[0],\n                d = p[1],\n                h = Math.round((n - c.x) / t[f]),\n                v = Math.round((r - c.y) / t[d]);\n              l[f] = Math.max(a.left, Math.min(a.right, h * t[f] + c.x)), l[d] = Math.max(a.top, Math.min(a.bottom, v * t[d] + c.y));\n            }\n            return l;\n          };\n        return n.grid = t, n.coordFields = e, n;\n      }\n    }),\n    dn = {\n      id: \"snappers\",\n      install: function (t) {\n        var e = t.interactStatic;\n        e.snappers = V(e.snappers || {}, fn), e.createSnapGrid = e.snappers.grid;\n      }\n    },\n    hn = dn,\n    vn = {\n      start: function (t) {\n        var n = t.state,\n          r = t.rect,\n          i = t.edges,\n          o = t.pageCoords,\n          a = n.options,\n          s = a.ratio,\n          c = a.enabled,\n          l = n.options,\n          u = l.equalDelta,\n          p = l.modifiers;\n        \"preserve\" === s && (s = r.width / r.height), n.startCoords = V({}, o), n.startRect = V({}, r), n.ratio = s, n.equalDelta = u;\n        var f = n.linkedEdges = {\n          top: i.top || i.left && !i.bottom,\n          left: i.left || i.top && !i.right,\n          bottom: i.bottom || i.right && !i.top,\n          right: i.right || i.bottom && !i.left\n        };\n        if (n.xIsPrimaryAxis = !(!i.left && !i.right), n.equalDelta) {\n          var d = (f.left ? 1 : -1) * (f.top ? 1 : -1);\n          n.edgeSign = {\n            x: d,\n            y: d\n          };\n        } else n.edgeSign = {\n          x: f.left ? -1 : 1,\n          y: f.top ? -1 : 1\n        };\n        if (!1 !== c && V(i, f), null != p && p.length) {\n          var h = new me(t.interaction);\n          h.copyFrom(t.interaction.modification), h.prepareStates(p), n.subModification = h, h.startAll(e({}, t));\n        }\n      },\n      set: function (t) {\n        var n = t.state,\n          r = t.rect,\n          i = t.coords,\n          o = n.linkedEdges,\n          a = V({}, i),\n          s = n.equalDelta ? gn : mn;\n        if (V(t.edges, o), s(n, n.xIsPrimaryAxis, i, r), !n.subModification) return null;\n        var c = V({}, r);\n        H(o, c, {\n          x: i.x - a.x,\n          y: i.y - a.y\n        });\n        var l = n.subModification.setAll(e(e({}, t), {}, {\n            rect: c,\n            edges: o,\n            pageCoords: i,\n            prevCoords: i,\n            prevRect: c\n          })),\n          u = l.delta;\n        l.changed && (s(n, Math.abs(u.x) > Math.abs(u.y), l.coords, l.rect), V(i, l.coords));\n        return l.eventProps;\n      },\n      defaults: {\n        ratio: \"preserve\",\n        equalDelta: !1,\n        modifiers: [],\n        enabled: !1\n      }\n    };\n  function gn(t, e, n) {\n    var r = t.startCoords,\n      i = t.edgeSign;\n    e ? n.y = r.y + (n.x - r.x) * i.y : n.x = r.x + (n.y - r.y) * i.x;\n  }\n  function mn(t, e, n, r) {\n    var i = t.startRect,\n      o = t.startCoords,\n      a = t.ratio,\n      s = t.edgeSign;\n    if (e) {\n      var c = r.width / a;\n      n.y = o.y + (c - i.height) * s.y;\n    } else {\n      var l = r.height * a;\n      n.x = o.x + (l - i.width) * s.x;\n    }\n  }\n  var yn = be(vn, \"aspectRatio\"),\n    bn = function () {};\n  bn._defaults = {};\n  var xn = bn;\n  function wn(t, e, n) {\n    return w.func(t) ? G(t, e.interactable, e.element, [n.x, n.y, e]) : G(t, e.interactable, e.element);\n  }\n  var En = {\n      start: function (t) {\n        var e = t.rect,\n          n = t.startOffset,\n          r = t.state,\n          i = t.interaction,\n          o = t.pageCoords,\n          a = r.options,\n          s = a.elementRect,\n          c = V({\n            left: 0,\n            top: 0,\n            right: 0,\n            bottom: 0\n          }, a.offset || {});\n        if (e && s) {\n          var l = wn(a.restriction, i, o);\n          if (l) {\n            var u = l.right - l.left - e.width,\n              p = l.bottom - l.top - e.height;\n            u < 0 && (c.left += u, c.right += u), p < 0 && (c.top += p, c.bottom += p);\n          }\n          c.left += n.left - e.width * s.left, c.top += n.top - e.height * s.top, c.right += n.right - e.width * (1 - s.right), c.bottom += n.bottom - e.height * (1 - s.bottom);\n        }\n        r.offset = c;\n      },\n      set: function (t) {\n        var e = t.coords,\n          n = t.interaction,\n          r = t.state,\n          i = r.options,\n          o = r.offset,\n          a = wn(i.restriction, n, e);\n        if (a) {\n          var s = function (t) {\n            return !t || \"left\" in t && \"top\" in t || ((t = V({}, t)).left = t.x || 0, t.top = t.y || 0, t.right = t.right || t.left + t.width, t.bottom = t.bottom || t.top + t.height), t;\n          }(a);\n          e.x = Math.max(Math.min(s.right - o.right, e.x), s.left + o.left), e.y = Math.max(Math.min(s.bottom - o.bottom, e.y), s.top + o.top);\n        }\n      },\n      defaults: {\n        restriction: null,\n        elementRect: null,\n        offset: null,\n        endOnly: !1,\n        enabled: !1\n      }\n    },\n    Tn = be(En, \"restrict\"),\n    Sn = {\n      top: 1 / 0,\n      left: 1 / 0,\n      bottom: -1 / 0,\n      right: -1 / 0\n    },\n    _n = {\n      top: -1 / 0,\n      left: -1 / 0,\n      bottom: 1 / 0,\n      right: 1 / 0\n    };\n  function Pn(t, e) {\n    for (var n = 0, r = [\"top\", \"left\", \"bottom\", \"right\"]; n < r.length; n++) {\n      var i = r[n];\n      i in t || (t[i] = e[i]);\n    }\n    return t;\n  }\n  var On = {\n      noInner: Sn,\n      noOuter: _n,\n      start: function (t) {\n        var e,\n          n = t.interaction,\n          r = t.startOffset,\n          i = t.state,\n          o = i.options;\n        o && (e = N(wn(o.offset, n, n.coords.start.page))), e = e || {\n          x: 0,\n          y: 0\n        }, i.offset = {\n          top: e.y + r.top,\n          left: e.x + r.left,\n          bottom: e.y - r.bottom,\n          right: e.x - r.right\n        };\n      },\n      set: function (t) {\n        var e = t.coords,\n          n = t.edges,\n          r = t.interaction,\n          i = t.state,\n          o = i.offset,\n          a = i.options;\n        if (n) {\n          var s = V({}, e),\n            c = wn(a.inner, r, s) || {},\n            l = wn(a.outer, r, s) || {};\n          Pn(c, Sn), Pn(l, _n), n.top ? e.y = Math.min(Math.max(l.top + o.top, s.y), c.top + o.top) : n.bottom && (e.y = Math.max(Math.min(l.bottom + o.bottom, s.y), c.bottom + o.bottom)), n.left ? e.x = Math.min(Math.max(l.left + o.left, s.x), c.left + o.left) : n.right && (e.x = Math.max(Math.min(l.right + o.right, s.x), c.right + o.right));\n        }\n      },\n      defaults: {\n        inner: null,\n        outer: null,\n        offset: null,\n        endOnly: !1,\n        enabled: !1\n      }\n    },\n    kn = be(On, \"restrictEdges\"),\n    Dn = V({\n      get elementRect() {\n        return {\n          top: 0,\n          left: 0,\n          bottom: 1,\n          right: 1\n        };\n      },\n      set elementRect(t) {}\n    }, En.defaults),\n    In = be({\n      start: En.start,\n      set: En.set,\n      defaults: Dn\n    }, \"restrictRect\"),\n    Mn = {\n      width: -1 / 0,\n      height: -1 / 0\n    },\n    zn = {\n      width: 1 / 0,\n      height: 1 / 0\n    };\n  var An = be({\n    start: function (t) {\n      return On.start(t);\n    },\n    set: function (t) {\n      var e = t.interaction,\n        n = t.state,\n        r = t.rect,\n        i = t.edges,\n        o = n.options;\n      if (i) {\n        var a = U(wn(o.min, e, t.coords)) || Mn,\n          s = U(wn(o.max, e, t.coords)) || zn;\n        n.options = {\n          endOnly: o.endOnly,\n          inner: V({}, On.noInner),\n          outer: V({}, On.noOuter)\n        }, i.top ? (n.options.inner.top = r.bottom - a.height, n.options.outer.top = r.bottom - s.height) : i.bottom && (n.options.inner.bottom = r.top + a.height, n.options.outer.bottom = r.top + s.height), i.left ? (n.options.inner.left = r.right - a.width, n.options.outer.left = r.right - s.width) : i.right && (n.options.inner.right = r.left + a.width, n.options.outer.right = r.left + s.width), On.set(t), n.options = o;\n      }\n    },\n    defaults: {\n      min: null,\n      max: null,\n      endOnly: !1,\n      enabled: !1\n    }\n  }, \"restrictSize\");\n  var Rn = {\n      start: function (t) {\n        var e,\n          n = t.interaction,\n          r = t.interactable,\n          i = t.element,\n          o = t.rect,\n          a = t.state,\n          s = t.startOffset,\n          c = a.options,\n          l = c.offsetWithOrigin ? function (t) {\n            var e = t.interaction.element,\n              n = N(G(t.state.options.origin, null, null, [e])),\n              r = n || K(t.interactable, e, t.interaction.prepared.name);\n            return r;\n          }(t) : {\n            x: 0,\n            y: 0\n          };\n        if (\"startCoords\" === c.offset) e = {\n          x: n.coords.start.page.x,\n          y: n.coords.start.page.y\n        };else {\n          var u = G(c.offset, r, i, [n]);\n          (e = N(u) || {\n            x: 0,\n            y: 0\n          }).x += l.x, e.y += l.y;\n        }\n        var p = c.relativePoints;\n        a.offsets = o && p && p.length ? p.map(function (t, n) {\n          return {\n            index: n,\n            relativePoint: t,\n            x: s.left - o.width * t.x + e.x,\n            y: s.top - o.height * t.y + e.y\n          };\n        }) : [{\n          index: 0,\n          relativePoint: null,\n          x: e.x,\n          y: e.y\n        }];\n      },\n      set: function (t) {\n        var e = t.interaction,\n          n = t.coords,\n          r = t.state,\n          i = r.options,\n          o = r.offsets,\n          a = K(e.interactable, e.element, e.prepared.name),\n          s = V({}, n),\n          c = [];\n        i.offsetWithOrigin || (s.x -= a.x, s.y -= a.y);\n        for (var l = 0, u = o; l < u.length; l++) for (var p = u[l], f = s.x - p.x, d = s.y - p.y, h = 0, v = i.targets.length; h < v; h++) {\n          var g = i.targets[h],\n            m = void 0;\n          (m = w.func(g) ? g(f, d, e._proxy, p, h) : g) && c.push({\n            x: (w.number(m.x) ? m.x : f) + p.x,\n            y: (w.number(m.y) ? m.y : d) + p.y,\n            range: w.number(m.range) ? m.range : i.range,\n            source: g,\n            index: h,\n            offset: p\n          });\n        }\n        for (var y = {\n            target: null,\n            inRange: !1,\n            distance: 0,\n            range: 0,\n            delta: {\n              x: 0,\n              y: 0\n            }\n          }, b = 0; b < c.length; b++) {\n          var x = c[b],\n            E = x.range,\n            T = x.x - s.x,\n            S = x.y - s.y,\n            _ = Q(T, S),\n            P = _ <= E;\n          E === 1 / 0 && y.inRange && y.range !== 1 / 0 && (P = !1), y.target && !(P ? y.inRange && E !== 1 / 0 ? _ / E < y.distance / y.range : E === 1 / 0 && y.range !== 1 / 0 || _ < y.distance : !y.inRange && _ < y.distance) || (y.target = x, y.distance = _, y.range = E, y.inRange = P, y.delta.x = T, y.delta.y = S);\n        }\n        return y.inRange && (n.x = y.target.x, n.y = y.target.y), r.closest = y, y;\n      },\n      defaults: {\n        range: 1 / 0,\n        targets: null,\n        offset: null,\n        offsetWithOrigin: !0,\n        origin: null,\n        relativePoints: null,\n        endOnly: !1,\n        enabled: !1\n      }\n    },\n    Cn = be(Rn, \"snap\");\n  var jn = {\n      start: function (t) {\n        var e = t.state,\n          n = t.edges,\n          r = e.options;\n        if (!n) return null;\n        t.state = {\n          options: {\n            targets: null,\n            relativePoints: [{\n              x: n.left ? 0 : 1,\n              y: n.top ? 0 : 1\n            }],\n            offset: r.offset || \"self\",\n            origin: {\n              x: 0,\n              y: 0\n            },\n            range: r.range\n          }\n        }, e.targetFields = e.targetFields || [[\"width\", \"height\"], [\"x\", \"y\"]], Rn.start(t), e.offsets = t.state.offsets, t.state = e;\n      },\n      set: function (t) {\n        var e = t.interaction,\n          n = t.state,\n          r = t.coords,\n          i = n.options,\n          o = n.offsets,\n          a = {\n            x: r.x - o[0].x,\n            y: r.y - o[0].y\n          };\n        n.options = V({}, i), n.options.targets = [];\n        for (var s = 0, c = i.targets || []; s < c.length; s++) {\n          var l = c[s],\n            u = void 0;\n          if (u = w.func(l) ? l(a.x, a.y, e) : l) {\n            for (var p = 0, f = n.targetFields; p < f.length; p++) {\n              var d = f[p],\n                h = d[0],\n                v = d[1];\n              if (h in u || v in u) {\n                u.x = u[h], u.y = u[v];\n                break;\n              }\n            }\n            n.options.targets.push(u);\n          }\n        }\n        var g = Rn.set(t);\n        return n.options = i, g;\n      },\n      defaults: {\n        range: 1 / 0,\n        targets: null,\n        offset: null,\n        endOnly: !1,\n        enabled: !1\n      }\n    },\n    Fn = be(jn, \"snapSize\");\n  var Xn = {\n      aspectRatio: yn,\n      restrictEdges: kn,\n      restrict: Tn,\n      restrictRect: In,\n      restrictSize: An,\n      snapEdges: be({\n        start: function (t) {\n          var e = t.edges;\n          return e ? (t.state.targetFields = t.state.targetFields || [[e.left ? \"left\" : \"right\", e.top ? \"top\" : \"bottom\"]], jn.start(t)) : null;\n        },\n        set: jn.set,\n        defaults: V(ge(jn.defaults), {\n          targets: void 0,\n          range: void 0,\n          offset: {\n            x: 0,\n            y: 0\n          }\n        })\n      }, \"snapEdges\"),\n      snap: Cn,\n      snapSize: Fn,\n      spring: xn,\n      avoid: xn,\n      transform: xn,\n      rubberband: xn\n    },\n    Yn = {\n      id: \"modifiers\",\n      install: function (t) {\n        var e = t.interactStatic;\n        for (var n in t.usePlugin(Ee), t.usePlugin(hn), e.modifiers = Xn, Xn) {\n          var r = Xn[n],\n            i = r._defaults,\n            o = r._methods;\n          i._methods = o, t.defaults.perAction[n] = i;\n        }\n      }\n    },\n    Ln = Yn,\n    qn = function (t) {\n      s(n, t);\n      var e = p(n);\n      function n(t, i, o, a, s, c) {\n        var l;\n        if (r(this, n), tt(u(l = e.call(this, s)), o), o !== i && tt(u(l), i), l.timeStamp = c, l.originalEvent = o, l.type = t, l.pointerId = at(i), l.pointerType = dt(i), l.target = a, l.currentTarget = null, \"tap\" === t) {\n          var p = s.getPointerIndex(i);\n          l.dt = l.timeStamp - s.pointers[p].downTime;\n          var f = l.timeStamp - s.tapTime;\n          l.double = !!s.prevTap && \"doubletap\" !== s.prevTap.type && s.prevTap.target === l.target && f < 500;\n        } else \"doubletap\" === t && (l.dt = i.timeStamp - s.tapTime, l.double = !0);\n        return l;\n      }\n      return o(n, [{\n        key: \"_subtractOrigin\",\n        value: function (t) {\n          var e = t.x,\n            n = t.y;\n          return this.pageX -= e, this.pageY -= n, this.clientX -= e, this.clientY -= n, this;\n        }\n      }, {\n        key: \"_addOrigin\",\n        value: function (t) {\n          var e = t.x,\n            n = t.y;\n          return this.pageX += e, this.pageY += n, this.clientX += e, this.clientY += n, this;\n        }\n      }, {\n        key: \"preventDefault\",\n        value: function () {\n          this.originalEvent.preventDefault();\n        }\n      }]), n;\n    }(vt),\n    Bn = {\n      id: \"pointer-events/base\",\n      before: [\"inertia\", \"modifiers\", \"auto-start\", \"actions\"],\n      install: function (t) {\n        t.pointerEvents = Bn, t.defaults.actions.pointerEvents = Bn.defaults, V(t.actions.phaselessTypes, Bn.types);\n      },\n      listeners: {\n        \"interactions:new\": function (t) {\n          var e = t.interaction;\n          e.prevTap = null, e.tapTime = 0;\n        },\n        \"interactions:update-pointer\": function (t) {\n          var e = t.down,\n            n = t.pointerInfo;\n          if (!e && n.hold) return;\n          n.hold = {\n            duration: 1 / 0,\n            timeout: null\n          };\n        },\n        \"interactions:move\": function (t, e) {\n          var n = t.interaction,\n            r = t.pointer,\n            i = t.event,\n            o = t.eventTarget;\n          t.duplicate || n.pointerIsDown && !n.pointerWasMoved || (n.pointerIsDown && Gn(t), Vn({\n            interaction: n,\n            pointer: r,\n            event: i,\n            eventTarget: o,\n            type: \"move\"\n          }, e));\n        },\n        \"interactions:down\": function (t, e) {\n          !function (t, e) {\n            for (var n = t.interaction, r = t.pointer, i = t.event, o = t.eventTarget, a = t.pointerIndex, s = n.pointers[a].hold, c = q(o), l = {\n                interaction: n,\n                pointer: r,\n                event: i,\n                eventTarget: o,\n                type: \"hold\",\n                targets: [],\n                path: c,\n                node: null\n              }, u = 0; u < c.length; u++) {\n              var p = c[u];\n              l.node = p, e.fire(\"pointerEvents:collect-targets\", l);\n            }\n            if (!l.targets.length) return;\n            for (var f = 1 / 0, d = 0, h = l.targets; d < h.length; d++) {\n              var v = h[d].eventable.options.holdDuration;\n              v < f && (f = v);\n            }\n            s.duration = f, s.timeout = setTimeout(function () {\n              Vn({\n                interaction: n,\n                eventTarget: o,\n                pointer: r,\n                event: i,\n                type: \"hold\"\n              }, e);\n            }, f);\n          }(t, e), Vn(t, e);\n        },\n        \"interactions:up\": function (t, e) {\n          Gn(t), Vn(t, e), function (t, e) {\n            var n = t.interaction,\n              r = t.pointer,\n              i = t.event,\n              o = t.eventTarget;\n            n.pointerWasMoved || Vn({\n              interaction: n,\n              eventTarget: o,\n              pointer: r,\n              event: i,\n              type: \"tap\"\n            }, e);\n          }(t, e);\n        },\n        \"interactions:cancel\": function (t, e) {\n          Gn(t), Vn(t, e);\n        }\n      },\n      PointerEvent: qn,\n      fire: Vn,\n      collectEventTargets: Wn,\n      defaults: {\n        holdDuration: 600,\n        ignoreFrom: null,\n        allowFrom: null,\n        origin: {\n          x: 0,\n          y: 0\n        }\n      },\n      types: {\n        down: !0,\n        move: !0,\n        up: !0,\n        cancel: !0,\n        tap: !0,\n        doubletap: !0,\n        hold: !0\n      }\n    };\n  function Vn(t, e) {\n    var n = t.interaction,\n      r = t.pointer,\n      i = t.event,\n      o = t.eventTarget,\n      a = t.type,\n      s = t.targets,\n      c = void 0 === s ? Wn(t, e) : s,\n      l = new qn(a, r, i, o, n, e.now());\n    e.fire(\"pointerEvents:new\", {\n      pointerEvent: l\n    });\n    for (var u = {\n        interaction: n,\n        pointer: r,\n        event: i,\n        eventTarget: o,\n        targets: c,\n        type: a,\n        pointerEvent: l\n      }, p = 0; p < c.length; p++) {\n      var f = c[p];\n      for (var d in f.props || {}) l[d] = f.props[d];\n      var h = K(f.eventable, f.node);\n      if (l._subtractOrigin(h), l.eventable = f.eventable, l.currentTarget = f.node, f.eventable.fire(l), l._addOrigin(h), l.immediatePropagationStopped || l.propagationStopped && p + 1 < c.length && c[p + 1].node !== l.currentTarget) break;\n    }\n    if (e.fire(\"pointerEvents:fired\", u), \"tap\" === a) {\n      var v = l.double ? Vn({\n        interaction: n,\n        pointer: r,\n        event: i,\n        eventTarget: o,\n        type: \"doubletap\"\n      }, e) : l;\n      n.prevTap = v, n.tapTime = v.timeStamp;\n    }\n    return l;\n  }\n  function Wn(t, e) {\n    var n = t.interaction,\n      r = t.pointer,\n      i = t.event,\n      o = t.eventTarget,\n      a = t.type,\n      s = n.getPointerIndex(r),\n      c = n.pointers[s];\n    if (\"tap\" === a && (n.pointerWasMoved || !c || c.downTarget !== o)) return [];\n    for (var l = q(o), u = {\n        interaction: n,\n        pointer: r,\n        event: i,\n        eventTarget: o,\n        type: a,\n        path: l,\n        targets: [],\n        node: null\n      }, p = 0; p < l.length; p++) {\n      var f = l[p];\n      u.node = f, e.fire(\"pointerEvents:collect-targets\", u);\n    }\n    return \"hold\" === a && (u.targets = u.targets.filter(function (t) {\n      var e, r;\n      return t.eventable.options.holdDuration === (null == (e = n.pointers[s]) || null == (r = e.hold) ? void 0 : r.duration);\n    })), u.targets;\n  }\n  function Gn(t) {\n    var e = t.interaction,\n      n = t.pointerIndex,\n      r = e.pointers[n].hold;\n    r && r.timeout && (clearTimeout(r.timeout), r.timeout = null);\n  }\n  var Nn = Object.freeze({\n    __proto__: null,\n    default: Bn\n  });\n  function Un(t) {\n    var e = t.interaction;\n    e.holdIntervalHandle && (clearInterval(e.holdIntervalHandle), e.holdIntervalHandle = null);\n  }\n  var Hn = {\n      id: \"pointer-events/holdRepeat\",\n      install: function (t) {\n        t.usePlugin(Bn);\n        var e = t.pointerEvents;\n        e.defaults.holdRepeatInterval = 0, e.types.holdrepeat = t.actions.phaselessTypes.holdrepeat = !0;\n      },\n      listeners: [\"move\", \"up\", \"cancel\", \"endall\"].reduce(function (t, e) {\n        return t[\"pointerEvents:\".concat(e)] = Un, t;\n      }, {\n        \"pointerEvents:new\": function (t) {\n          var e = t.pointerEvent;\n          \"hold\" === e.type && (e.count = (e.count || 0) + 1);\n        },\n        \"pointerEvents:fired\": function (t, e) {\n          var n = t.interaction,\n            r = t.pointerEvent,\n            i = t.eventTarget,\n            o = t.targets;\n          if (\"hold\" === r.type && o.length) {\n            var a = o[0].eventable.options.holdRepeatInterval;\n            a <= 0 || (n.holdIntervalHandle = setTimeout(function () {\n              e.pointerEvents.fire({\n                interaction: n,\n                eventTarget: i,\n                type: \"hold\",\n                pointer: r,\n                event: r\n              }, e);\n            }, a));\n          }\n        }\n      })\n    },\n    Kn = Hn;\n  var $n = {\n      id: \"pointer-events/interactableTargets\",\n      install: function (t) {\n        var e = t.Interactable;\n        e.prototype.pointerEvents = function (t) {\n          return V(this.events.options, t), this;\n        };\n        var n = e.prototype._backCompatOption;\n        e.prototype._backCompatOption = function (t, e) {\n          var r = n.call(this, t, e);\n          return r === this && (this.events.options[t] = e), r;\n        };\n      },\n      listeners: {\n        \"pointerEvents:collect-targets\": function (t, e) {\n          var n = t.targets,\n            r = t.node,\n            i = t.type,\n            o = t.eventTarget;\n          e.interactables.forEachMatch(r, function (t) {\n            var e = t.events,\n              a = e.options;\n            e.types[i] && e.types[i].length && t.testIgnoreAllow(a, r, o) && n.push({\n              node: r,\n              eventable: e,\n              props: {\n                interactable: t\n              }\n            });\n          });\n        },\n        \"interactable:new\": function (t) {\n          var e = t.interactable;\n          e.events.getRect = function (t) {\n            return e.getRect(t);\n          };\n        },\n        \"interactable:set\": function (t, e) {\n          var n = t.interactable,\n            r = t.options;\n          V(n.events.options, e.pointerEvents.defaults), V(n.events.options, r.pointerEvents || {});\n        }\n      }\n    },\n    Jn = $n,\n    Qn = {\n      id: \"pointer-events\",\n      install: function (t) {\n        t.usePlugin(Nn), t.usePlugin(Kn), t.usePlugin(Jn);\n      }\n    },\n    Zn = Qn;\n  var tr = {\n      id: \"reflow\",\n      install: function (t) {\n        var e = t.Interactable;\n        t.actions.phases.reflow = !0, e.prototype.reflow = function (e) {\n          return function (t, e, n) {\n            for (var r = t.getAllElements(), i = n.window.Promise, o = i ? [] : null, a = function () {\n                var a = r[s],\n                  c = t.getRect(a);\n                if (!c) return 1;\n                var l,\n                  u = bt(n.interactions.list, function (n) {\n                    return n.interacting() && n.interactable === t && n.element === a && n.prepared.name === e.name;\n                  });\n                if (u) u.move(), o && (l = u._reflowPromise || new i(function (t) {\n                  u._reflowResolve = t;\n                }));else {\n                  var p = U(c),\n                    f = function (t) {\n                      return {\n                        coords: t,\n                        get page() {\n                          return this.coords.page;\n                        },\n                        get client() {\n                          return this.coords.client;\n                        },\n                        get timeStamp() {\n                          return this.coords.timeStamp;\n                        },\n                        get pageX() {\n                          return this.coords.page.x;\n                        },\n                        get pageY() {\n                          return this.coords.page.y;\n                        },\n                        get clientX() {\n                          return this.coords.client.x;\n                        },\n                        get clientY() {\n                          return this.coords.client.y;\n                        },\n                        get pointerId() {\n                          return this.coords.pointerId;\n                        },\n                        get target() {\n                          return this.coords.target;\n                        },\n                        get type() {\n                          return this.coords.type;\n                        },\n                        get pointerType() {\n                          return this.coords.pointerType;\n                        },\n                        get buttons() {\n                          return this.coords.buttons;\n                        },\n                        preventDefault: function () {}\n                      };\n                    }({\n                      page: {\n                        x: p.x,\n                        y: p.y\n                      },\n                      client: {\n                        x: p.x,\n                        y: p.y\n                      },\n                      timeStamp: n.now()\n                    });\n                  l = function (t, e, n, r, i) {\n                    var o = t.interactions.new({\n                        pointerType: \"reflow\"\n                      }),\n                      a = {\n                        interaction: o,\n                        event: i,\n                        pointer: i,\n                        eventTarget: n,\n                        phase: \"reflow\"\n                      };\n                    o.interactable = e, o.element = n, o.prevEvent = i, o.updatePointer(i, i, n, !0), nt(o.coords.delta), Ut(o.prepared, r), o._doPhase(a);\n                    var s = t.window,\n                      c = s.Promise,\n                      l = c ? new c(function (t) {\n                        o._reflowResolve = t;\n                      }) : void 0;\n                    o._reflowPromise = l, o.start(r, e, n), o._interacting ? (o.move(a), o.end(i)) : (o.stop(), o._reflowResolve());\n                    return o.removePointer(i, i), l;\n                  }(n, t, a, e, f);\n                }\n                o && o.push(l);\n              }, s = 0; s < r.length && !a(); s++);\n            return o && i.all(o).then(function () {\n              return t;\n            });\n          }(this, e, t);\n        };\n      },\n      listeners: {\n        \"interactions:stop\": function (t, e) {\n          var n = t.interaction;\n          \"reflow\" === n.pointerType && (n._reflowResolve && n._reflowResolve(), function (t, e) {\n            t.splice(t.indexOf(e), 1);\n          }(e.interactions.list, n));\n        }\n      }\n    },\n    er = tr;\n  if (un.use(he), un.use(Ce), un.use(Zn), un.use(qe), un.use(Ln), un.use(pe), un.use(Xt), un.use(Gt), un.use(er), un.default = un, \"object\" === (\"undefined\" == typeof module ? \"undefined\" : n(module)) && module) try {\n    module.exports = un;\n  } catch (t) {}\n  return un.default = un, un;\n});\n//# sourceMappingURL=interact.min.js.map","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}
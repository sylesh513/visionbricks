{"ast":null,"code":"!function (e, t) {\n  \"object\" == typeof exports && \"object\" == typeof module ? module.exports = t() : \"function\" == typeof define && define.amd ? define([], t) : \"object\" == typeof exports ? exports.Drawflow = t() : e.Drawflow = t();\n}(\"undefined\" != typeof self ? self : this, function () {\n  return function (e) {\n    var t = {};\n    function n(i) {\n      if (t[i]) return t[i].exports;\n      var s = t[i] = {\n        i: i,\n        l: !1,\n        exports: {}\n      };\n      return e[i].call(s.exports, s, s.exports, n), s.l = !0, s.exports;\n    }\n    return n.m = e, n.c = t, n.d = function (e, t, i) {\n      n.o(e, t) || Object.defineProperty(e, t, {\n        enumerable: !0,\n        get: i\n      });\n    }, n.r = function (e) {\n      \"undefined\" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {\n        value: \"Module\"\n      }), Object.defineProperty(e, \"__esModule\", {\n        value: !0\n      });\n    }, n.t = function (e, t) {\n      if (1 & t && (e = n(e)), 8 & t) return e;\n      if (4 & t && \"object\" == typeof e && e && e.__esModule) return e;\n      var i = Object.create(null);\n      if (n.r(i), Object.defineProperty(i, \"default\", {\n        enumerable: !0,\n        value: e\n      }), 2 & t && \"string\" != typeof e) for (var s in e) n.d(i, s, function (t) {\n        return e[t];\n      }.bind(null, s));\n      return i;\n    }, n.n = function (e) {\n      var t = e && e.__esModule ? function () {\n        return e.default;\n      } : function () {\n        return e;\n      };\n      return n.d(t, \"a\", t), t;\n    }, n.o = function (e, t) {\n      return Object.prototype.hasOwnProperty.call(e, t);\n    }, n.p = \"\", n(n.s = 0);\n  }([function (e, t, n) {\n    \"use strict\";\n\n    n.r(t), n.d(t, \"default\", function () {\n      return i;\n    });\n    class i {\n      constructor(e, t = null, n = null) {\n        this.events = {}, this.container = e, this.precanvas = null, this.nodeId = 1, this.ele_selected = null, this.node_selected = null, this.drag = !1, this.reroute = !1, this.reroute_fix_curvature = !1, this.curvature = .5, this.reroute_curvature_start_end = .5, this.reroute_curvature = .5, this.reroute_width = 6, this.drag_point = !1, this.editor_selected = !1, this.connection = !1, this.connection_ele = null, this.connection_selected = null, this.canvas_x = 0, this.canvas_y = 0, this.pos_x = 0, this.pos_x_start = 0, this.pos_y = 0, this.pos_y_start = 0, this.mouse_x = 0, this.mouse_y = 0, this.line_path = 5, this.first_click = null, this.force_first_input = !1, this.draggable_inputs = !0, this.useuuid = !1, this.parent = n, this.noderegister = {}, this.render = t, this.drawflow = {\n          drawflow: {\n            Home: {\n              data: {}\n            }\n          }\n        }, this.module = \"Home\", this.editor_mode = \"edit\", this.zoom = 1, this.zoom_max = 1.6, this.zoom_min = .5, this.zoom_value = .1, this.zoom_last_value = 1, this.evCache = new Array(), this.prevDiff = -1;\n      }\n      start() {\n        this.container.classList.add(\"parent-drawflow\"), this.container.tabIndex = 0, this.precanvas = document.createElement(\"div\"), this.precanvas.classList.add(\"drawflow\"), this.container.appendChild(this.precanvas), this.container.addEventListener(\"mouseup\", this.dragEnd.bind(this)), this.container.addEventListener(\"mousemove\", this.position.bind(this)), this.container.addEventListener(\"mousedown\", this.click.bind(this)), this.container.addEventListener(\"touchend\", this.dragEnd.bind(this)), this.container.addEventListener(\"touchmove\", this.position.bind(this)), this.container.addEventListener(\"touchstart\", this.click.bind(this)), this.container.addEventListener(\"contextmenu\", this.contextmenu.bind(this)), this.container.addEventListener(\"keydown\", this.key.bind(this)), this.container.addEventListener(\"wheel\", this.zoom_enter.bind(this)), this.container.addEventListener(\"input\", this.updateNodeValue.bind(this)), this.container.addEventListener(\"dblclick\", this.dblclick.bind(this)), this.container.onpointerdown = this.pointerdown_handler.bind(this), this.container.onpointermove = this.pointermove_handler.bind(this), this.container.onpointerup = this.pointerup_handler.bind(this), this.container.onpointercancel = this.pointerup_handler.bind(this), this.container.onpointerout = this.pointerup_handler.bind(this), this.container.onpointerleave = this.pointerup_handler.bind(this), this.load();\n      }\n      pointerdown_handler(e) {\n        this.evCache.push(e);\n      }\n      pointermove_handler(e) {\n        for (var t = 0; t < this.evCache.length; t++) if (e.pointerId == this.evCache[t].pointerId) {\n          this.evCache[t] = e;\n          break;\n        }\n        if (2 == this.evCache.length) {\n          var n = Math.abs(this.evCache[0].clientX - this.evCache[1].clientX);\n          this.prevDiff > 100 && (n > this.prevDiff && this.zoom_in(), n < this.prevDiff && this.zoom_out()), this.prevDiff = n;\n        }\n      }\n      pointerup_handler(e) {\n        this.remove_event(e), this.evCache.length < 2 && (this.prevDiff = -1);\n      }\n      remove_event(e) {\n        for (var t = 0; t < this.evCache.length; t++) if (this.evCache[t].pointerId == e.pointerId) {\n          this.evCache.splice(t, 1);\n          break;\n        }\n      }\n      load() {\n        for (var e in this.drawflow.drawflow[this.module].data) this.addNodeImport(this.drawflow.drawflow[this.module].data[e], this.precanvas);\n        if (this.reroute) for (var e in this.drawflow.drawflow[this.module].data) this.addRerouteImport(this.drawflow.drawflow[this.module].data[e]);\n        for (var e in this.drawflow.drawflow[this.module].data) this.updateConnectionNodes(\"node-\" + e);\n        const t = this.drawflow.drawflow;\n        let n = 1;\n        Object.keys(t).map(function (e, i) {\n          Object.keys(t[e].data).map(function (e, t) {\n            parseInt(e) >= n && (n = parseInt(e) + 1);\n          });\n        }), this.nodeId = n;\n      }\n      removeReouteConnectionSelected() {\n        this.dispatch(\"connectionUnselected\", !0), this.reroute_fix_curvature && this.connection_selected.parentElement.querySelectorAll(\".main-path\").forEach((e, t) => {\n          e.classList.remove(\"selected\");\n        });\n      }\n      click(e) {\n        if (this.dispatch(\"click\", e), \"fixed\" === this.editor_mode) {\n          if (e.preventDefault(), \"parent-drawflow\" !== e.target.classList[0] && \"drawflow\" !== e.target.classList[0]) return !1;\n          this.ele_selected = e.target.closest(\".parent-drawflow\");\n        } else \"view\" === this.editor_mode ? (null != e.target.closest(\".drawflow\") || e.target.matches(\".parent-drawflow\")) && (this.ele_selected = e.target.closest(\".parent-drawflow\"), e.preventDefault()) : (this.first_click = e.target, this.ele_selected = e.target, 0 === e.button && this.contextmenuDel(), null != e.target.closest(\".drawflow_content_node\") && (this.ele_selected = e.target.closest(\".drawflow_content_node\").parentElement));\n        switch (this.ele_selected.classList[0]) {\n          case \"drawflow-node\":\n            null != this.node_selected && (this.node_selected.classList.remove(\"selected\"), this.node_selected != this.ele_selected && this.dispatch(\"nodeUnselected\", !0)), null != this.connection_selected && (this.connection_selected.classList.remove(\"selected\"), this.removeReouteConnectionSelected(), this.connection_selected = null), this.node_selected != this.ele_selected && this.dispatch(\"nodeSelected\", this.ele_selected.id.slice(5)), this.node_selected = this.ele_selected, this.node_selected.classList.add(\"selected\"), this.draggable_inputs ? \"SELECT\" !== e.target.tagName && (this.drag = !0) : \"INPUT\" !== e.target.tagName && \"TEXTAREA\" !== e.target.tagName && \"SELECT\" !== e.target.tagName && !0 !== e.target.hasAttribute(\"contenteditable\") && (this.drag = !0);\n            break;\n          case \"output\":\n            this.connection = !0, null != this.node_selected && (this.node_selected.classList.remove(\"selected\"), this.node_selected = null, this.dispatch(\"nodeUnselected\", !0)), null != this.connection_selected && (this.connection_selected.classList.remove(\"selected\"), this.removeReouteConnectionSelected(), this.connection_selected = null), this.drawConnection(e.target);\n            break;\n          case \"parent-drawflow\":\n          case \"drawflow\":\n            null != this.node_selected && (this.node_selected.classList.remove(\"selected\"), this.node_selected = null, this.dispatch(\"nodeUnselected\", !0)), null != this.connection_selected && (this.connection_selected.classList.remove(\"selected\"), this.removeReouteConnectionSelected(), this.connection_selected = null), this.editor_selected = !0;\n            break;\n          case \"main-path\":\n            null != this.node_selected && (this.node_selected.classList.remove(\"selected\"), this.node_selected = null, this.dispatch(\"nodeUnselected\", !0)), null != this.connection_selected && (this.connection_selected.classList.remove(\"selected\"), this.removeReouteConnectionSelected(), this.connection_selected = null), this.connection_selected = this.ele_selected, this.connection_selected.classList.add(\"selected\");\n            const t = this.connection_selected.parentElement.classList;\n            t.length > 1 && (this.dispatch(\"connectionSelected\", {\n              output_id: t[2].slice(14),\n              input_id: t[1].slice(13),\n              output_class: t[3],\n              input_class: t[4]\n            }), this.reroute_fix_curvature && this.connection_selected.parentElement.querySelectorAll(\".main-path\").forEach((e, t) => {\n              e.classList.add(\"selected\");\n            }));\n            break;\n          case \"point\":\n            this.drag_point = !0, this.ele_selected.classList.add(\"selected\");\n            break;\n          case \"drawflow-delete\":\n            this.node_selected && this.removeNodeId(this.node_selected.id), this.connection_selected && this.removeConnection(), null != this.node_selected && (this.node_selected.classList.remove(\"selected\"), this.node_selected = null, this.dispatch(\"nodeUnselected\", !0)), null != this.connection_selected && (this.connection_selected.classList.remove(\"selected\"), this.removeReouteConnectionSelected(), this.connection_selected = null);\n        }\n        \"touchstart\" === e.type ? (this.pos_x = e.touches[0].clientX, this.pos_x_start = e.touches[0].clientX, this.pos_y = e.touches[0].clientY, this.pos_y_start = e.touches[0].clientY, this.mouse_x = e.touches[0].clientX, this.mouse_y = e.touches[0].clientY) : (this.pos_x = e.clientX, this.pos_x_start = e.clientX, this.pos_y = e.clientY, this.pos_y_start = e.clientY), [\"input\", \"output\", \"main-path\"].includes(this.ele_selected.classList[0]) && e.preventDefault(), this.dispatch(\"clickEnd\", e);\n      }\n      position(e) {\n        if (\"touchmove\" === e.type) var t = e.touches[0].clientX,\n          n = e.touches[0].clientY;else t = e.clientX, n = e.clientY;\n        if (this.connection && this.updateConnection(t, n), this.editor_selected && (i = this.canvas_x + -(this.pos_x - t), s = this.canvas_y + -(this.pos_y - n), this.dispatch(\"translate\", {\n          x: i,\n          y: s\n        }), this.precanvas.style.transform = \"translate(\" + i + \"px, \" + s + \"px) scale(\" + this.zoom + \")\"), this.drag) {\n          e.preventDefault();\n          var i = (this.pos_x - t) * this.precanvas.clientWidth / (this.precanvas.clientWidth * this.zoom),\n            s = (this.pos_y - n) * this.precanvas.clientHeight / (this.precanvas.clientHeight * this.zoom);\n          this.pos_x = t, this.pos_y = n, this.ele_selected.style.top = this.ele_selected.offsetTop - s + \"px\", this.ele_selected.style.left = this.ele_selected.offsetLeft - i + \"px\", this.drawflow.drawflow[this.module].data[this.ele_selected.id.slice(5)].pos_x = this.ele_selected.offsetLeft - i, this.drawflow.drawflow[this.module].data[this.ele_selected.id.slice(5)].pos_y = this.ele_selected.offsetTop - s, this.updateConnectionNodes(this.ele_selected.id);\n        }\n        if (this.drag_point) {\n          i = (this.pos_x - t) * this.precanvas.clientWidth / (this.precanvas.clientWidth * this.zoom), s = (this.pos_y - n) * this.precanvas.clientHeight / (this.precanvas.clientHeight * this.zoom);\n          this.pos_x = t, this.pos_y = n;\n          var o = this.pos_x * (this.precanvas.clientWidth / (this.precanvas.clientWidth * this.zoom)) - this.precanvas.getBoundingClientRect().x * (this.precanvas.clientWidth / (this.precanvas.clientWidth * this.zoom)),\n            l = this.pos_y * (this.precanvas.clientHeight / (this.precanvas.clientHeight * this.zoom)) - this.precanvas.getBoundingClientRect().y * (this.precanvas.clientHeight / (this.precanvas.clientHeight * this.zoom));\n          this.ele_selected.setAttributeNS(null, \"cx\", o), this.ele_selected.setAttributeNS(null, \"cy\", l);\n          const e = this.ele_selected.parentElement.classList[2].slice(9),\n            c = this.ele_selected.parentElement.classList[1].slice(13),\n            d = this.ele_selected.parentElement.classList[3],\n            a = this.ele_selected.parentElement.classList[4];\n          let r = Array.from(this.ele_selected.parentElement.children).indexOf(this.ele_selected) - 1;\n          if (this.reroute_fix_curvature) {\n            r -= this.ele_selected.parentElement.querySelectorAll(\".main-path\").length - 1, r < 0 && (r = 0);\n          }\n          const h = e.slice(5),\n            u = this.drawflow.drawflow[this.module].data[h].outputs[d].connections.findIndex(function (e, t) {\n              return e.node === c && e.output === a;\n            });\n          this.drawflow.drawflow[this.module].data[h].outputs[d].connections[u].points[r] = {\n            pos_x: o,\n            pos_y: l\n          };\n          const p = this.ele_selected.parentElement.classList[2].slice(9);\n          this.updateConnectionNodes(p);\n        }\n        \"touchmove\" === e.type && (this.mouse_x = t, this.mouse_y = n), this.dispatch(\"mouseMove\", {\n          x: t,\n          y: n\n        });\n      }\n      dragEnd(e) {\n        if (\"touchend\" === e.type) var t = this.mouse_x,\n          n = this.mouse_y,\n          i = document.elementFromPoint(t, n);else t = e.clientX, n = e.clientY, i = e.target;\n        if (this.drag && (this.pos_x_start == t && this.pos_y_start == n || this.dispatch(\"nodeMoved\", this.ele_selected.id.slice(5))), this.drag_point && (this.ele_selected.classList.remove(\"selected\"), this.pos_x_start == t && this.pos_y_start == n || this.dispatch(\"rerouteMoved\", this.ele_selected.parentElement.classList[2].slice(14))), this.editor_selected && (this.canvas_x = this.canvas_x + -(this.pos_x - t), this.canvas_y = this.canvas_y + -(this.pos_y - n), this.editor_selected = !1), !0 === this.connection) if (\"input\" === i.classList[0] || this.force_first_input && (null != i.closest(\".drawflow_content_node\") || \"drawflow-node\" === i.classList[0])) {\n          if (!this.force_first_input || null == i.closest(\".drawflow_content_node\") && \"drawflow-node\" !== i.classList[0]) s = i.parentElement.parentElement.id, o = i.classList[1];else {\n            if (null != i.closest(\".drawflow_content_node\")) var s = i.closest(\".drawflow_content_node\").parentElement.id;else var s = i.id;\n            if (0 === Object.keys(this.getNodeFromId(s.slice(5)).inputs).length) var o = !1;else var o = \"input_1\";\n          }\n          var l = this.ele_selected.parentElement.parentElement.id,\n            c = this.ele_selected.classList[1];\n          if (l !== s && !1 !== o) {\n            if (0 === this.container.querySelectorAll(\".connection.node_in_\" + s + \".node_out_\" + l + \".\" + c + \".\" + o).length) {\n              this.connection_ele.classList.add(\"node_in_\" + s), this.connection_ele.classList.add(\"node_out_\" + l), this.connection_ele.classList.add(c), this.connection_ele.classList.add(o);\n              var d = s.slice(5),\n                a = l.slice(5);\n              this.drawflow.drawflow[this.module].data[a].outputs[c].connections.push({\n                node: d,\n                output: o\n              }), this.drawflow.drawflow[this.module].data[d].inputs[o].connections.push({\n                node: a,\n                input: c\n              }), this.updateConnectionNodes(\"node-\" + a), this.updateConnectionNodes(\"node-\" + d), this.dispatch(\"connectionCreated\", {\n                output_id: a,\n                input_id: d,\n                output_class: c,\n                input_class: o\n              });\n            } else this.dispatch(\"connectionCancel\", !0), this.connection_ele.remove();\n            this.connection_ele = null;\n          } else this.dispatch(\"connectionCancel\", !0), this.connection_ele.remove(), this.connection_ele = null;\n        } else this.dispatch(\"connectionCancel\", !0), this.connection_ele.remove(), this.connection_ele = null;\n        this.drag = !1, this.drag_point = !1, this.connection = !1, this.ele_selected = null, this.editor_selected = !1, this.dispatch(\"mouseUp\", e);\n      }\n      contextmenu(e) {\n        if (this.dispatch(\"contextmenu\", e), e.preventDefault(), \"fixed\" === this.editor_mode || \"view\" === this.editor_mode) return !1;\n        if (this.precanvas.getElementsByClassName(\"drawflow-delete\").length && this.precanvas.getElementsByClassName(\"drawflow-delete\")[0].remove(), this.node_selected || this.connection_selected) {\n          var t = document.createElement(\"div\");\n          t.classList.add(\"drawflow-delete\"), t.innerHTML = \"x\", this.node_selected && this.node_selected.appendChild(t), this.connection_selected && this.connection_selected.parentElement.classList.length > 1 && (t.style.top = e.clientY * (this.precanvas.clientHeight / (this.precanvas.clientHeight * this.zoom)) - this.precanvas.getBoundingClientRect().y * (this.precanvas.clientHeight / (this.precanvas.clientHeight * this.zoom)) + \"px\", t.style.left = e.clientX * (this.precanvas.clientWidth / (this.precanvas.clientWidth * this.zoom)) - this.precanvas.getBoundingClientRect().x * (this.precanvas.clientWidth / (this.precanvas.clientWidth * this.zoom)) + \"px\", this.precanvas.appendChild(t));\n        }\n      }\n      contextmenuDel() {\n        this.precanvas.getElementsByClassName(\"drawflow-delete\").length && this.precanvas.getElementsByClassName(\"drawflow-delete\")[0].remove();\n      }\n      key(e) {\n        if (this.dispatch(\"keydown\", e), \"fixed\" === this.editor_mode || \"view\" === this.editor_mode) return !1;\n        (\"Delete\" === e.key || \"Backspace\" === e.key && e.metaKey) && (null != this.node_selected && \"INPUT\" !== this.first_click.tagName && \"TEXTAREA\" !== this.first_click.tagName && !0 !== this.first_click.hasAttribute(\"contenteditable\") && this.removeNodeId(this.node_selected.id), null != this.connection_selected && this.removeConnection());\n      }\n      zoom_enter(e, t) {\n        e.ctrlKey && (e.preventDefault(), e.deltaY > 0 ? this.zoom_out() : this.zoom_in());\n      }\n      zoom_refresh() {\n        this.dispatch(\"zoom\", this.zoom), this.canvas_x = this.canvas_x / this.zoom_last_value * this.zoom, this.canvas_y = this.canvas_y / this.zoom_last_value * this.zoom, this.zoom_last_value = this.zoom, this.precanvas.style.transform = \"translate(\" + this.canvas_x + \"px, \" + this.canvas_y + \"px) scale(\" + this.zoom + \")\";\n      }\n      zoom_in() {\n        this.zoom < this.zoom_max && (this.zoom += this.zoom_value, this.zoom_refresh());\n      }\n      zoom_out() {\n        this.zoom > this.zoom_min && (this.zoom -= this.zoom_value, this.zoom_refresh());\n      }\n      zoom_reset() {\n        1 != this.zoom && (this.zoom = 1, this.zoom_refresh());\n      }\n      createCurvature(e, t, n, i, s, o) {\n        var l = e,\n          c = t,\n          d = n,\n          a = i,\n          r = s;\n        switch (o) {\n          case \"open\":\n            if (e >= n) var h = l + Math.abs(d - l) * r,\n              u = d - Math.abs(d - l) * (-1 * r);else h = l + Math.abs(d - l) * r, u = d - Math.abs(d - l) * r;\n            return \" M \" + l + \" \" + c + \" C \" + h + \" \" + c + \" \" + u + \" \" + a + \" \" + d + \"  \" + a;\n          case \"close\":\n            if (e >= n) h = l + Math.abs(d - l) * (-1 * r), u = d - Math.abs(d - l) * r;else h = l + Math.abs(d - l) * r, u = d - Math.abs(d - l) * r;\n            return \" M \" + l + \" \" + c + \" C \" + h + \" \" + c + \" \" + u + \" \" + a + \" \" + d + \"  \" + a;\n          case \"other\":\n            if (e >= n) h = l + Math.abs(d - l) * (-1 * r), u = d - Math.abs(d - l) * (-1 * r);else h = l + Math.abs(d - l) * r, u = d - Math.abs(d - l) * r;\n            return \" M \" + l + \" \" + c + \" C \" + h + \" \" + c + \" \" + u + \" \" + a + \" \" + d + \"  \" + a;\n          default:\n            return \" M \" + l + \" \" + c + \" C \" + (h = l + Math.abs(d - l) * r) + \" \" + c + \" \" + (u = d - Math.abs(d - l) * r) + \" \" + a + \" \" + d + \"  \" + a;\n        }\n      }\n      drawConnection(e) {\n        var t = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\");\n        this.connection_ele = t;\n        var n = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n        n.classList.add(\"main-path\"), n.setAttributeNS(null, \"d\", \"\"), t.classList.add(\"connection\"), t.appendChild(n), this.precanvas.appendChild(t);\n        var i = e.parentElement.parentElement.id.slice(5),\n          s = e.classList[1];\n        this.dispatch(\"connectionStart\", {\n          output_id: i,\n          output_class: s\n        });\n      }\n      updateConnection(e, t) {\n        const n = this.precanvas,\n          i = this.zoom;\n        let s = n.clientWidth / (n.clientWidth * i);\n        s = s || 0;\n        let o = n.clientHeight / (n.clientHeight * i);\n        o = o || 0;\n        var l = this.connection_ele.children[0],\n          c = this.ele_selected.offsetWidth / 2 + (this.ele_selected.getBoundingClientRect().x - n.getBoundingClientRect().x) * s,\n          d = this.ele_selected.offsetHeight / 2 + (this.ele_selected.getBoundingClientRect().y - n.getBoundingClientRect().y) * o,\n          a = e * (this.precanvas.clientWidth / (this.precanvas.clientWidth * this.zoom)) - this.precanvas.getBoundingClientRect().x * (this.precanvas.clientWidth / (this.precanvas.clientWidth * this.zoom)),\n          r = t * (this.precanvas.clientHeight / (this.precanvas.clientHeight * this.zoom)) - this.precanvas.getBoundingClientRect().y * (this.precanvas.clientHeight / (this.precanvas.clientHeight * this.zoom)),\n          h = this.curvature,\n          u = this.createCurvature(c, d, a, r, h, \"openclose\");\n        l.setAttributeNS(null, \"d\", u);\n      }\n      addConnection(e, t, n, i) {\n        var s = this.getModuleFromNodeId(e);\n        if (s === this.getModuleFromNodeId(t)) {\n          var o = this.getNodeFromId(e),\n            l = !1;\n          for (var c in o.outputs[n].connections) {\n            var d = o.outputs[n].connections[c];\n            d.node == t && d.output == i && (l = !0);\n          }\n          if (!1 === l) {\n            if (this.drawflow.drawflow[s].data[e].outputs[n].connections.push({\n              node: t.toString(),\n              output: i\n            }), this.drawflow.drawflow[s].data[t].inputs[i].connections.push({\n              node: e.toString(),\n              input: n\n            }), this.module === s) {\n              var a = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\"),\n                r = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n              r.classList.add(\"main-path\"), r.setAttributeNS(null, \"d\", \"\"), a.classList.add(\"connection\"), a.classList.add(\"node_in_node-\" + t), a.classList.add(\"node_out_node-\" + e), a.classList.add(n), a.classList.add(i), a.appendChild(r), this.precanvas.appendChild(a), this.updateConnectionNodes(\"node-\" + e), this.updateConnectionNodes(\"node-\" + t);\n            }\n            this.dispatch(\"connectionCreated\", {\n              output_id: e,\n              input_id: t,\n              output_class: n,\n              input_class: i\n            });\n          }\n        }\n      }\n      updateConnectionNodes(e) {\n        const t = \"node_in_\" + e,\n          n = \"node_out_\" + e;\n        this.line_path;\n        const i = this.container,\n          s = this.precanvas,\n          o = this.curvature,\n          l = this.createCurvature,\n          c = this.reroute_curvature,\n          d = this.reroute_curvature_start_end,\n          a = this.reroute_fix_curvature,\n          r = this.reroute_width,\n          h = this.zoom;\n        let u = s.clientWidth / (s.clientWidth * h);\n        u = u || 0;\n        let p = s.clientHeight / (s.clientHeight * h);\n        p = p || 0;\n        const f = i.querySelectorAll(\".\" + n);\n        Object.keys(f).map(function (t, n) {\n          if (null === f[t].querySelector(\".point\")) {\n            var m = i.querySelector(\"#\" + e),\n              g = f[t].classList[1].replace(\"node_in_\", \"\"),\n              _ = i.querySelector(\"#\" + g).querySelectorAll(\".\" + f[t].classList[4])[0],\n              w = _.offsetWidth / 2 + (_.getBoundingClientRect().x - s.getBoundingClientRect().x) * u,\n              v = _.offsetHeight / 2 + (_.getBoundingClientRect().y - s.getBoundingClientRect().y) * p,\n              y = m.querySelectorAll(\".\" + f[t].classList[3])[0],\n              C = y.offsetWidth / 2 + (y.getBoundingClientRect().x - s.getBoundingClientRect().x) * u,\n              x = y.offsetHeight / 2 + (y.getBoundingClientRect().y - s.getBoundingClientRect().y) * p;\n            const n = l(C, x, w, v, o, \"openclose\");\n            f[t].children[0].setAttributeNS(null, \"d\", n);\n          } else {\n            const n = f[t].querySelectorAll(\".point\");\n            let o = \"\";\n            const m = [];\n            n.forEach((t, a) => {\n              if (0 === a && n.length - 1 == 0) {\n                var f = i.querySelector(\"#\" + e),\n                  g = ((x = t).getBoundingClientRect().x - s.getBoundingClientRect().x) * u + r,\n                  _ = (x.getBoundingClientRect().y - s.getBoundingClientRect().y) * p + r,\n                  w = (L = f.querySelectorAll(\".\" + t.parentElement.classList[3])[0]).offsetWidth / 2 + (L.getBoundingClientRect().x - s.getBoundingClientRect().x) * u,\n                  v = L.offsetHeight / 2 + (L.getBoundingClientRect().y - s.getBoundingClientRect().y) * p,\n                  y = l(w, v, g, _, d, \"open\");\n                o += y, m.push(y);\n                f = t;\n                var C = t.parentElement.classList[1].replace(\"node_in_\", \"\"),\n                  x = (E = i.querySelector(\"#\" + C)).querySelectorAll(\".\" + t.parentElement.classList[4])[0];\n                g = (R = E.querySelectorAll(\".\" + t.parentElement.classList[4])[0]).offsetWidth / 2 + (R.getBoundingClientRect().x - s.getBoundingClientRect().x) * u, _ = R.offsetHeight / 2 + (R.getBoundingClientRect().y - s.getBoundingClientRect().y) * p, w = (f.getBoundingClientRect().x - s.getBoundingClientRect().x) * u + r, v = (f.getBoundingClientRect().y - s.getBoundingClientRect().y) * p + r, y = l(w, v, g, _, d, \"close\");\n                o += y, m.push(y);\n              } else if (0 === a) {\n                var L;\n                f = i.querySelector(\"#\" + e), g = ((x = t).getBoundingClientRect().x - s.getBoundingClientRect().x) * u + r, _ = (x.getBoundingClientRect().y - s.getBoundingClientRect().y) * p + r, w = (L = f.querySelectorAll(\".\" + t.parentElement.classList[3])[0]).offsetWidth / 2 + (L.getBoundingClientRect().x - s.getBoundingClientRect().x) * u, v = L.offsetHeight / 2 + (L.getBoundingClientRect().y - s.getBoundingClientRect().y) * p, y = l(w, v, g, _, d, \"open\");\n                o += y, m.push(y);\n                f = t, g = ((x = n[a + 1]).getBoundingClientRect().x - s.getBoundingClientRect().x) * u + r, _ = (x.getBoundingClientRect().y - s.getBoundingClientRect().y) * p + r, w = (f.getBoundingClientRect().x - s.getBoundingClientRect().x) * u + r, v = (f.getBoundingClientRect().y - s.getBoundingClientRect().y) * p + r, y = l(w, v, g, _, c, \"other\");\n                o += y, m.push(y);\n              } else if (a === n.length - 1) {\n                var E, R;\n                f = t, C = t.parentElement.classList[1].replace(\"node_in_\", \"\"), x = (E = i.querySelector(\"#\" + C)).querySelectorAll(\".\" + t.parentElement.classList[4])[0], g = (R = E.querySelectorAll(\".\" + t.parentElement.classList[4])[0]).offsetWidth / 2 + (R.getBoundingClientRect().x - s.getBoundingClientRect().x) * u, _ = R.offsetHeight / 2 + (R.getBoundingClientRect().y - s.getBoundingClientRect().y) * p, w = (f.getBoundingClientRect().x - s.getBoundingClientRect().x) * (s.clientWidth / (s.clientWidth * h)) + r, v = (f.getBoundingClientRect().y - s.getBoundingClientRect().y) * (s.clientHeight / (s.clientHeight * h)) + r, y = l(w, v, g, _, d, \"close\");\n                o += y, m.push(y);\n              } else {\n                f = t, g = ((x = n[a + 1]).getBoundingClientRect().x - s.getBoundingClientRect().x) * (s.clientWidth / (s.clientWidth * h)) + r, _ = (x.getBoundingClientRect().y - s.getBoundingClientRect().y) * (s.clientHeight / (s.clientHeight * h)) + r, w = (f.getBoundingClientRect().x - s.getBoundingClientRect().x) * (s.clientWidth / (s.clientWidth * h)) + r, v = (f.getBoundingClientRect().y - s.getBoundingClientRect().y) * (s.clientHeight / (s.clientHeight * h)) + r, y = l(w, v, g, _, c, \"other\");\n                o += y, m.push(y);\n              }\n            }), a ? m.forEach((e, n) => {\n              f[t].children[n].setAttributeNS(null, \"d\", e);\n            }) : f[t].children[0].setAttributeNS(null, \"d\", o);\n          }\n        });\n        const m = i.querySelectorAll(\".\" + t);\n        Object.keys(m).map(function (t, n) {\n          if (null === m[t].querySelector(\".point\")) {\n            var h = i.querySelector(\"#\" + e),\n              f = m[t].classList[2].replace(\"node_out_\", \"\"),\n              g = i.querySelector(\"#\" + f).querySelectorAll(\".\" + m[t].classList[3])[0],\n              _ = g.offsetWidth / 2 + (g.getBoundingClientRect().x - s.getBoundingClientRect().x) * u,\n              w = g.offsetHeight / 2 + (g.getBoundingClientRect().y - s.getBoundingClientRect().y) * p,\n              v = (h = h.querySelectorAll(\".\" + m[t].classList[4])[0]).offsetWidth / 2 + (h.getBoundingClientRect().x - s.getBoundingClientRect().x) * u,\n              y = h.offsetHeight / 2 + (h.getBoundingClientRect().y - s.getBoundingClientRect().y) * p;\n            const n = l(_, w, v, y, o, \"openclose\");\n            m[t].children[0].setAttributeNS(null, \"d\", n);\n          } else {\n            const n = m[t].querySelectorAll(\".point\");\n            let o = \"\";\n            const h = [];\n            n.forEach((t, a) => {\n              if (0 === a && n.length - 1 == 0) {\n                var f = i.querySelector(\"#\" + e),\n                  m = ((C = t).getBoundingClientRect().x - s.getBoundingClientRect().x) * u + r,\n                  g = (C.getBoundingClientRect().y - s.getBoundingClientRect().y) * p + r,\n                  _ = (E = f.querySelectorAll(\".\" + t.parentElement.classList[4])[0]).offsetWidth / 2 + (E.getBoundingClientRect().x - s.getBoundingClientRect().x) * u,\n                  w = E.offsetHeight / 2 + (E.getBoundingClientRect().y - s.getBoundingClientRect().y) * p,\n                  v = l(m, g, _, w, d, \"close\");\n                o += v, h.push(v);\n                f = t;\n                var y = t.parentElement.classList[2].replace(\"node_out_\", \"\"),\n                  C = (L = i.querySelector(\"#\" + y)).querySelectorAll(\".\" + t.parentElement.classList[3])[0];\n                m = (x = L.querySelectorAll(\".\" + t.parentElement.classList[3])[0]).offsetWidth / 2 + (x.getBoundingClientRect().x - s.getBoundingClientRect().x) * u, g = x.offsetHeight / 2 + (x.getBoundingClientRect().y - s.getBoundingClientRect().y) * p, _ = (f.getBoundingClientRect().x - s.getBoundingClientRect().x) * u + r, w = (f.getBoundingClientRect().y - s.getBoundingClientRect().y) * p + r, v = l(m, g, _, w, d, \"open\");\n                o += v, h.push(v);\n              } else if (0 === a) {\n                var x;\n                f = t, y = t.parentElement.classList[2].replace(\"node_out_\", \"\"), C = (L = i.querySelector(\"#\" + y)).querySelectorAll(\".\" + t.parentElement.classList[3])[0], m = (x = L.querySelectorAll(\".\" + t.parentElement.classList[3])[0]).offsetWidth / 2 + (x.getBoundingClientRect().x - s.getBoundingClientRect().x) * u, g = x.offsetHeight / 2 + (x.getBoundingClientRect().y - s.getBoundingClientRect().y) * p, _ = (f.getBoundingClientRect().x - s.getBoundingClientRect().x) * u + r, w = (f.getBoundingClientRect().y - s.getBoundingClientRect().y) * p + r, v = l(m, g, _, w, d, \"open\");\n                o += v, h.push(v);\n                f = t, _ = ((C = n[a + 1]).getBoundingClientRect().x - s.getBoundingClientRect().x) * u + r, w = (C.getBoundingClientRect().y - s.getBoundingClientRect().y) * p + r, m = (f.getBoundingClientRect().x - s.getBoundingClientRect().x) * u + r, g = (f.getBoundingClientRect().y - s.getBoundingClientRect().y) * p + r, v = l(m, g, _, w, c, \"other\");\n                o += v, h.push(v);\n              } else if (a === n.length - 1) {\n                var L, E;\n                f = t, y = t.parentElement.classList[1].replace(\"node_in_\", \"\"), C = (L = i.querySelector(\"#\" + y)).querySelectorAll(\".\" + t.parentElement.classList[4])[0], _ = (E = L.querySelectorAll(\".\" + t.parentElement.classList[4])[0]).offsetWidth / 2 + (E.getBoundingClientRect().x - s.getBoundingClientRect().x) * u, w = E.offsetHeight / 2 + (E.getBoundingClientRect().y - s.getBoundingClientRect().y) * p, m = (f.getBoundingClientRect().x - s.getBoundingClientRect().x) * u + r, g = (f.getBoundingClientRect().y - s.getBoundingClientRect().y) * p + r, v = l(m, g, _, w, d, \"close\");\n                o += v, h.push(v);\n              } else {\n                f = t, _ = ((C = n[a + 1]).getBoundingClientRect().x - s.getBoundingClientRect().x) * u + r, w = (C.getBoundingClientRect().y - s.getBoundingClientRect().y) * p + r, m = (f.getBoundingClientRect().x - s.getBoundingClientRect().x) * u + r, g = (f.getBoundingClientRect().y - s.getBoundingClientRect().y) * p + r, v = l(m, g, _, w, c, \"other\");\n                o += v, h.push(v);\n              }\n            }), a ? h.forEach((e, n) => {\n              m[t].children[n].setAttributeNS(null, \"d\", e);\n            }) : m[t].children[0].setAttributeNS(null, \"d\", o);\n          }\n        });\n      }\n      dblclick(e) {\n        null != this.connection_selected && this.reroute && this.createReroutePoint(this.connection_selected), \"point\" === e.target.classList[0] && this.removeReroutePoint(e.target);\n      }\n      createReroutePoint(e) {\n        this.connection_selected.classList.remove(\"selected\");\n        const t = this.connection_selected.parentElement.classList[2].slice(9),\n          n = this.connection_selected.parentElement.classList[1].slice(13),\n          i = this.connection_selected.parentElement.classList[3],\n          s = this.connection_selected.parentElement.classList[4];\n        this.connection_selected = null;\n        const o = document.createElementNS(\"http://www.w3.org/2000/svg\", \"circle\");\n        o.classList.add(\"point\");\n        var l = this.pos_x * (this.precanvas.clientWidth / (this.precanvas.clientWidth * this.zoom)) - this.precanvas.getBoundingClientRect().x * (this.precanvas.clientWidth / (this.precanvas.clientWidth * this.zoom)),\n          c = this.pos_y * (this.precanvas.clientHeight / (this.precanvas.clientHeight * this.zoom)) - this.precanvas.getBoundingClientRect().y * (this.precanvas.clientHeight / (this.precanvas.clientHeight * this.zoom));\n        o.setAttributeNS(null, \"cx\", l), o.setAttributeNS(null, \"cy\", c), o.setAttributeNS(null, \"r\", this.reroute_width);\n        let d = 0;\n        if (this.reroute_fix_curvature) {\n          const t = e.parentElement.querySelectorAll(\".main-path\").length;\n          var a = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n          if (a.classList.add(\"main-path\"), a.setAttributeNS(null, \"d\", \"\"), e.parentElement.insertBefore(a, e.parentElement.children[t]), 1 === t) e.parentElement.appendChild(o);else {\n            const n = Array.from(e.parentElement.children).indexOf(e);\n            d = n, e.parentElement.insertBefore(o, e.parentElement.children[n + t + 1]);\n          }\n        } else e.parentElement.appendChild(o);\n        const r = t.slice(5),\n          h = this.drawflow.drawflow[this.module].data[r].outputs[i].connections.findIndex(function (e, t) {\n            return e.node === n && e.output === s;\n          });\n        void 0 === this.drawflow.drawflow[this.module].data[r].outputs[i].connections[h].points && (this.drawflow.drawflow[this.module].data[r].outputs[i].connections[h].points = []), this.reroute_fix_curvature ? (d > 0 || this.drawflow.drawflow[this.module].data[r].outputs[i].connections[h].points !== [] ? this.drawflow.drawflow[this.module].data[r].outputs[i].connections[h].points.splice(d, 0, {\n          pos_x: l,\n          pos_y: c\n        }) : this.drawflow.drawflow[this.module].data[r].outputs[i].connections[h].points.push({\n          pos_x: l,\n          pos_y: c\n        }), e.parentElement.querySelectorAll(\".main-path\").forEach((e, t) => {\n          e.classList.remove(\"selected\");\n        })) : this.drawflow.drawflow[this.module].data[r].outputs[i].connections[h].points.push({\n          pos_x: l,\n          pos_y: c\n        }), this.dispatch(\"addReroute\", r), this.updateConnectionNodes(t);\n      }\n      removeReroutePoint(e) {\n        const t = e.parentElement.classList[2].slice(9),\n          n = e.parentElement.classList[1].slice(13),\n          i = e.parentElement.classList[3],\n          s = e.parentElement.classList[4];\n        let o = Array.from(e.parentElement.children).indexOf(e);\n        const l = t.slice(5),\n          c = this.drawflow.drawflow[this.module].data[l].outputs[i].connections.findIndex(function (e, t) {\n            return e.node === n && e.output === s;\n          });\n        if (this.reroute_fix_curvature) {\n          const t = e.parentElement.querySelectorAll(\".main-path\").length;\n          e.parentElement.children[t - 1].remove(), o -= t, o < 0 && (o = 0);\n        } else o--;\n        this.drawflow.drawflow[this.module].data[l].outputs[i].connections[c].points.splice(o, 1), e.remove(), this.dispatch(\"removeReroute\", l), this.updateConnectionNodes(t);\n      }\n      registerNode(e, t, n = null, i = null) {\n        this.noderegister[e] = {\n          html: t,\n          props: n,\n          options: i\n        };\n      }\n      getNodeFromId(e) {\n        var t = this.getModuleFromNodeId(e);\n        return JSON.parse(JSON.stringify(this.drawflow.drawflow[t].data[e]));\n      }\n      getNodesFromName(e) {\n        var t = [];\n        const n = this.drawflow.drawflow;\n        return Object.keys(n).map(function (i, s) {\n          for (var o in n[i].data) n[i].data[o].name == e && t.push(n[i].data[o].id);\n        }), t;\n      }\n      addNode(e, t, n, i, s, o, l, c, d = !1) {\n        if (this.useuuid) var a = this.getUuid();else a = this.nodeId;\n        const r = document.createElement(\"div\");\n        r.classList.add(\"parent-node\");\n        const h = document.createElement(\"div\");\n        h.innerHTML = \"\", h.setAttribute(\"id\", \"node-\" + a), h.classList.add(\"drawflow-node\"), \"\" != o && h.classList.add(...o.split(\" \"));\n        const u = document.createElement(\"div\");\n        u.classList.add(\"inputs\");\n        const p = document.createElement(\"div\");\n        p.classList.add(\"outputs\");\n        const f = {};\n        for (var m = 0; m < t; m++) {\n          const e = document.createElement(\"div\");\n          e.classList.add(\"input\"), e.classList.add(\"input_\" + (m + 1)), f[\"input_\" + (m + 1)] = {\n            connections: []\n          }, u.appendChild(e);\n        }\n        const g = {};\n        for (m = 0; m < n; m++) {\n          const e = document.createElement(\"div\");\n          e.classList.add(\"output\"), e.classList.add(\"output_\" + (m + 1)), g[\"output_\" + (m + 1)] = {\n            connections: []\n          }, p.appendChild(e);\n        }\n        const _ = document.createElement(\"div\");\n        if (_.classList.add(\"drawflow_content_node\"), !1 === d) _.innerHTML = c;else if (!0 === d) _.appendChild(this.noderegister[c].html.cloneNode(!0));else if (3 === parseInt(this.render.version)) {\n          let e = this.render.h(this.noderegister[c].html, this.noderegister[c].props, this.noderegister[c].options);\n          e.appContext = this.parent, this.render.render(e, _);\n        } else {\n          let e = new this.render({\n            parent: this.parent,\n            render: e => e(this.noderegister[c].html, {\n              props: this.noderegister[c].props\n            }),\n            ...this.noderegister[c].options\n          }).$mount();\n          _.appendChild(e.$el);\n        }\n        Object.entries(l).forEach(function (e, t) {\n          if (\"object\" == typeof e[1]) !function e(t, n, i) {\n            if (null === t) t = l[n];else t = t[n];\n            null !== t && Object.entries(t).forEach(function (n, s) {\n              if (\"object\" == typeof n[1]) e(t, n[0], i + \"-\" + n[0]);else for (var o = _.querySelectorAll(\"[df-\" + i + \"-\" + n[0] + \"]\"), l = 0; l < o.length; l++) o[l].value = n[1], o[l].isContentEditable && (o[l].innerText = n[1]);\n            });\n          }(null, e[0], e[0]);else for (var n = _.querySelectorAll(\"[df-\" + e[0] + \"]\"), i = 0; i < n.length; i++) n[i].value = e[1], n[i].isContentEditable && (n[i].innerText = e[1]);\n        }), h.appendChild(u), h.appendChild(_), h.appendChild(p), h.style.top = s + \"px\", h.style.left = i + \"px\", r.appendChild(h), this.precanvas.appendChild(r);\n        var w = {\n          id: a,\n          name: e,\n          data: l,\n          class: o,\n          html: c,\n          typenode: d,\n          inputs: f,\n          outputs: g,\n          pos_x: i,\n          pos_y: s\n        };\n        return this.drawflow.drawflow[this.module].data[a] = w, this.dispatch(\"nodeCreated\", a), this.useuuid || this.nodeId++, a;\n      }\n      addNodeImport(e, t) {\n        const n = document.createElement(\"div\");\n        n.classList.add(\"parent-node\");\n        const i = document.createElement(\"div\");\n        i.innerHTML = \"\", i.setAttribute(\"id\", \"node-\" + e.id), i.classList.add(\"drawflow-node\"), \"\" != e.class && i.classList.add(...e.class.split(\" \"));\n        const s = document.createElement(\"div\");\n        s.classList.add(\"inputs\");\n        const o = document.createElement(\"div\");\n        o.classList.add(\"outputs\"), Object.keys(e.inputs).map(function (n, i) {\n          const o = document.createElement(\"div\");\n          o.classList.add(\"input\"), o.classList.add(n), s.appendChild(o), Object.keys(e.inputs[n].connections).map(function (i, s) {\n            var o = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\"),\n              l = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n            l.classList.add(\"main-path\"), l.setAttributeNS(null, \"d\", \"\"), o.classList.add(\"connection\"), o.classList.add(\"node_in_node-\" + e.id), o.classList.add(\"node_out_node-\" + e.inputs[n].connections[i].node), o.classList.add(e.inputs[n].connections[i].input), o.classList.add(n), o.appendChild(l), t.appendChild(o);\n          });\n        });\n        for (var l = 0; l < Object.keys(e.outputs).length; l++) {\n          const e = document.createElement(\"div\");\n          e.classList.add(\"output\"), e.classList.add(\"output_\" + (l + 1)), o.appendChild(e);\n        }\n        const c = document.createElement(\"div\");\n        if (c.classList.add(\"drawflow_content_node\"), !1 === e.typenode) c.innerHTML = e.html;else if (!0 === e.typenode) c.appendChild(this.noderegister[e.html].html.cloneNode(!0));else if (3 === parseInt(this.render.version)) {\n          let t = this.render.h(this.noderegister[e.html].html, this.noderegister[e.html].props, this.noderegister[e.html].options);\n          t.appContext = this.parent, this.render.render(t, c);\n        } else {\n          let t = new this.render({\n            parent: this.parent,\n            render: t => t(this.noderegister[e.html].html, {\n              props: this.noderegister[e.html].props\n            }),\n            ...this.noderegister[e.html].options\n          }).$mount();\n          c.appendChild(t.$el);\n        }\n        Object.entries(e.data).forEach(function (t, n) {\n          if (\"object\" == typeof t[1]) !function t(n, i, s) {\n            if (null === n) n = e.data[i];else n = n[i];\n            null !== n && Object.entries(n).forEach(function (e, i) {\n              if (\"object\" == typeof e[1]) t(n, e[0], s + \"-\" + e[0]);else for (var o = c.querySelectorAll(\"[df-\" + s + \"-\" + e[0] + \"]\"), l = 0; l < o.length; l++) o[l].value = e[1], o[l].isContentEditable && (o[l].innerText = e[1]);\n            });\n          }(null, t[0], t[0]);else for (var i = c.querySelectorAll(\"[df-\" + t[0] + \"]\"), s = 0; s < i.length; s++) i[s].value = t[1], i[s].isContentEditable && (i[s].innerText = t[1]);\n        }), i.appendChild(s), i.appendChild(c), i.appendChild(o), i.style.top = e.pos_y + \"px\", i.style.left = e.pos_x + \"px\", n.appendChild(i), this.precanvas.appendChild(n);\n      }\n      addRerouteImport(e) {\n        const t = this.reroute_width,\n          n = this.reroute_fix_curvature,\n          i = this.container;\n        Object.keys(e.outputs).map(function (s, o) {\n          Object.keys(e.outputs[s].connections).map(function (o, l) {\n            const c = e.outputs[s].connections[o].points;\n            void 0 !== c && c.forEach((l, d) => {\n              const a = e.outputs[s].connections[o].node,\n                r = e.outputs[s].connections[o].output,\n                h = i.querySelector(\".connection.node_in_node-\" + a + \".node_out_node-\" + e.id + \".\" + s + \".\" + r);\n              if (n && 0 === d) for (var u = 0; u < c.length; u++) {\n                var p = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n                p.classList.add(\"main-path\"), p.setAttributeNS(null, \"d\", \"\"), h.appendChild(p);\n              }\n              const f = document.createElementNS(\"http://www.w3.org/2000/svg\", \"circle\");\n              f.classList.add(\"point\");\n              var m = l.pos_x,\n                g = l.pos_y;\n              f.setAttributeNS(null, \"cx\", m), f.setAttributeNS(null, \"cy\", g), f.setAttributeNS(null, \"r\", t), h.appendChild(f);\n            });\n          });\n        });\n      }\n      updateNodeValue(e) {\n        for (var t = e.target.attributes, n = 0; n < t.length; n++) if (t[n].nodeName.startsWith(\"df-\")) {\n          for (var i = t[n].nodeName.slice(3).split(\"-\"), s = this.drawflow.drawflow[this.module].data[e.target.closest(\".drawflow_content_node\").parentElement.id.slice(5)].data, o = 0; o < i.length - 1; o += 1) null == s[i[o]] && (s[i[o]] = {}), s = s[i[o]];\n          s[i[i.length - 1]] = e.target.value, e.target.isContentEditable && (s[i[i.length - 1]] = e.target.innerText), this.dispatch(\"nodeDataChanged\", e.target.closest(\".drawflow_content_node\").parentElement.id.slice(5));\n        }\n      }\n      updateNodeDataFromId(e, t) {\n        var n = this.getModuleFromNodeId(e);\n        if (this.drawflow.drawflow[n].data[e].data = t, this.module === n) {\n          const n = this.container.querySelector(\"#node-\" + e);\n          Object.entries(t).forEach(function (e, i) {\n            if (\"object\" == typeof e[1]) !function e(i, s, o) {\n              if (null === i) i = t[s];else i = i[s];\n              null !== i && Object.entries(i).forEach(function (t, s) {\n                if (\"object\" == typeof t[1]) e(i, t[0], o + \"-\" + t[0]);else for (var l = n.querySelectorAll(\"[df-\" + o + \"-\" + t[0] + \"]\"), c = 0; c < l.length; c++) l[c].value = t[1], l[c].isContentEditable && (l[c].innerText = t[1]);\n              });\n            }(null, e[0], e[0]);else for (var s = n.querySelectorAll(\"[df-\" + e[0] + \"]\"), o = 0; o < s.length; o++) s[o].value = e[1], s[o].isContentEditable && (s[o].innerText = e[1]);\n          });\n        }\n      }\n      addNodeInput(e) {\n        var t = this.getModuleFromNodeId(e);\n        const n = this.getNodeFromId(e),\n          i = Object.keys(n.inputs).length;\n        if (this.module === t) {\n          const t = document.createElement(\"div\");\n          t.classList.add(\"input\"), t.classList.add(\"input_\" + (i + 1)), this.container.querySelector(\"#node-\" + e + \" .inputs\").appendChild(t), this.updateConnectionNodes(\"node-\" + e);\n        }\n        this.drawflow.drawflow[t].data[e].inputs[\"input_\" + (i + 1)] = {\n          connections: []\n        };\n      }\n      addNodeOutput(e) {\n        var t = this.getModuleFromNodeId(e);\n        const n = this.getNodeFromId(e),\n          i = Object.keys(n.outputs).length;\n        if (this.module === t) {\n          const t = document.createElement(\"div\");\n          t.classList.add(\"output\"), t.classList.add(\"output_\" + (i + 1)), this.container.querySelector(\"#node-\" + e + \" .outputs\").appendChild(t), this.updateConnectionNodes(\"node-\" + e);\n        }\n        this.drawflow.drawflow[t].data[e].outputs[\"output_\" + (i + 1)] = {\n          connections: []\n        };\n      }\n      removeNodeInput(e, t) {\n        var n = this.getModuleFromNodeId(e);\n        const i = this.getNodeFromId(e);\n        this.module === n && this.container.querySelector(\"#node-\" + e + \" .inputs .input.\" + t).remove();\n        const s = [];\n        Object.keys(i.inputs[t].connections).map(function (n, o) {\n          const l = i.inputs[t].connections[o].node,\n            c = i.inputs[t].connections[o].input;\n          s.push({\n            id_output: l,\n            id: e,\n            output_class: c,\n            input_class: t\n          });\n        }), s.forEach((e, t) => {\n          this.removeSingleConnection(e.id_output, e.id, e.output_class, e.input_class);\n        }), delete this.drawflow.drawflow[n].data[e].inputs[t];\n        const o = [],\n          l = this.drawflow.drawflow[n].data[e].inputs;\n        Object.keys(l).map(function (e, t) {\n          o.push(l[e]);\n        }), this.drawflow.drawflow[n].data[e].inputs = {};\n        const c = t.slice(6);\n        let d = [];\n        if (o.forEach((t, i) => {\n          t.connections.forEach((e, t) => {\n            d.push(e);\n          }), this.drawflow.drawflow[n].data[e].inputs[\"input_\" + (i + 1)] = t;\n        }), d = new Set(d.map(e => JSON.stringify(e))), d = Array.from(d).map(e => JSON.parse(e)), this.module === n) {\n          this.container.querySelectorAll(\"#node-\" + e + \" .inputs .input\").forEach((e, t) => {\n            const n = e.classList[1].slice(6);\n            parseInt(c) < parseInt(n) && (e.classList.remove(\"input_\" + n), e.classList.add(\"input_\" + (n - 1)));\n          });\n        }\n        d.forEach((t, i) => {\n          this.drawflow.drawflow[n].data[t.node].outputs[t.input].connections.forEach((i, s) => {\n            if (i.node == e) {\n              const o = i.output.slice(6);\n              if (parseInt(c) < parseInt(o)) {\n                if (this.module === n) {\n                  const n = this.container.querySelector(\".connection.node_in_node-\" + e + \".node_out_node-\" + t.node + \".\" + t.input + \".input_\" + o);\n                  n.classList.remove(\"input_\" + o), n.classList.add(\"input_\" + (o - 1));\n                }\n                i.points ? this.drawflow.drawflow[n].data[t.node].outputs[t.input].connections[s] = {\n                  node: i.node,\n                  output: \"input_\" + (o - 1),\n                  points: i.points\n                } : this.drawflow.drawflow[n].data[t.node].outputs[t.input].connections[s] = {\n                  node: i.node,\n                  output: \"input_\" + (o - 1)\n                };\n              }\n            }\n          });\n        }), this.updateConnectionNodes(\"node-\" + e);\n      }\n      removeNodeOutput(e, t) {\n        var n = this.getModuleFromNodeId(e);\n        const i = this.getNodeFromId(e);\n        this.module === n && this.container.querySelector(\"#node-\" + e + \" .outputs .output.\" + t).remove();\n        const s = [];\n        Object.keys(i.outputs[t].connections).map(function (n, o) {\n          const l = i.outputs[t].connections[o].node,\n            c = i.outputs[t].connections[o].output;\n          s.push({\n            id: e,\n            id_input: l,\n            output_class: t,\n            input_class: c\n          });\n        }), s.forEach((e, t) => {\n          this.removeSingleConnection(e.id, e.id_input, e.output_class, e.input_class);\n        }), delete this.drawflow.drawflow[n].data[e].outputs[t];\n        const o = [],\n          l = this.drawflow.drawflow[n].data[e].outputs;\n        Object.keys(l).map(function (e, t) {\n          o.push(l[e]);\n        }), this.drawflow.drawflow[n].data[e].outputs = {};\n        const c = t.slice(7);\n        let d = [];\n        if (o.forEach((t, i) => {\n          t.connections.forEach((e, t) => {\n            d.push({\n              node: e.node,\n              output: e.output\n            });\n          }), this.drawflow.drawflow[n].data[e].outputs[\"output_\" + (i + 1)] = t;\n        }), d = new Set(d.map(e => JSON.stringify(e))), d = Array.from(d).map(e => JSON.parse(e)), this.module === n) {\n          this.container.querySelectorAll(\"#node-\" + e + \" .outputs .output\").forEach((e, t) => {\n            const n = e.classList[1].slice(7);\n            parseInt(c) < parseInt(n) && (e.classList.remove(\"output_\" + n), e.classList.add(\"output_\" + (n - 1)));\n          });\n        }\n        d.forEach((t, i) => {\n          this.drawflow.drawflow[n].data[t.node].inputs[t.output].connections.forEach((i, s) => {\n            if (i.node == e) {\n              const o = i.input.slice(7);\n              if (parseInt(c) < parseInt(o)) {\n                if (this.module === n) {\n                  const n = this.container.querySelector(\".connection.node_in_node-\" + t.node + \".node_out_node-\" + e + \".output_\" + o + \".\" + t.output);\n                  n.classList.remove(\"output_\" + o), n.classList.remove(t.output), n.classList.add(\"output_\" + (o - 1)), n.classList.add(t.output);\n                }\n                i.points ? this.drawflow.drawflow[n].data[t.node].inputs[t.output].connections[s] = {\n                  node: i.node,\n                  input: \"output_\" + (o - 1),\n                  points: i.points\n                } : this.drawflow.drawflow[n].data[t.node].inputs[t.output].connections[s] = {\n                  node: i.node,\n                  input: \"output_\" + (o - 1)\n                };\n              }\n            }\n          });\n        }), this.updateConnectionNodes(\"node-\" + e);\n      }\n      removeNodeId(e) {\n        this.removeConnectionNodeId(e);\n        var t = this.getModuleFromNodeId(e.slice(5));\n        this.module === t && this.container.querySelector(\"#\" + e).remove(), delete this.drawflow.drawflow[t].data[e.slice(5)], this.dispatch(\"nodeRemoved\", e.slice(5));\n      }\n      removeConnection() {\n        if (null != this.connection_selected) {\n          var e = this.connection_selected.parentElement.classList;\n          this.connection_selected.parentElement.remove();\n          var t = this.drawflow.drawflow[this.module].data[e[2].slice(14)].outputs[e[3]].connections.findIndex(function (t, n) {\n            return t.node === e[1].slice(13) && t.output === e[4];\n          });\n          this.drawflow.drawflow[this.module].data[e[2].slice(14)].outputs[e[3]].connections.splice(t, 1);\n          var n = this.drawflow.drawflow[this.module].data[e[1].slice(13)].inputs[e[4]].connections.findIndex(function (t, n) {\n            return t.node === e[2].slice(14) && t.input === e[3];\n          });\n          this.drawflow.drawflow[this.module].data[e[1].slice(13)].inputs[e[4]].connections.splice(n, 1), this.dispatch(\"connectionRemoved\", {\n            output_id: e[2].slice(14),\n            input_id: e[1].slice(13),\n            output_class: e[3],\n            input_class: e[4]\n          }), this.connection_selected = null;\n        }\n      }\n      removeSingleConnection(e, t, n, i) {\n        var s = this.getModuleFromNodeId(e);\n        if (s === this.getModuleFromNodeId(t)) {\n          if (this.drawflow.drawflow[s].data[e].outputs[n].connections.findIndex(function (e, n) {\n            return e.node == t && e.output === i;\n          }) > -1) {\n            this.module === s && this.container.querySelector(\".connection.node_in_node-\" + t + \".node_out_node-\" + e + \".\" + n + \".\" + i).remove();\n            var o = this.drawflow.drawflow[s].data[e].outputs[n].connections.findIndex(function (e, n) {\n              return e.node == t && e.output === i;\n            });\n            this.drawflow.drawflow[s].data[e].outputs[n].connections.splice(o, 1);\n            var l = this.drawflow.drawflow[s].data[t].inputs[i].connections.findIndex(function (t, i) {\n              return t.node == e && t.input === n;\n            });\n            return this.drawflow.drawflow[s].data[t].inputs[i].connections.splice(l, 1), this.dispatch(\"connectionRemoved\", {\n              output_id: e,\n              input_id: t,\n              output_class: n,\n              input_class: i\n            }), !0;\n          }\n          return !1;\n        }\n        return !1;\n      }\n      removeConnectionNodeId(e) {\n        const t = \"node_in_\" + e,\n          n = \"node_out_\" + e,\n          i = this.container.querySelectorAll(\".\" + n);\n        for (var s = i.length - 1; s >= 0; s--) {\n          var o = i[s].classList,\n            l = this.drawflow.drawflow[this.module].data[o[1].slice(13)].inputs[o[4]].connections.findIndex(function (e, t) {\n              return e.node === o[2].slice(14) && e.input === o[3];\n            });\n          this.drawflow.drawflow[this.module].data[o[1].slice(13)].inputs[o[4]].connections.splice(l, 1);\n          var c = this.drawflow.drawflow[this.module].data[o[2].slice(14)].outputs[o[3]].connections.findIndex(function (e, t) {\n            return e.node === o[1].slice(13) && e.output === o[4];\n          });\n          this.drawflow.drawflow[this.module].data[o[2].slice(14)].outputs[o[3]].connections.splice(c, 1), i[s].remove(), this.dispatch(\"connectionRemoved\", {\n            output_id: o[2].slice(14),\n            input_id: o[1].slice(13),\n            output_class: o[3],\n            input_class: o[4]\n          });\n        }\n        const d = this.container.querySelectorAll(\".\" + t);\n        for (s = d.length - 1; s >= 0; s--) {\n          o = d[s].classList, c = this.drawflow.drawflow[this.module].data[o[2].slice(14)].outputs[o[3]].connections.findIndex(function (e, t) {\n            return e.node === o[1].slice(13) && e.output === o[4];\n          });\n          this.drawflow.drawflow[this.module].data[o[2].slice(14)].outputs[o[3]].connections.splice(c, 1);\n          l = this.drawflow.drawflow[this.module].data[o[1].slice(13)].inputs[o[4]].connections.findIndex(function (e, t) {\n            return e.node === o[2].slice(14) && e.input === o[3];\n          });\n          this.drawflow.drawflow[this.module].data[o[1].slice(13)].inputs[o[4]].connections.splice(l, 1), d[s].remove(), this.dispatch(\"connectionRemoved\", {\n            output_id: o[2].slice(14),\n            input_id: o[1].slice(13),\n            output_class: o[3],\n            input_class: o[4]\n          });\n        }\n      }\n      getModuleFromNodeId(e) {\n        var t;\n        const n = this.drawflow.drawflow;\n        return Object.keys(n).map(function (i, s) {\n          Object.keys(n[i].data).map(function (n, s) {\n            n == e && (t = i);\n          });\n        }), t;\n      }\n      addModule(e) {\n        this.drawflow.drawflow[e] = {\n          data: {}\n        }, this.dispatch(\"moduleCreated\", e);\n      }\n      changeModule(e) {\n        this.dispatch(\"moduleChanged\", e), this.module = e, this.precanvas.innerHTML = \"\", this.canvas_x = 0, this.canvas_y = 0, this.pos_x = 0, this.pos_y = 0, this.mouse_x = 0, this.mouse_y = 0, this.zoom = 1, this.zoom_last_value = 1, this.precanvas.style.transform = \"\", this.import(this.drawflow, !1);\n      }\n      removeModule(e) {\n        this.module === e && this.changeModule(\"Home\"), delete this.drawflow.drawflow[e], this.dispatch(\"moduleRemoved\", e);\n      }\n      clearModuleSelected() {\n        this.precanvas.innerHTML = \"\", this.drawflow.drawflow[this.module] = {\n          data: {}\n        };\n      }\n      clear() {\n        this.precanvas.innerHTML = \"\", this.drawflow = {\n          drawflow: {\n            Home: {\n              data: {}\n            }\n          }\n        };\n      }\n      export() {\n        const e = JSON.parse(JSON.stringify(this.drawflow));\n        return this.dispatch(\"export\", e), e;\n      }\n      import(e, t = !0) {\n        this.clear(), this.drawflow = JSON.parse(JSON.stringify(e)), this.load(), t && this.dispatch(\"import\", \"import\");\n      }\n      on(e, t) {\n        return \"function\" != typeof t ? (console.error(\"The listener callback must be a function, the given type is \" + typeof t), !1) : \"string\" != typeof e ? (console.error(\"The event name must be a string, the given type is \" + typeof e), !1) : (void 0 === this.events[e] && (this.events[e] = {\n          listeners: []\n        }), void this.events[e].listeners.push(t));\n      }\n      removeListener(e, t) {\n        if (!this.events[e]) return !1;\n        const n = this.events[e].listeners,\n          i = n.indexOf(t);\n        i > -1 && n.splice(i, 1);\n      }\n      dispatch(e, t) {\n        if (void 0 === this.events[e]) return !1;\n        this.events[e].listeners.forEach(e => {\n          e(t);\n        });\n      }\n      getUuid() {\n        for (var e = [], t = 0; t < 36; t++) e[t] = \"0123456789abcdef\".substr(Math.floor(16 * Math.random()), 1);\n        return e[14] = \"4\", e[19] = \"0123456789abcdef\".substr(3 & e[19] | 8, 1), e[8] = e[13] = e[18] = e[23] = \"-\", e.join(\"\");\n      }\n    }\n  }]).default;\n});","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}
{"ast":null,"code":"import { __decorate } from \"tslib\";\nimport { Component, ViewEncapsulation, HostListener } from '@angular/core';\nimport { NodeDialogComponent } from './node-dialog/node-dialog.component';\nimport Drawflow from 'drawflow';\nimport interact from 'interactjs';\nimport { environment } from '../environments/environment';\nlet AppComponent = class AppComponent {\n  dialog;\n  http;\n  drawflow;\n  id = null;\n  items = [{\n    name: 'Node 1',\n    params: '',\n    file: null\n  }];\n  newItemName = '';\n  workflows = [];\n  currentWorkflow = '';\n  apiUrl = environment.apiUrl;\n  constructor(dialog, http) {\n    this.dialog = dialog;\n    this.http = http;\n  }\n  ngOnInit() {\n    this.id = document.getElementById('drawflow');\n    this.drawflow = new Drawflow(this.id);\n    this.drawflow.start();\n    const savedWorkflow = localStorage.getItem('workflowData');\n    if (savedWorkflow) {\n      this.importWorkflow(savedWorkflow);\n    }\n    interact('.draggable-item').draggable({\n      inertia: true,\n      autoScroll: true,\n      onstart: event => {\n        const target = event.target;\n        const rect = target.getBoundingClientRect();\n        target.setAttribute('data-start-x', rect.left);\n        target.setAttribute('data-start-y', rect.top);\n      },\n      onmove: this.dragMoveListener,\n      onend: event => {\n        if (!event.target.dropzone) {\n          const startX = event.target.getAttribute('data-start-x');\n          const startY = event.target.getAttribute('data-start-y');\n          event.target.style.transform = 'translate(0px, 0px)';\n          event.target.style.left = `${startX}px`;\n          event.target.style.top = `${startY}px`;\n          event.target.removeAttribute('data-x');\n          event.target.removeAttribute('data-y');\n        }\n      }\n    });\n    interact('#drawflow').dropzone({\n      accept: '.draggable-item',\n      overlap: 0.75,\n      ondrop: event => {\n        const nodeName = event.relatedTarget.getAttribute('data-node-name');\n        const x = event.dragEvent.clientX - event.target.getBoundingClientRect().left - 300;\n        const y = event.dragEvent.clientY - event.target.getBoundingClientRect().top - 40;\n        this.addNode(nodeName, x, y);\n      },\n      ondropdeactivate: event => {\n        const startX = event.relatedTarget.getAttribute('data-start-x');\n        const startY = event.relatedTarget.getAttribute('data-start-y');\n        event.relatedTarget.style.transform = 'translate(0px, 0px)';\n        event.relatedTarget.style.left = `${startX}px`;\n        event.relatedTarget.style.top = `${startY}px`;\n        event.relatedTarget.removeAttribute('data-x');\n        event.relatedTarget.removeAttribute('data-y');\n      }\n    });\n    this.drawflow.on('connectionCreated', event => {\n      const outputNode = this.drawflow.getNodeFromId(event.output_id);\n      const inputNode = this.drawflow.getNodeFromId(event.input_id);\n      if (outputNode.name === inputNode.name) {\n        alert('Error: Cannot connect two consecutive nodes with the same name!');\n        this.drawflow.removeSingleConnection(event.output_id, event.input_id, event.output_class, event.input_class);\n      } else if (this.hasCycle()) {\n        alert('Error: Cycle detected in the workflow!');\n        this.drawflow.removeSingleConnection(event.output_id, event.input_id, event.output_class, event.input_class);\n      }\n    });\n    this.id.addEventListener('dblclick', event => {\n      const target = event.target;\n      const nodeElement = target.closest('.drawflow-node');\n      if (nodeElement) {\n        const nodeId = nodeElement.id.replace('node-', '');\n        const node = this.drawflow.getNodeFromId(nodeId);\n        const index = this.items.findIndex(item => item.name === node.name);\n        if (index !== -1) {\n          this.openEditDialog(index);\n        }\n      }\n    });\n  }\n  unloadNotification($event) {\n    const workflowData = this.drawflow.export();\n    const processedData = this.processWorkflowData(workflowData);\n    localStorage.setItem('workflowData', JSON.stringify(processedData));\n  }\n  openDialog() {\n    const dialogRef = this.dialog.open(NodeDialogComponent, {\n      width: '300px',\n      data: {\n        name: '',\n        mode: 'create',\n        params: ''\n      }\n    });\n    dialogRef.afterClosed().subscribe(result => {\n      if (result && result.action === 'create') {\n        this.newItemName = result.name;\n        const newItemParams = result.params;\n        if (typeof this.newItemName === 'string') {\n          this.items.push({\n            name: this.newItemName,\n            params: newItemParams,\n            file: result.file\n          });\n        }\n      }\n    });\n  }\n  loadWorkflows() {\n    this.http.get(`${this.apiUrl}/workflows`).subscribe(data => {\n      this.workflows = data;\n    });\n  }\n  openCreateWorkflowDialog() {\n    const dialogRef = this.dialog.open(NodeDialogComponent, {\n      width: '300px',\n      data: {\n        name: '',\n        mode: 'createWorkflow'\n      }\n    });\n    dialogRef.afterClosed().subscribe(result => {\n      if (result && result.name) {\n        this.createWorkflow(result.name);\n      }\n    });\n  }\n  createWorkflow(name) {\n    this.http.post(`${this.apiUrl}/create`, {\n      name\n    }).subscribe(() => {\n      this.loadWorkflows(); // Reload workflows after creating a new one\n      this.currentWorkflow = name;\n      this.clearWorkflow();\n    });\n  }\n  saveWorkflow() {\n    const workflowData = this.drawflow.export();\n    const processedData = this.processWorkflowData(workflowData);\n    this.http.post(`${this.apiUrl}/workflow/save`, {\n      name: this.currentWorkflow,\n      data: processedData\n    }).subscribe(() => {\n      console.log('Workflow saved successfully');\n    });\n  }\n  onWorkflowChange(event) {\n    const selectedWorkflow = event.target.value;\n    this.loadWorkflow(selectedWorkflow);\n  }\n  loadWorkflows() {\n    this.http.get(`${this.apiUrl}/workflows`).subscribe(data => {\n      this.workflows = data;\n    });\n  }\n  deleteWorkflow() {\n    if (this.currentWorkflow) {\n      this.http.delete(`${this.apiUrl}/workflow/${this.currentWorkflow}`).subscribe(() => {\n        this.workflows = this.workflows.filter(w => w !== this.currentWorkflow);\n        this.currentWorkflow = '';\n        this.clearWorkflow();\n      });\n    }\n  }\n  openContextMenu(event, index) {\n    const contextMenu = document.createElement('div');\n    contextMenu.classList.add('context-menu');\n    contextMenu.style.top = `${event.clientY}px`;\n    contextMenu.style.left = `${event.clientX}px`;\n    const editItem = document.createElement('div');\n    editItem.classList.add('context-menu-item');\n    editItem.innerText = 'Edit';\n    editItem.addEventListener('click', () => {\n      this.openEditDialog(index);\n      document.body.removeChild(contextMenu);\n    });\n    const deleteItem = document.createElement('div');\n    deleteItem.classList.add('context-menu-item');\n    deleteItem.innerText = 'Delete';\n    deleteItem.addEventListener('click', () => {\n      this.deleteItem(index);\n      document.body.removeChild(contextMenu);\n    });\n    contextMenu.appendChild(editItem);\n    contextMenu.appendChild(deleteItem);\n    const existingMenu = document.querySelector('.context-menu');\n    if (existingMenu) {\n      document.body.removeChild(existingMenu);\n    }\n    document.body.appendChild(contextMenu);\n    document.addEventListener('click', () => {\n      if (contextMenu) {\n        document.body.removeChild(contextMenu);\n      }\n    }, {\n      once: true\n    });\n  }\n  dragMoveListener(event) {\n    const target = event.target;\n    const x = (parseFloat(target.getAttribute('data-x')) || 0) + event.dx;\n    const y = (parseFloat(target.getAttribute('data-y')) || 0) + event.dy;\n    target.style.transform = `translate(${x}px, ${y}px)`;\n    target.setAttribute('data-x', x);\n    target.setAttribute('data-y', y);\n  }\n  addNode(nodeName, x, y) {\n    var html = document.createElement('div');\n    html.innerHTML = nodeName;\n    this.drawflow.registerNode('test', html);\n    return this.drawflow.addNode(nodeName, 1, 1, x, y, 'github', this.items, 'test', true);\n  }\n  openEditDialog(index) {\n    const dialogRef = this.dialog.open(NodeDialogComponent, {\n      width: '300px',\n      maxWidth: '100%',\n      data: {\n        name: this.items[index].name,\n        params: this.items[index].params,\n        file: this.items[index].file,\n        index: index,\n        mode: 'edit'\n      }\n    });\n    dialogRef.afterClosed().subscribe(result => {\n      if (result && result.action === 'save') {\n        this.items[index].name = result.name;\n        this.items[index].params = result.params;\n        if (result.file) {\n          this.items[index].file = result.file;\n        }\n      } else if (result && result.action === 'delete') {\n        this.deleteItem(index);\n      }\n    });\n  }\n  uploadFile(file, index) {\n    const formData = new FormData();\n    formData.append('file', file);\n    this.items[index].file = file;\n    console.log(this.items);\n  }\n  removeNodeFromDrawflow(index) {\n    const item = document.querySelector(`.draggable-item[data-index=\"${index}\"]`);\n    if (item) {\n      item.style.display = 'none';\n      setTimeout(() => {\n        item.style.display = '';\n      }, 0);\n    }\n  }\n  runWorkflow() {\n    for (const item of this.items) {\n      if (!item.file && item.file === 'none' && item.file === '') {\n        alert(`Error: Node \"${item.name}\" does not have an associated file.`);\n        return;\n      }\n    }\n    const workflowData = this.drawflow.export();\n    const processedData = this.processWorkflowData(workflowData);\n    this.sendWorkflowData(processedData);\n  }\n  sendWorkflowData(workflowData) {\n    const formData = new FormData();\n    formData.append('workflowData', JSON.stringify(workflowData, null, 2));\n    workflowData.nodes.forEach((node, index) => {\n      if (node.file) {\n        formData.append(node.name, node.file);\n      }\n    });\n    const url = `${this.apiUrl}/upload_workflow`;\n    fetch(url, {\n      method: 'POST',\n      body: formData\n    }).then(response => response.json()).then(data => {\n      console.log('Workflow data uploaded successfully:', data);\n    }).catch(error => {\n      console.error('Error uploading workflow data:', error);\n    });\n    console.log('Sending workflow data to server:', workflowData);\n  }\n  createNode() {\n    const nodeNameInput = document.getElementById('nodeNameInput');\n    const nodeName = nodeNameInput.value;\n    if (nodeName) {\n      this.addNode(nodeName, 50, 50);\n      nodeNameInput.value = '';\n    } else {\n      alert('Please enter a node name');\n    }\n  }\n  addItem() {\n    if (this.newItemName) {\n      if (this.items.some(item => item.name === this.newItemName)) {\n        alert('Item with this name already exists');\n      } else {\n        this.items.push({\n          name: this.newItemName,\n          params: '',\n          file: null\n        });\n        this.newItemName = '';\n      }\n    } else {\n      alert('Please enter an item name');\n    }\n  }\n  deleteItem(index) {\n    this.items.splice(index, 1);\n    console.log(this.items);\n  }\n  importWorkflow(jsonData) {\n    this.items.length = 0;\n    try {\n      const workflowData = JSON.parse(jsonData);\n      if (!this.drawflow) {\n        this.id = document.getElementById('drawflow');\n        this.drawflow = new Drawflow(this.id);\n        this.drawflow.start();\n      } else {\n        this.drawflow.clear();\n      }\n      const nodeIdMap = new Map();\n      const nodeNamesSet = new Set();\n      workflowData.nodes.forEach(node => {\n        const nodeId = this.addNode(node.name, node.position.x, node.position.y);\n        nodeIdMap.set(node.name, nodeId);\n        const drawflowNode = this.drawflow.getNodeFromId(nodeId);\n        drawflowNode.data = {\n          params: node.params,\n          file: node.file\n        };\n        if (!nodeNamesSet.has(node.name)) {\n          nodeNamesSet.add(node.name);\n          this.items.push({\n            name: node.name,\n            params: JSON.stringify(node.params),\n            file: node.file\n          });\n        } else {\n          console.warn(`Duplicate node name found: ${node.name}. Skipping this node.`);\n        }\n      });\n      workflowData.nodes.forEach(node => {\n        node.connections.forEach(connection => {\n          const outputNodeId = nodeIdMap.get(node.name);\n          const inputNodeId = nodeIdMap.get(connection);\n          if (outputNodeId && inputNodeId) {\n            this.drawflow.addConnection(outputNodeId, inputNodeId, 'output_1', 'input_1');\n          }\n        });\n      });\n      console.log('Workflow imported successfully:', workflowData);\n    } catch (error) {\n      console.error('Error importing workflow data:', error);\n    }\n  }\n  onFileSelected(event) {\n    const file = event.target.files[0];\n    if (file) {\n      const reader = new FileReader();\n      reader.onload = e => {\n        const jsonData = e.target.result;\n        this.importWorkflow(jsonData);\n      };\n      reader.readAsText(file);\n    }\n  }\n  clearWorkflow() {\n    this.drawflow.clear();\n    window.location.reload();\n  }\n  exportWorkflow() {\n    const workflowData = this.drawflow.export();\n    const processedData = this.processWorkflowData(workflowData);\n    console.log('Exported Workflow Data:', processedData);\n    this.downloadWorkflow(processedData);\n  }\n  triggerFileInput() {\n    const fileInput = document.querySelector('input[type=\"file\"]');\n    if (fileInput) {\n      fileInput.click();\n    }\n  }\n  processWorkflowData(workflowData) {\n    const processedData = {\n      nodes: []\n    };\n    for (const key in workflowData.drawflow.Home.data) {\n      const node = workflowData.drawflow.Home.data[key];\n      const item = this.items.find(item => item.name === node.name);\n      const connections = [];\n      for (const outputKey in node.outputs) {\n        const outputConnections = node.outputs[outputKey].connections;\n        for (const connection of outputConnections) {\n          const connectedNode = workflowData.drawflow.Home.data[connection.node];\n          connections.push(connectedNode.name);\n        }\n      }\n      processedData.nodes.push({\n        id: node.id,\n        name: node.name,\n        params: item ? typeof item.params === 'string' ? JSON.parse(item.params) : item.params : {},\n        file: item ? item.file : null,\n        filePath: item && item.file ? item.file.path : null,\n        connections: connections,\n        position: {\n          x: node.pos_x,\n          y: node.pos_y\n        }\n      });\n    }\n    return processedData;\n  }\n  downloadWorkflow(workflowData) {\n    const dataStr = JSON.stringify(workflowData, null, 2);\n    const blob = new Blob([dataStr], {\n      type: 'application/json'\n    });\n    const url = URL.createObjectURL(blob);\n    const a = document.createElement('a');\n    a.href = url;\n    a.download = 'workflow.json';\n    document.body.appendChild(a);\n    a.click();\n    document.body.removeChild(a);\n    URL.revokeObjectURL(url);\n  }\n  hasCycle() {\n    const workflowData = this.drawflow.export();\n    const graph = this.buildGraph(workflowData);\n    return this.detectCycle(graph);\n  }\n  buildGraph(workflowData) {\n    const graph = new Map();\n    for (const key in workflowData.drawflow.Home.data) {\n      const node = workflowData.drawflow.Home.data[key];\n      graph.set(key, []);\n      for (const outputKey in node.outputs) {\n        const connections = node.outputs[outputKey].connections;\n        for (const connection of connections) {\n          graph.get(key).push(connection.node);\n        }\n      }\n    }\n    return graph;\n  }\n  detectCycle(graph) {\n    const visited = new Set();\n    const recStack = new Set();\n    const dfs = node => {\n      if (!visited.has(node)) {\n        visited.add(node);\n        recStack.add(node);\n        const neighbors = graph.get(node) || [];\n        for (const neighbor of neighbors) {\n          if (!visited.has(neighbor) && dfs(neighbor)) {\n            return true;\n          } else if (recStack.has(neighbor)) {\n            return true;\n          }\n        }\n      }\n      recStack.delete(node);\n      return false;\n    };\n    for (const node of graph.keys()) {\n      if (dfs(node)) {\n        return true;\n      }\n    }\n    return false;\n  }\n};\n__decorate([HostListener('window:beforeunload', ['$event'])], AppComponent.prototype, \"unloadNotification\", null);\nAppComponent = __decorate([Component({\n  selector: 'my-app',\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css'],\n  encapsulation: ViewEncapsulation.None\n})], AppComponent);\nexport { AppComponent };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}